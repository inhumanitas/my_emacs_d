;/****************************************************************************
**
** Copyright (C) 2009 BARS Group.
** Contact: BARS Group (bars@bars-open.ru)
**
****************************************************************************/

    #include "browse.ch"
    #include "global.ch"
    #include "ord.ch"
    #include "gui.ch"

// Длина описания счета в з/плате ( еще надо поменять в MIDDL.PRG )
    #define LEN_DESC_ACC 8

    #define COMP_TABL   {   ;
                            { "11", "211" }, ;
                            { "12", "212" }, ;
                            { "13", "213" }, ;
                            { "21", "221" }, ;
                            { "22", "222" }, ;
                            { "23", "223" }, ;
                            { "24", "224" }, ;
                            { "25", "225" }, ;
                            { "26", "226" } ;
                        }

    STATIC asType := { "П/Н", "П/Нкфц", "П/Нмат" }
    STATIC asProftType := { "П/Н", "П/НК", "П/НМ" }


    MEMVAR cEnt, Ent, Year, SprPath
    MEMVAR Path


*------------------------------------------------------*
*   Заработная плата

    PROCEDURE Wages()
*------------------------------------------------------*
    LOCAL cFileName := FILE_NAME( "WAGES", Ent,,Year )
    LOCAL cDescName := FILEDESC( "WAGES" )
    LOCAL cJobName  := FILE_NAME( "JOBTB", Ent,,Year )

    PRIVATE aPlusArr
    PRIVATE aMinusArr
    PRIVATE cpWageCodeSay := {"",""}

    // Штатные сотрудники
    PRIVATE npFacesType := 10
    PRIVATE apWageJobtb := {}  //информация из табеля (по TAB)

    PRIVATE opUT := UTables():new() // Открытые таблицы
    PRIVATE ohTax := Hash():new() // для подоходного налога (ускорение расчета)

    SAVESET()

    BEGIN SEQUENCE

        BeginStatus()

        SayStatus( "Чтение конфигурации по зарплате" )

        IF MacroRun(MEMVAR->ModMacPath + "checkrefer.mac") < 1.5
            BREAK
        ENDIF
        // Установка записи на конф. по з/п и SCOPE на разрядную сетку
        IF ! OpenWconfByDate( BOM( MEMVAR->DATE ) )
            BREAK
        ENDIF

        // создание и открытие архива сотрудников
        SayStatus( "Инициализация архива сотрудников" )
        IF .NOT. MODINIT( { "JOBS_", "PERSN", "CALCR"/*, "DEDCT"*/ } )
            BREAK
        ENDIF

        // Открытие заработной платы и табеля рабочего времени
        SayStatus( "Инициализация тарификации" )
        IF .NOT. MODINIT( { "TARIF", "TRREC", "TRLIN" },, ,MEMVAR->Ent )
            BREAK
        ENDIF

        SayStatus( "Инициализация ведомостей" )
        IF .NOT. MODINIT( { "SHEET", "SHLST" }, MEMVAR->Year )
            BREAK
        ENDIF

        // Открытие заработной платы и табеля рабочего времени
        SayStatus( "Инициализация зарплаты и табеля" )
        IF .NOT. MODINIT( { "WAGES", "JOBTB", "JOBTD", "CALCS", "OUTCM" }, Year, , MEMVAR->Ent )
            BREAK
        ENDIF

        //выбор отделов
        SelectEntGroup()

        SayStatus( "Подготовка справочников" )
        IF ! ReferInit( { "PYMNT", "ENTTB", "PRSCT", "SUCH", "POSTS", "ACCNT", "ACKGU" } )
            BREAK
        ENDIF

        SayStatus( "Установка связей" )

        InitWageRelation()

        GO TOP
        EndStatus()

        // Установка на клавишу ТАБ карточки

        WindOpen( "Wages",,"Заработная плата за "+ REMALL( SayDate( MEMVAR->Date, "MMMMM YYYY г." ) ) +" по учреждению " + cEnt )
        SetBKey( Qt_Key_Tab, {|| WagesCard() } )
        SetFKey({"Помощь;Help('WAGES')",;
                 "Печать;Print('WAGES'),InitWageRelations()",;
                 "ВОплат/Редактирование справочника видов оплат;EditPayTable()",;
                 "Расчет/Расчет заработной платы;WagesRecalc(),InitWageRelations()",;
                 "Примеч./Редактирование примечания по сотруднику;IF(!WAGES->(EOF()).AND.!WAGES->(BOF()),WAGES->(REPLACE('NOTE',EditString(WAGES->NOTE))),NIL)",;
                 "Основ./Редактирование оснований для начислений и удержаний;BrowseAddTable('CALCR')",;
                 "Меню/Меню дополнительных функций;BrowseFuncMenu( 'WAGES', 'Дополнительные функции',,,'WAGESMENU' ),InitWageRelations()",;
                 "Обновл/Обновление списка сотрудников по табелю;WagesListUpdate()",;
                 "Кальк.;Calculator()",;
                 "Отдел/Быстрая смена отделов;WageChangeMonth(,.T.)";
                 },;
                 {;
                 "Информ/Карточка учета кадров по сотруднику;PersonCode(WAGES->JOBSCODE),BrowsePersArc(4,'10'),InitWageRelations()",;
                 "Тариф./Тарификации сотрудника;TarifListBrowse(),InitWageRelations()",;
                 "Табель/Табель рабочего времени по сотруднику;SaveSet(),ShowTabel('JOBTB',.T.),InitWageRelations(),RestSet(),RefreshAll()",;
                 "Больн./Реестр больничных листов;DBCLOSE('BNFIT'),BrowseTable('HSSHT',,.T.),InitWageRelations()",;
                 "Отпуск/Реестр отпускных;BrowseTable('VACTN',,.T.),DBCLOSE('CALCS'),MODINIT( { 'CALCS' },Year,,MEMVAR->Ent),InitWageRelations()",;
                 "Алимен/Реестр алиментов;RIsLists(WAGES->CODE),InitWageRelations()",;
                 "Депон./Реестр депонентов;Deponent(WAGES->CODE),InitWageRelations()",;
                 "Сбер.Б/Реестр перечислений в сбербанк;RPZPBbrowse(WAGES->CODE),InitWageRelations()",;
                 "Карточ/Карточка по сотруднику;WagesCard()",;
                 "Месяц/Быстрая смена текущего месяца;WageChangeMonth()" },{} )

        ******************************************************************************
        * IceMan >> добавляем дополнительные элементы ( *.ITM ) в меню окна
        MixExItemsAlias( ,"WAGES" )
        ******************************************************************************

        cDescName := TableBrowse( cFileName, cDescName, "WAGES", !.T., , , 1, ( &("{||FIELD->JOBSCODE==PersonCode()}" ) ), , !.F., !.F., .F., 2, ( { { "CALCS", "WAGES->RECCODE", "WAGESCODE" }, { "OUTCM", "WAGES->RECCODE", "WAGESCODE" } } ), , , , .F., ( { {|| SayRefer("POSTS",WAGES->MAINPOST,20) + " " + IF(JOBS_->COMB,"[ Совместитель ]","") + " " + "( " + IF( JOBTB->LDAY, "Чс", "Дн" ) + ".:" + XTOC( IF( JOBTB->LDAY, JOBTB->NORMHOURS, JOBTB->NORMDAYS ) ) + ", Отр.:" + XTOC( IF( JOBTB->LDAY, JOBTB->WRKDHOURS, JOBTB->WRKDDAYS ) ) + IF( ! EMPTY( JOBTB->ILL ), ", Больн.:" + XTOC( JOBTB->ILL ), "" ) + IF( ! EMPTY( JOBTB->VACATION ), ", Отп.:" + XTOC( JOBTB->VACATION ), "" ) + " )" }, {|| IF(EMPTY(WAGES->NOTE),"","Примечание: " + WAGES->NOTE ) } } ), , , , , , ( { {|x|  NIL }, {|| NIL } } ),  )

        WAGES->( DBGOTO( cDescName[ 1 ] ) )

        PersonCode( WAGES->JOBSCODE )

        RestFKey()
        WindClose()

    END SEQUENCE

    MEMVAR->opUT:Destroy()

    RESTSET()

    RETURN


*------------------------------------------------------*
*   Устанавливает связи WAGES с другими базами

    PROCEDURE InitWageRelation()
*------------------------------------------------------*
    SELECT PERSN
    DB_SETORDER( "CODE" )
    SET SCOPE TO
    SETFILTER(NIL)

    SELECT TARIF
    DB_SETORDER( "TABEL" )
    SET SCOPE TO
    SETFILTER(NIL)

    SELECT TRREC
    DB_SETORDER( "TARIFCODE" )
    SET SCOPE TO
    SETFILTER(NIL)

    SELECT TRLIN
    DB_SETORDER( "RECCODE" )
    SET SCOPE TO
    SETFILTER(NIL)

    SELECT JOBTB
    DB_SETORDER( "CODE" )
    SET SCOPE TO
    SETFILTER(NIL)

    // Сбросим отношение JOBS_ -> PERSN
    SELECT JOBS_
    DB_SETRELATION( NIL )
    DB_SETORDER( "RECCODE" )
    SET SCOPE TO
    SETFILTER(NIL)

    // Установка RELATION с JOBS, PERSN, TARIF, JOBTB
    SELECT WAGES
    DB_SETORDER( "BROWS" )

    DB_SETRELATION( "PERSN", "FIELD->CODE" )
    DB_SETRELATION( "JOBS_", "FIELD->JOBSCODE", .T. )
    DB_SETRELATION( "TARIF", "FIELD->JOBSCODE", .T. )
    DB_SETRELATION( "JOBTB", "DTOS(BOM(MEMVAR->DATE)) + FIELD->CODE + FIELD->JOBSCODE", .T. )

    IF EMPTY( MEMVAR->cpSelectEntGroup )
        // Только штатные сотрудники
        SET SCOPE TO "10" + DTOS( BOM( MEMVAR->DATE ) )
    ELSE
        IF LEN( MEMVAR->cpSelectEntGroup ) == 13
            DB_SETORDER( "PRSGR" )
            SET SCOPE TO "10" + DTOS( BOM( MEMVAR->DATE ) ) + LEFT( MEMVAR->cpSelectEntGroup, 12 )
        ELSE
            SET SCOPE TO "10" + DTOS( BOM( MEMVAR->DATE ) )
            SETFILTER( MEMVAR->cpSelectEntGroup )
        ENDIF
    ENDIF

    SKIP 0

    InitCfgFIO()

    RETURN
*------------------------------------------------------*
*   Восстановление связи WAGES с другими базами

    PROCEDURE RestoreWageRelation()
*------------------------------------------------------*
    LOCAL cAlias := ALIAS()

    LOCAL nOrderPersn, nOrderTarif, nOrderTrrec, nOrderTrlin, nOrderJobtb, nOrderJobs_, nOrderWages

    nOrderPersn := PERSN->( OrdNumber() )
    nOrderTarif := TARIF->( OrdNumber() )
    nOrderJobtb := JOBTB->( OrdNumber() )
    nOrderJobs_ := JOBS_->( OrdNumber() )
    nOrderWages := WAGES->( OrdNumber() )

    SELECT PERSN
    DB_SETORDER( "CODE" )

    SELECT TARIF
    DB_SETORDER( "TABEL" )

    SELECT JOBTB
    DB_SETORDER( "CODE" )

    // Сбросим отношение JOBS_ -> PERSN
    SELECT JOBS_
    DB_SETRELATION( NIL )
    DB_SETORDER( "RECCODE" )

    // Установка RELATION с JOBS, PERSN, TARIF, JOBTB
    SELECT WAGES
    DB_SETORDER( "BROWS" )

    DB_SETRELATION( "PERSN", "FIELD->CODE" )
    DB_SETRELATION( "JOBS_", "FIELD->JOBSCODE", .T. )
    DB_SETRELATION( "TARIF", "FIELD->JOBSCODE", .T. )
    DB_SETRELATION( "JOBTB", "DTOS(BOM(MEMVAR->DATE)) + FIELD->CODE + FIELD->JOBSCODE", .T. )

    PERSN->( DB_SETORDER( nOrderPersn ) )
    TARIF->( DB_SETORDER( nOrderTarif ) )
    JOBTB->( DB_SETORDER( nOrderJobtb ) )
    JOBS_->( DB_SETORDER( nOrderJobs_ ) )
    WAGES->( DB_SETORDER( nOrderWages ) )

    SKIP 0

    DbSelectArea( cAlias )

    RETURN

*------------------------------------------------------*
*   Быстрая смена текущего месяца без выхода в главное меню

    PROCEDURE WageChangeMonth( cType, lChangeGroup )
*------------------------------------------------------*
    LOCAL nMonth
    LOCAL aMonth := {}
    LOCAL nCount
    LOCAL nEmpCode := WAGES->CODE
    LOCAL aSaveScope
    LOCAL cWindHeader

    MEMVAR npFacesType, lpSpecial

    DEFAULT cType        IS "WAGE"
    DEFAULT lChangeGroup IS .F.

    SaveSet()
    SELECT WAGES
    aSaveScope := SaveScope()
    SET SCOPE TO

    IF !lChangeGroup
        // Заполним массив существующих месяцев
        FOR nCount := 1 TO 12
            AADD( aMonth,;
                { " " + PADR( NTOCMONTH( nCount ), 20 ) + " ",;
                 DBSEEK( "10" + DTOS( CTOD( "01/" + STRZERO( nCount, 2 ) + "/" + XTOC(MEMVAR->Year) ) ) ) } )
        NEXT

        nMonth := SprSelect( aMonth,,,,,"Перейти к месяцу..." )

        IF EMPTY( nMonth )
            SELECT WAGES
            RestScope( aSaveScope )
            RestSet()
            RETURN
        ENDIF

        MEMVAR->Month := nMonth
    ENDIF

    VarDate()

    IF lChangeGroup
        MEMVAR->cpSelectEntGroup := NIL
        SelectEntGroup()
    ENDIF

    SELECT WAGES
    RestSet()

    IF cType == "WAGE"
        InitWageRelations()
    ELSE
        InitUnWageRelations()
    ENDIF

    GO TOP

    DO WHILE ! EOF()
        IF WAGES->CODE = nEmpCode
            EXIT
        ENDIF
        SKIP
    ENDDO

    IF EOF()
        DBGOTOP()
    ENDIF

    RefreshAll()

    IF cType == "WAGE"
        CWindHeader := "Заработная плата за "+ REMALL( SayDate( MEMVAR->Date, "MMMMM YYYY г." ) ) +" по учреждению " + cEnt
    ELSE
        IF npFacesType = 20
            cWindHeader := "Зарплата нештатных сотрудников за "+ REMALL( SayDate( MEMVAR->Date, "MMMMM YYYY г." ) ) +" по учреждению " + cEnt
        ELSE
            IF ( npFacesType == GetStudFaceTypeCode() ) .AND. lpSpecial
                cWindHeader := "Выплаты " + REMALL( SayRefer( "PRSCT", npFacesType ) ) + " " + REMALL( SayDate( MEMVAR->Date, "MMMMM YYYY г." ) ) +" (гр. " + REMALL( MEMVAR->aGroup[ 2 ] ) + ", " + REMALL( cEnt ) + ")"
            ELSE
                cWindHeader := "Выплаты физ.лицам " + REMALL( SayRefer( "PRSCT", npFacesType ) ) + " " + REMALL( SayDate( MEMVAR->Date, "MMMMM YYYY г." ) ) +" ( " + REMALL( cEnt ) + " )"
            ENDIF
        ENDIF
    ENDIF

    ChangeHeader( cWindHeader )

    RETURN


*------------------------------------------------------*
*   Обновление списка сотрудников в заработной плате

    FUNCTION WagesListUpdate()
*------------------------------------------------------*
    LOCAL lDone := .T.
    LOCAL aRelation
    LOCAL cNote
    LOCAL nMoveNote := 0
    LOCAL aScope
    LOCAL nCount
    LOCAL aMassiv := {}
    LOCAL dFdate
    LOCAL aTemp   := {}
    LOCAL aWages  := {}
    LOCAL cOtdel  := ""
    LOCAL aOutCome
    LOCAL lOutCome

    // Если текущий месяц не относится к закрытому периоду
    IF ! WagesClose()
        SaveSet()

        BeginStatus()

        SELECT WAGES
        aRelation := SaveRels()
        DB_SETRELATION( NIL )

        DB_SETORDER( "CODE" ) // По месяцу и коду

        SELECT JOBTB
        IF EMPTY( MEMVAR->cpSelectEntGroup )
            cOtdel := ""
            DB_SETORDER( "CODE" ) // По месяцу, коду, JobsCode, Признаку главной должности
            // Добавление новых сотрудников
            SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) )
        ELSE
            IF LEN( MEMVAR->cpSelectEntGroup ) == 13
                cOtdel := MEMVAR->cpSelectEntGroup
                DB_SETORDER( "CODEP" ) // По месяцу, коду, JobsCode, Признаку главной должности
                // Добавление новых сотрудников
                SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + LEFT( MEMVAR->cpSelectEntGroup, 12 )
            ELSE
                cOtdel := ""
                DB_SETORDER( "CODE" ) // По месяцу, коду, JobsCode, Признаку главной должности
                // Добавление новых сотрудников
                SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) )
                SETFILTER( MEMVAR->cpSelectEntGroup )
            ENDIF
        ENDIF
        GO TOP

        IF EOF()
            Message( "!Табель рабочего времени не заполнен" )
            lDone := .F.
        ENDIF
        SELECT JOBTB

        DO WHILE ! EOF()

            IF ! WAGES->( DBSEEK( "10" + DTOS( BOM( MEMVAR->DATE ) ) + JOBTB->CODE + JOBTB->JOBSCODE ) )
                DO WHILE ! WAGES->( ADD_REC() ); ENDDO
                WAGES->RECCODE  := WAGES->( UQ_CODE() )
                WAGES->JOBSCODE := JOBTB->JOBSCODE
                WAGES->CODE     := JOBTB->CODE
                WAGES->MONTH    := BOM( JOBTB->MONTH )
                WAGES->TYPE     := 10
            ENDIF

            WAGES->( REPLACE( "PRSGR", JOBTB->PRSGR ) )
            PERSN->( DBSEEK( WAGES->CODE ) )
            SayStatus( SayFio() )

            // Присваивать всегда (на случай, если изменится)
            // Но только для главной должности
            IF JOBTB->MAINPOST
                WAGES->( REPLACE( "SURNAME", JOBTB->SURNAME ) )
                WAGES->( REPLACE( "RANK", JOBTB->RANK ) )
                WAGES->( REPLACE( "MAINPOST", JOBTB->POST ) )
            ENDIF
            IF nMoveNote < 2 .AND. EMPTY( WAGES->NOTE ) .AND. ! EMPTY( cNote := WAGES->( GetWageIncome( FIELD->NOTE, "NOTE" ) ) )
                IF EMPTY( nMoveNote )
                    IF MALERT( "Переносить примечания прошлого месяца?", {"Да","Нет"} ) = 2
                        nMoveNote := 2
                    ELSE
                        nMoveNote := 1
                    ENDIF
                ENDIF
                IF nMoveNote < 2
                    WAGES->( REPLACE( "NOTE", cNote ) )
                ENDIF
            ENDIF
            // Переместимся на запись по следующему сотруднику
            ORDSKIPUNIQUE()
        ENDDO

        IF lDone
            SayStatus( "Завершение операции..." )
            // Удаление несуществующих сотрудников
            SELECT WAGES
            IF EMPTY( MEMVAR->cpSelectEntGroup )
                // Только текущий тип физического лица
                DB_SETORDER( "CODE" ) // По месяцу и коду
                SET SCOPE TO STRZERO( MEMVAR->npFacesType, 2 ) + DTOS( BOM( MEMVAR->DATE ) )
            ELSEIF LEN( MEMVAR->cpSelectEntGroup ) == 13
                DB_SETORDER( "CODEP" ) // По месяцу и коду
                SET SCOPE TO STRZERO( MEMVAR->npFacesType, 2 ) + DTOS( BOM( MEMVAR->DATE ) ) + LEFT( MEMVAR->cpSelectEntGroup, 12 )
            ELSE
                // Только текущий тип физического лица
                DB_SETORDER( "CODE" ) // По месяцу и коду
                SET SCOPE TO STRZERO( MEMVAR->npFacesType, 2 ) + DTOS( BOM( MEMVAR->DATE ) )
                SETFILTER( MEMVAR->cpSelectEntGroup )
            ENDIF

            GO TOP

            DO WHILE ! EOF()
                IF ! JOBTB->( DBSEEK( DTOS( BOM( MEMVAR->DATE ) ) + cOtdel + WAGES->CODE + WAGES->JOBSCODE ) )
                    IF ! WAGES->LOCKED
                        PERSN->( DBSEEK( WAGES->CODE ) )

                        IF IF(!WAGES->UVOLN,PersMessage( "@В заработной плате обнаружен сотрудник, который не найден в табеле рабочего времени. Удалить его из заработной платы ?", {"Удалить","Отказ"} ) = 1,.T.)
                            // если по уволенному есть долг - тогда не будем удалять его из зарплаты
                            lOutCome := .F.
                            aOutCome := GetWageIncome( {}, "OUTCOME" )
                            FOR nCount := 1 TO LEN( aOutCome )
                                IF ABS( aOutCome[ nCount ][ 2 ] ) > 0.0001
                                    lOutCome := .T.
                                    EXIT
                                ENDIF
                            NEXT


                            IF !lOutCome

                                SELECT CALCS
                                DB_SETORDER( "WAGESCODE" )
                                SET SCOPE TO WAGES->RECCODE
                                GO TOP
                                DO WHILE !EOF()
                                    IF !EMPTY( CALCS->SHLSTCODE )
                                        lDone := .F.
                                    ENDIF
                                    SKIP
                                ENDDO
                                SELECT WAGES
                                IF !lDone
                                    PersMessage( "@!Нельзя удалить сотрудника из заработной платы, "+;
                                           "так как присутствуют виды оплат, включенные в ведомости" )
                                    SKIP
                                    LOOP
                                ENDIF
                                IF R_LOCK()

                                    // чистим начисленные доходы по ПН и ЕСН
                                    IF .NOT. MODINIT( { "PROFT", "SPRFT" }, MEMVAR->YEAR )
                                        BREAK
                                    ENDIF

                                    // удаляем расшифровки доходов для налога с физических лиц
                                    SELECT PROFT
                                    DB_SETORDER( "JOBSCODE" )
                                    SET SCOPE TO WAGES->JOBSCODE
                                    GO TOP
                                    DO WHILE .NOT. EOF()
                                        DO WHILE ! R_LOCK(); ENDDO
                                        FIELD->&( "MONTH" + STRZERO( MONTH( WAGES->MONTH ), 2 ) ) := 0
                                        FIELD->PRSUM := SumRecord( "MONTH01", "MONTH12" )
                                        UN_LOCK()
                                        SKIP
                                    ENDDO

                                    // удаляем расшифровки доходов для ЕСН
                                    SELECT SPRFT
                                    DB_SETORDER( "JOBSCODE" )
                                    SET SCOPE TO WAGES->JOBSCODE
                                    GO TOP
                                    DO WHILE .NOT. EOF()
                                        DO WHILE ! R_LOCK(); ENDDO
                                        FIELD->&( "MONTH" + STRZERO( MONTH( WAGES->MONTH ), 2 ) ) := 0
                                        FIELD->PRSUM    := SumRecord( "MONTH01", "MONTH12" )
                                        UN_LOCK()
                                        SKIP
                                    ENDDO

                                    // Удалим запись вместе с подчиненными записями
                                    DBSELECTAREA( "WAGES" )
                                    tb_Delete()
                                    UN_LOCK()
                                ENDIF
                            ENDIF
                        ENDIF
                    ENDIF
                ELSEIF WAGES->UVOLN
                    // если по уволенному есть долг - тогда не будем удалять его из зарплаты
                    lOutCome := .F.
                    aOutCome := GetWageIncome( {}, "OUTCOME" )
                    FOR nCount := 1 TO LEN( aOutCome )
                        IF ABS( aOutCome[ nCount ][ 2 ] ) > 0.0001
                            lOutCome := .T.
                            EXIT
                        ENDIF
                    NEXT


                    IF !lOutCome
                        // если получилась такая ситуаци, что человека неправильно уволили, а затем исправили дату увольнения, то этот чек
                        // все равно остается в зарплате и поэтому его оттуда надо жахнуть...
                        SELECT CALCS
                        DB_SETORDER( "WAGESCODE" )
                        SET SCOPE TO WAGES->RECCODE
                        GO TOP
                        DO WHILE !EOF()
                            IF !EMPTY( CALCS->SHLSTCODE )
                                lDone := .F.
                            ENDIF
                            SKIP
                        ENDDO

                        IF lDone
                            // если запись в Wages удаляем - тогда и Calcs тоже почистим
                            SELECT CALCS
                            DB_SETORDER( "WAGESCODE" )
                            SET SCOPE TO WAGES->RECCODE
                            GO TOP
                            DO WHILE !EOF()
                                DEL_REC()
                                SKIP
                            ENDDO
                        ENDIF

                        SELECT WAGES
                        // Предварительно проверив, не включены ли в ведомости какие-нибудь выплаты
                        IF !lDone
                            PersMessage( "@!Нельзя удалить сотрудника из заработной платы, "+;
                                   "так как присутствуют виды оплат, включенные в ведомости" )
                            SKIP
                            LOOP
                        ELSE
                            DEL_REC()
                        ENDIF
                    ENDIF
                ENDIF
                SKIP
            ENDDO
        ENDIF

        CheckDimissEmployee()
        EndStatus()

        RestSet()
    ENDIF

    SELECT WAGES
    InitWageRelations()
    GO TOP
    MEMVAR->oBrowse:RefreshAll()

    RETURN( lDone )


*------------------------------------------------------*
*   Проверка на уволенных сотрудников с долгами

    PROCEDURE CheckDimissEmployee()
*------------------------------------------------------*
    LOCAL aScope
    LOCAL dFdate
    LOCAL aTemp
    LOCAL nCount
    LOCAL aWages

    WAGES->( aScope := SaveScope() )
    SaveSet()

    SELECT WAGES
    DB_SETORDER("CODE")
    SET SCOPE TO

    aWages := Extract({},"ARR",File_Name("WAGES",MEMVAR->ENT,,YEAR(ADDMONTH(MEMVAR->DATE,-1))),;
              {"CODE", "TYPE", "JOBSCODE", "MAINPOST", "OUTCOME"},;
              {"BROWS", STRZERO( MEMVAR->npFacesType, 2 ) + DTOS(BOM(ADDMONTH(MEMVAR->DATE, -1))),;
                        STRZERO( MEMVAR->npFacesType, 2 ) + DTOS(BOM(ADDMONTH(MEMVAR->DATE, -1))), "FIELD->OUTCOME <> 0" }, .F. )

    IF !EMPTY(aWages)

        FOR nCount := 1 TO LEN(aWages)
          // проверяем на наличие долга у человека
               // проверяем не уволен ли ч-к
            aTemp := EXTRACT({,""},"VAL", "JOBS_", { "FDATE", "SURNAME" }, { "RECCODE", aWages[nCount][3], aWages[nCount][3] } )

            dFdate := aTemp[1]

            IF !EMPTY(dFdate) .AND. EOM( dFdate ) < BOM( MEMVAR->DATE )
                // запоминаем если есть уволенный с долгами
                IF ! DBSEEK( STRZERO(aWages[nCount][2], 2 ) + DTOS( BOM( MEMVAR->DATE ) ) + aWages[nCount][1] + aWages[nCount][3] )

                    IF MEMVAR->npFacesType == 10 .AND. EMPTY( aWages[nCount][4] )
                        SELECT TARIF
                        DB_SETORDER( "TARIFDATE" )
                        SET SCOPE TO aWages[nCount][1] + aWages[nCount][3] + DTOS( BOM ( MEMVAR->DATE ) ),;
                                     aWages[nCount][1] + aWages[nCount][3]
                        GO TOP
                        IF !EOF()
                            SELECT TRREC
                            DB_SETORDER( "TARIFCODE" )
                            SET SCOPE TO aWages[nCount][1] + TARIF->TARIFCODE + "0"
                            GO TOP
                            IF !EOF()
                                aWages[ nCount ][ 4 ] := TRREC->POSTCODE
                            ENDIF
                        ENDIF
                        IF EMPTY( aWages[nCount][4] )
                            ALERT( "Не найдена ни одна должность в тарификации по сотруднику;"+;
                                   ALLTRIM( SayFIO( .T., aWages[ nCount ][ 1 ] ) ) + " (таб.ном.:" + aWages[ nCount ][ 1 ] + ");"+;
                                   "по этому сотруднику присутствует долг, которой не;"+;
                                   "удается привязать ни к одной должности. Долг учтен не будет!" )
                        ENDIF
                        SELECT WAGES
                    ENDIF

                    DO WHILE ! WAGES->( ADD_REC() ); ENDDO
                    WAGES->RECCODE  := WAGES->( UQ_CODE() )
                    WAGES->CODE     := aWages[nCount][1]
                    WAGES->TYPE     := aWages[nCount][2]
                    WAGES->MONTH    := BOM( MEMVAR->DATE )
                    WAGES->SURNAME  := aTemp[2]
                    WAGES->MAINPOST := aWages[nCount][4]
                    WAGES->JOBSCODE := aWages[nCount][3]
                    WAGES->UVOLN    := .T.

                ENDIF

            ENDIF
        NEXT

    ENDIF

    RestSet()
    WAGES->(RestScope(aScope) )

    RETURN

*------------------------------------------------------*
*   Расшифровка заработной платы по видам оплат и удержаний

    FUNCTION WagesCard()
*------------------------------------------------------*
    STATIC lCardRun := .F.

    LOCAL cFileName := FILE_NAME( "WAGES",Ent,,Year )
    LOCAL cDescName := FILEDESC( "WAGES" )
    LOCAL cCardName := CARD_NAME( "WAGES.CRD", "PERSONAL" )

    MEMVAR aPlusArr
    MEMVAR aMinusArr

    // Если карточка уже запущена
    IF lCardRun .OR. Alias() != "WAGES"
        RETURN( NIL )
    ENDIF

    lCardRun := .T.

    SAVESET()

    BEGIN SEQUENCE

        WindOpen( "WagesCardWind",,SayFio(.F.)+": зарплата за " + NTOCMONTH( MEMVAR->Month ),,,,,,,.F. )
        SetFKey( { "Помощь;Help('WAGES')",,,,,,,,"Кальк.;Calculator()" } )

        SELECT WAGES

        CRDBROWSE FILE ( cFileName );
           DESCRIPTION ( cDescName );
                  CARD ( cCardName );
                OPENLY ;
                   NEW (.F.)

        RestFKey()
        WindClose()

    END SEQUENCE

    RESTSET()

    InitWageRelations()
    MEMVAR->oBrowse:RefreshCurrent()

    lCardRun := .F.

    RETURN( NIL )


*------------------------------------------------------*
*   Массив начислений

    FUNCTION GetWageArr( nMode, aInfo )
*------------------------------------------------------*
    MEMVAR aPlusArr, aMinusArr, cpWageCodeSay

    LOCAL nCount
    LOCAL aKoef

    SAVESET()

    IF IF( nMode = 1, EMPTY( MEMVAR->aPlusArr ).OR.cpWageCodeSay[1] <> WAGES->RECCODE , EMPTY( MEMVAR->aMinusArr ).OR.cpWageCodeSay[2] <> WAGES->RECCODE )
        SELECT CALCS

        IF nMode == 1
            MEMVAR->cpWageCodeSay[1] := WAGES->RECCODE
        ELSE
            MEMVAR->cpWageCodeSay[2] := WAGES->RECCODE
        ENDIF

        IF nMode = 1
            aInfo := {"MODE", "COMMENT", "PADR(REMALL(SayMethod(CALCS->PAYTYPE,CALCS->PARAM))+' '+SayPost(POST),35)", "POST", "SUMMA", "GROUP", "PAYTYPE" }
        ENDIF

        DB_SETORDER( "CODE" )

        IF nMode = 1
            SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( 10, 2 ),;
                     DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( 30, 2 )
        ELSE
            SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( 40, 2 ),;
                     DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( 50, 2 )
        ENDIF

        GO TOP

        IF nMode = 1
            MEMVAR->aPlusArr := Extract( {}, "ARR", "CALCS", aInfo, "!GROUP=30" )
            // Коэффициенты просуммируем в одну строку
            aKoef := {}
            GO TOP
            DO WHILE ! EOF()
                IF CALCS->GROUP = 30
                    // Если в массиве коэффициентов уже есть такой коэффициент
                    IF ( nCount := ASCAN( aKoef, {|x| x[ 6 ] = CALCS->GROUP .AND. x[ 7 ] == CALCS->PAYTYPE } ) ) = 0
                        AADD( aKoef, { CALCS->MODE, CALCS->COMMENT, PADR(REMALL(SayMethod(CALCS->PAYTYPE,CALCS->PARAM))+' (итого)',35), CALCS->POST, 0, CALCS->GROUP, CALCS->PAYTYPE } )
                        nCount := LEN( aKoef )
                    ENDIF
                    // Увеличим сумму
                    aKoef[ nCount ][ 5 ] += CALCS->SUMMA
                ENDIF
                SKIP
            ENDDO
            // Аппенднем массив aKoef к массиву aPlusArr
            FOR nCount := 1 TO LEN( aKoef )
                AADD( aPlusArr, aKoef[ nCount ] )
            NEXT
            IF EMPTY( aPlusArr )
                aPlusArr := { "" }
            ENDIF
        ELSE
            MEMVAR->aMinusArr := Extract( {""}, "ARR", "CALCS", aInfo, ".T." )
        ENDIF

        SET SCOPE TO

        // Приведем массив начислений к приличному виду
        IF nMode = 1
            FOR nCount := 1 TO LEN( aPlusArr )
                IF ! EMPTY( aPlusArr[ nCount ] )
                    aPlusArr[nCount] := IF(aPlusArr[nCount][1] == 10, "Тар.|", "Нач.|") + Left(aPlusArr[nCount][2], 21) + "|" + aPlusArr[nCount][3] + "|" + Str(aPlusArr[nCount][5], 10, 2)
                ENDIF
            NEXT
        ENDIF
    ENDIF

    RESTSET()

    RETURN( IF( nMode=1, MEMVAR->aPlusArr, MEMVAR->aMinusArr ) )


*------------------------------------------------------*
*   Расшифровка заработной платы по видам оплат и удержаний

    FUNCTION BrowseWagesList( nMode1, nMode2, cHeader, nHidden )
*------------------------------------------------------*
    LOCAL cFileName := FILE_NAME( "CALCS",Ent,,Year )
    LOCAL cDescName := FILEDESC( "CALCS" )
    LOCAL nWageSum := 0
    LOCAL xReturn
    LOCAL aWindInfo
    LOCAL bOldBlock

    PRIVATE npMode       := nHidden
    PRIVATE apRegenWages := { .F., .F., .F. }
    PRIVATE cpCalcsHeader
    PRIVATE lpStrongUpdate := .F.

    SAVESET()

    BEGIN SEQUENCE

        SELECT CALCS

        DB_SETORDER( "CODE" )

        SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( nMode1, 2 ),;
                     DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( nMode2, 2 )
        GO TOP

        cpCalcsHeader := cHeader + " за " + NTOCMONTH( MEMVAR->Month ) + " " + SayFio() + " " + IF(WAGES->TYPE = 10, SayRefer("POSTS",WAGES->MAINPOST,20), "" )

        WindOpen( "WagesCalcsWind",, cpCalcsHeader )
        // на TAB устанавливаем функцию просмотра карточки
        SetBKey( Qt_Key_Tab, {|| CalcsCard( nMode1, nMode2 ) } )
        SetFKey({"Помощь;Help('CALCS')",;
                 ,;
                 "ВОплат/Редактирование справочника видов оплат;EditPayTable()",,;
                 "Примеч./Редактирование примечания по сотруднику;WAGES->(REPLACE('NOTE',EditString(WAGES->NOTE)))",;
                 "Основ./Редактирование оснований для начислений и удержаний;BrowseAddTable('CALCR')",;
                 "Входим/Редактирование входимости текущего вида оплаты;EditEntryTable(CALCS->PAYTYPE,CALCS->COMMENT)",,;
                 "Кальк.;Calculator()"},{},{} )

        IF npMode = 1 .AND. MEMVAR->npFacesType = 10
            aWindInfo := {{;
                           {|| "Сумма по тарифу : "  },;
                           {||"[" },;
                           {|| + XTOC( WAGES->TARIF, 12, 2 )},;
                           {||"]" },;
                           {|| "Параметры расчета:" },;
                           {||"[" },;
                           {|| IF(FIELDNUM("METOD")>0.AND.CALCS->METOD=0, SayMethod( CALCS->PAYTYPE, CALCS->PARAM ),"") },;
                           {||"]" };
                           },{;
                           {|| "Дебет:"},;
                           {||"[" },;
                           {|| SayAcc( CALCS->DFKR, CALCS->DBACC, CALCS->DBKGU, CALCS->DBACCKF1, CALCS->DBACCKF2, CALCS->DBACCKF3 )},;
                           {||"]" },;
                           {|| "Кредит"},;
                           {||"[" },;
                           {|| SayAcc( CALCS->DFKR, CALCS->KACC, CALCS->KKGU, CALCS->KACCKF1, CALCS->KACCKF2, CALCS->KACCKF3 )},;
                           {||"]" };
                           }}
        ELSE
            aWindInfo := {{;
                           {|| "Параметры расчета:" },;
                           {||"[" },;
                           {|| IF(FIELDNUM("METOD")>0.AND.CALCS->METOD=0, SayMethod( CALCS->PAYTYPE, CALCS->PARAM ),"") },;
                           {||"]" },;
                           {|| ""  },  ;
                           {|| ""  },  ;
                           {|| ""  },  ;
                           {|| ""  }  ;
                           },{;
                           {|| "Дебет:"},;
                           {||"[" },;
                           {|| SayAcc( CALCS->DFKR, CALCS->DBACC, CALCS->DBKGU, CALCS->DBACCKF1, CALCS->DBACCKF2, CALCS->DBACCKF3 )},;
                           {||"]" },;
                           {|| "Кредит"},;
                           {||"[" },;
                           {|| SayAcc( CALCS->DFKR, CALCS->KACC, CALCS->KKGU, CALCS->KACCKF1, CALCS->KACCKF2, CALCS->KACCKF3 )},;
                           {||"]" };
                           }}
        ENDIF

        xReturn := TableBrowse( cFileName, cDescName, "CALCS", !.T., , ( {|x,y,z| WagesInsDel(x,y,z) } ), 2, , , !.F., !.F., .T., ( IF( BOM(GetCloseDate()) >= BOM( MEMVAR->Date )  , 3, IF( ! WAGES->LOCKED .AND. !nHidden = 0, 2, 3 ) ) ), , , , , .F., ( aWindInfo ), , , ( MIN( nHidden, 3 ) ), , , ,  )

        xReturn := ASCAN( xReturn[ 4 ], .T. ) > 0
        // Изменились начисления
        IF xReturn .AND. nHidden = 1
            apRegenWages := { .F., .T., .T. }
        ELSEIF ( xReturn .AND. nHidden = 2 ) .OR. lpStrongUpdate
            apRegenWages := { .F., .F., .T. }
        ENDIF

        // Пересчитать суммы если флаг пересчета установлен
        IF ASCAN( apRegenWages, .T. ) > 0
            SumByTarif( NIL, .T., apRegenWages )
        ENDIF

        UpdateOutcmEntDolg( .T. )

        SELECT CALCS
        DB_SETORDER( "CODE" )
        SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( nMode1, 2 ),;
                     DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( nMode2, 2 )
        GO TOP
        nWageSum := Extract( 0, "SUM", "CALCS", "SUMMA", "GROUP!=80" )
        // к удержаниям добавим долг на начало

        SET SCOPE TO

        RestFKey()
        WindClose()

    END SEQUENCE

    RESTSET()

    RETURN( nWageSum )



*------------------------------------------------------*
*   Выбор счета в карточке начисления
    FUNCTION CalcsChangeDacc( cDefault )
*------------------------------------------------------*
    LOCAL cResult := cDefault
    LOCAL oBack
    LOCAL y,z,i
    LOCAL cSavedDacc
    LOCAL cErrorMsg := ""

    DEFAULT cResult IS FIELD->DACC

    oBack := BackTracking():new()

    BEGIN SEQUENCE

        IF CalcSheets():CalcWasPayed(, .T.)
            // не можем изменить запись из-за того, что она включена в ведомость
            BREAK
        ELSE
            IF !oBack:SaveRec()
                oBack:SayError()
                BREAK
            ENDIF

            z := IF( EMPTY( cResult ), GetWageAcc( FIELD->PAYTYPE, FIELD->MODE>39 ), cResult )
            y := SUBSTR( z, 3 )
            i := SUBSTR( z, 1, 2 )
            y := GetValue( { { "Введите аналит.счета зар:", "C", 2, 0, i, NIL }, ;
                             { "Введите КСГУ для фин.рез.", "C", 6, 0, y, NIL } }, "КСГУ" )

            cSavedDacc := FIELD->DACC

            FIELD->DACC := IF( !EMPTY( y ), y[ 1 ] + y[ 2 ], cResult )

            IF !IsCorrectDacc( IF( EMPTY( FIELD->DACC ), GetWageAcc( FIELD->PAYTYPE, FIELD->MODE>39 ), FIELD->DACC ), @cErrorMsg )
                ALERT( "!" + cErrorMsg + " Изменения не сохранены." )
                BREAK
            ENDIF

            // валидируем и в случае невалидности откатываем изменения
            IF ! CalcSheets():AllowCalcChange( .T. )
                oBack:Undo()
                cResult := cSavedDacc
            ENDIF
        ENDIF

        cResult := FIELD->DACC
    END SEQUENCE

    RETURN cResult

*------------------------------------------------------*
*   Выбор счета в карточке начисления
    FUNCTION CalcsChangePost( cDefault )
*------------------------------------------------------*
    LOCAL cResult := cDefault
    LOCAL oBack
    LOCAL y,z,i
    LOCAL cSavedPost

    DEFAULT cResult IS FIELD->POST

    oBack := BackTracking():new()

    BEGIN SEQUENCE

        IF CalcSheets():CalcWasPayed(, .T.)
            // не можем изменить запись из-за того, что она включена в ведомость
            BREAK
        ELSE
            IF !oBack:SaveRec()
                oBack:SayError()
                BREAK
            ENDIF

            cSavedPost := FIELD->POST
            FIELD->POST := WagesPostSelect( cDefault )

            // валидируем и в случае невалидности откатываем изменения
            IF ! CalcSheets():AllowCalcChange( .T. )
                oBack:Undo()
                cResult := cSavedPost
            ENDIF
        ENDIF

        cResult := FIELD->POST
    END SEQUENCE

    RETURN cResult


*------------------------------------------------------*
*   Расшифровка долгов по заработной плате в разрезе счетов

    FUNCTION BrowseOutcomeWagesList( lIsPersonOutcome )
*------------------------------------------------------*
    LOCAL cFileName := MEMVAR->LocalPath + "outcm_view.dbf"//FILE_NAME( "OUTCM",Ent,,Year )
    LOCAL cDescName := FILEDESC( "OUTCM" )
    LOCAL nWageSum := 0
    LOCAL xReturn
    LOCAL cHeader := ""
    LOCAL aGrouped := {}
    LOCAL nI
    LOCAL oHash

    SAVESET()

    BEGIN SEQUENCE

        DBCLOSE( "OUTCM_VIEW" )
        IF !OpenDbfCdx( cFileName, cDescName, "OUTCM_VIEW", .T.,,{{"AAA", "FIELD->DACC" }}, .F. )
            ALERT( "Не удалось создать временную таблицу. Возможно, Вам поможет перезапуск модуля." )
            BREAK
        ENDIF

        SELECT OUTCM_VIEW
        ZAP

        SELECT OUTCM
        DB_SETORDER( "WAGESTYPE" )
        SET SCOPE TO WAGES->RECCODE// + STRZERO( nMode1, 2), WAGES->RECCODE + STRZERO( nMode2, 2)
        GO TOP
        WHILE !EOF()

            SELECT OUTCM_VIEW

            __dblocate( {|| FIELD->DBACC == OUTCM->DBACC .AND. FIELD->DBFKR == OUTCM->DBFKR ;
                    .AND. FIELD->DBKGU == OUTCM->DBKGU .AND. FIELD->DBACCKF1 == OUTCM->DBACCKF1 ;
                    .AND. FIELD->DBACCKF2 == OUTCM->DBACCKF2  .AND. FIELD->DBACCKF3 == OUTCM->DBACCKF3 } )

            IF FOUND()
                FIELD->SUMMA += IF( OUTCM->TYPE <= 40, OUTCM->SUMMA, -OUTCM->SUMMA )
            ELSE
                oHash := OUTCM->( ReadRecordToHash() )
                AddRecordAndWriteHash( oHash )
                IF OUTCM->TYPE >= 50
                    REPLACE( "SUMMA", -FIELD->SUMMA )
                ENDIF
            ENDIF

            SELECT OUTCM
            SKIP
        ENDDO

        SELECT OUTCM_VIEW
        GO TOP

        WHILE !EOF()
            IF  lIsPersonOutcome
                IF FIELD->SUMMA < -0.001
                    DBDELETE()
                ENDIF
            ENDIF
            IF !lIsPersonOutcome
                IF FIELD->SUMMA < -0.001
                    FIELD->SUMMA := -FIELD->SUMMA
                ELSE
                    DBDELETE()
                ENDIF
            ENDIF
            SKIP
        ENDDO

        GO TOP
        IF EOF() .OR. BOF()
            BREAK
        ENDIF

        WindOpen( "WagesOutcomeWind",,cHeader + " за " + NTOCMONTH( MEMVAR->Month ) + " " + SayFio() + " " + IF(WAGES->TYPE = 10, SayRefer("POSTS",WAGES->MAINPOST,20), "" ) )
        SetFKey({"Помощь;Help('OUTCM')",;
                 "Печать;Print('OUTCM')",;
                 ,,;
                 ,;
                 ,;
                 ,,;
                 "Кальк.;Calculator()"},{},{} )

        xReturn := TableBrowse( cFileName, cDescName, "OUTCM_VIEW", , , , , , , , , , 3, , , , , , , , , , , , ,  )

        RestFKey()
        WindClose()

    END SEQUENCE

    DBCLOSE( "OUTCM_VIEW" )

    RESTSET()

    RETURN( nWageSum )

*------------------------------------------------------*
*   Проверка корректности записи dacc
    FUNCTION IsCorrectDacc( cDacc, cRetErrorMessage )
*------------------------------------------------------*
    LOCAL cAcc
    LOCAL cSt
    LOCAL cAccnt

    IF !EMPTY( cDacc )
        cAcc := "302" + LEFT( cDacc, 2 )
        cSt  := SUBSTR( cDacc, 3, 3 )

        cAccnt := Extract( NIL, "VAL", MEMVAR->SprPath + "accnt.dbf", "ACCKF", { "ACCNT", cAcc } )
        IF !EMPTY( cAccnt ) .AND. !( ALLTRIM( cSt ) == ALLTRIM( cAccnt ) )
            IF cRetErrorMessage != NIL
                cRetErrorMessage := "В настройках счета 302" + LEFT( cDacc, 2 ) + " указано, что КОСГУ аналитического учета может принимать только значение " + ALLTRIM( cAccnt ) + "."
            ENDIF
            RETURN .F.
        ELSEIF cAccnt == NIL
            IF cRetErrorMessage != NIL
                cRetErrorMessage := "Счет 302" + LEFT( cDacc, 2 ) + " не найден в плане счетов."
            ENDIF
            RETURN .F.
        ENDIF
    ENDIF

    RETURN .T.

*------------------------------------------------------*
*   Выбор должности по которой происходит начисление
*   вида оплаты

    FUNCTION WagesInsDel( nKey )
*------------------------------------------------------*
    LOCAL xReturn    := TB_NO_CHANGE
    LOCAL cPaySelect
    LOCAL aScope
    LOCAL bBlock
    LOCAL aResult
    LOCAL apPayInfo
    LOCAL nOldSum
    LOCAL lDone  := .F.
    LOCAL aWScope
    LOCAL cName
    LOCAL cDacc
    LOCAL aSheets
    LOCAL xTemp
    LOCAL aCalcsParam
    LOCAL nRecnoBefore
    LOCAL oBack
    LOCAL cErrorMsg
    LOCAL oCalcsAcc

    MEMVAR npMode

    PRIVATE apPayDate := { CTOD(" / / "), CTOD(" / / "), 0 }
    PRIVATE dpDateTarif

    IF nKey <> K_INS .AND. nKey <> K_DEL .AND. nKey <> K_ENTER
        RETURN( xReturn )
    ENDIF

    IF WAGES->LOCKED .OR. WagesClose()
        RETURN( xReturn )
    ENDIF

    // Если это не начисления и не удержания
    IF ! RANGE( npMode, 1, 4 )
        RETURN( TB_NO_CHANGE )
    ENDIF

    IF npMode = 1
        IF MEMVAR->aCfgFIO[5] = 1
            aWScope := { "25", "25", NIL }
        ELSE
            aWScope := { "10", "30", "GROUP!=13 .AND. GROUP!=26" }
        ENDIF
        cName := "начисления"
    ELSEIF npMode = 2
        aWScope := { "35", "85", NIL }
        cName := "удержания"
    ELSEIF npMode = 3
        aWScope := { "90", "90", NIL }
        cName := "выплаты"
    ELSE
        // а вдруг npMode будет в пределах 1..3 ?
        aWScope := { "00", "00", NIL }
        cName := ""
    ENDIF

    BEGIN SEQUENCE

        // В случае добавления выберем вид оплаты
        IF nKey = K_INS
            cPaySelect := PaySelect( NIL,;
                { "GROUP", aWScope[ 1 ], aWScope[ 2 ], aWScope[ 3 ] },;
                "Добавление " + cName )

            IF EMPTY( cPaySelect )
                BREAK
            ENDIF

            oCalcsAcc := CalcsAccs():new()
            cErrorMsg := ""
            IF ! oCalcsAcc:LoadFromPymnt( cPaySelect, MEMVAR->ENT, WAGES->MAINPOST, NIL, @cErrorMsg )
                Message( "S" + cErrorMsg )
                BREAK
            ENDIF

            apPayInfo := { cPaySelect,;                         // Вид оплаты
                          SayRefer( "PYMNT", cPaySelect, 30 ),; // Описание
                          WAGES->MAINPOST,;                     // Должность
                          oCalcsAcc,;                           // Счет
                          "08##0###",;                          // Вид суммы для расчета
                          0,;                                   // Сумма для расчета
                          "",;                                  // Параметры
                          0;                                    // Сумма
                          }
        ELSE
            oCalcsAcc := CalcsAccs():new()
            IF ! oCalcsAcc:LoadFromCalcs()
                BREAK
            ENDIF
            apPayInfo := { CALCS->PAYTYPE,;                     // Вид оплаты
                          CALCS->COMMENT,;                      // Описание
                          CALCS->POST,;                         // Должность
                          oCalcsAcc,;//SUBSTR(CALCS->DACC,3,6),;             // Счет
                          CALCS->SUMTYPE,;                      // Вид суммы для расчета
                          CALCS->COUNTSUM,;                     // Сумма для расчета
                          CALCS->PARAM,;                        // Параметры
                          CALCS->SUMMA;                         // Сумма
                         }

        ENDIF

        cPaySelect := apPayInfo[ 1 ]

        // Добавление записи или редактирование
        IF nKey = K_INS .OR. ( nKey = K_ENTER .AND. CALCS->SHLSTCODE == SPACE(UQ_CodeLen() ) )

            // Запомним старую сумму по данному виду оплаты
            IF nKey = K_ENTER
                nOldSum        := CALCS->SUMMA
                apPayDate[ 1 ] := CALCS->DATEPRODUC
                apPayDate[ 2 ] := CALCS->FDATEREC
                apPayDate[ 3 ] := CALCS->METOD
            ENDIF

            // Вызов метода редактирования суммы

            // Для этого найдем вид оплаты в справочнике
            SELECT PYMNT
            DB_SETORDER( "CODE" )
            IF ! DBSEEK( apPayInfo[ 1 ] )
                ALERT( "Вид оплаты '" + apPayInfo[ 1 ] + "' не найден в справочнике видов оплат" )
                BREAK
            ENDIF

            // Допустимого метода нет или указано, что это сумма
            IF EMPTY( PYMNT->METOD ) .OR. !( "W_" == UPPER( LEFT( PYMNT->METOD, 2 ) ) ) .OR. IF( nKey=K_ENTER, (CALCS->(FIELDNUM("METOD"))>0.AND.CALCS->METOD=1), .F. )
                    // Работает метод по умолчанию
                bBlock := {|x,y| MacroRun( MEMVAR->ModSysPath + "W_SUMMA.MAC", "A", { x, y } ) }
            ELSE
                // Работает определенный метод расчета
                IF ! CompileCode( PYMNT->EDITMETOD, @bBlock )
                    ALERT( "Ошибка компиляции метода;для вида оплаты "+'"'+ cPaySelect +'"' )
                    BREAK
                ENDIF
            ENDIF

            SELECT CALCS

            IF ExecuteCode( bBlock, @aResult, apPayInfo, cPaySelect )
                apPayInfo := aResult
                lDone := ! EMPTY( apPayInfo )
                IF lDone
                    // Вернули некорректное значение
                    IF VALTYPE( apPayInfo ) = "A" .AND. !LEN( apPayInfo ) = 8
                        lDone := .F.
                        ALERT( "Метод расчета вида оплаты "+'"'+ cPaySelect +;
                             '";возвратил некорректное значение' )
                        BREAK
                    ELSEIF VALTYPE( apPayInfo ) <> "A"
                        xReturn := TB_REF_ALL
                        BREAK
                    ENDIF
                ELSE
                    xReturn := TB_REF_ALL
                    BREAK
                ENDIF
            ELSE
                ALERT( "Ошибка выполнения метода;для вида оплаты                        " )
                BREAK
            ENDIF

            SELECT CALCS

            // Если это было добавление записи
            IF nKey = K_INS
                // Добавим запись
                nRecnoBefore := RECNO()
                AddCalcsRec( cPaySelect, IF( npMode = 1, 20, IF( npMode = 2, 40, 60 ) ) )
            ELSE
                oBack := BackTracking():new()

                IF !oBack:SaveRec()
                    oBack:SayError()
                    BREAK
                ENDIF
            ENDIF

            CALCS->COMMENT    := apPayInfo[ 2 ]   // Описание
            CALCS->POST       := apPayInfo[ 3 ]   // Должность

            IF VALTYPE( apPayInfo[ 4 ] ) == "O"// .AND. LEN( apPayInfo[ 4 ] ) = 6 .AND. ! EMPTY( apPayInfo[ 4 ] )
                CALCS->( CalcsObjectToTable( apPayInfo[ 4 ] ) )
            ENDIF

            IF nKey = K_INS
               xTemp := GetPrimaryFkr()
               CALCS->DFKR     := xTemp[1]
               CALCS->REFBU    := xTemp[2]
            ENDIF

            CALCS->SUMTYPE    := apPayInfo[ 5 ]   // Вид суммы для расчета
            CALCS->COUNTSUM   := apPayInfo[ 6 ]   // Сумма для расчета
            CALCS->PARAM      := apPayInfo[ 7 ]   // Параметры
            CALCS->SUMMA      := ROUND( apPayInfo[ 8 ], 2 )   // Сумма

            IF !EMPTY( apPayDate ) .AND. VALTYPE(apPayDate[ 1 ]) == "D" .AND. VALTYPE(apPayDate[ 2 ]) == "D" .AND.;
               VALTYPE( apPayDate[ 3 ]) = "N"
                CALCS->DATEPRODUC := apPayDate[ 1 ]   // Относится к какой дате
                CALCS->FDATEREC   := apPayDate[ 2 ]   // Относится до какой даты
                CALCS->METOD      := apPayDate[ 3 ]   // Метод начисления выплаты
            ELSE
                CALCS->DATEPRODUC := CTOD(" / / ")
                CALCS->FDATEREC   := CTOD(" / / ")
                CALCS->METOD      := 0
            ENDIF

            IF !EMPTY( MEMVAR->dpDateTarif )
                CALCS->TARIFDATE := MEMVAR->dpDateTarif
            ENDIF

            xReturn := TB_REF_ALL

            // проверить, а можно ли добавлять метод с такими параметрами
            cErrorMsg := ""
            IF ! CalcSheets():AllowCalcChange( .T. )
                IF !EMPTY( cErrorMsg )
                    ALERT( "!" + cErrorMsg + " Изменения в видах оплат сотрудника не сохранены.")
                ENDIF
                IF nKey == K_INS
                    SOFT_DELETE()

                    DBGOTO( nRecnoBefore )
                ELSE
                    oBack:Undo()
                ENDIF
            ENDIF

        // Удаление записи
        ELSEIF nKey = K_DEL
            IF ALERT( "Удалить запись ?", { "Удалить", "Отказ" } ) = 1
                IF CalcSheets():CalcWasPayed(, .T. )
                    BREAK
                ENDIF

                Tb_Delete()
            ELSE
                BREAK
            ENDIF
        ENDIF

        SELECT CALCS

        // Удаление автоначислений и автоудержаний
        // Так как при добавлении нового начисления или удержания
        // Автоначисления или автоудержания будут изменены

        // Если это было редактирование //(и сумма не изменилась)
        IF nKey = K_ENTER //.AND. ABS( nOldSum - CALCS->SUMMA ) < 0.01
            xReturn := TB_REF_CUR
            BREAK
        ENDIF

        // Признак расчитанности записи
        WAGES->ISCALC := .F.

        aScope := SaveScope()

        // В случае начисления
        IF npMode = 1
            // Установка признака пересчета всех автоначислений и автоудержаний
            // SBT_Delete( { 30, 50 } )
            MEMVAR->apRegenWages := { .F., .T., .T. }

        // В случае удержания
        ELSEIF npMode = 2
            // Установка признака пересчета всех автоудержаний
            MEMVAR->apRegenWages := { .F., .F., .T. }

        ENDIF

        RestScope( aScope )

        GO TOP

        ALL_FIELDS_WAS_REPLACE
        xReturn := TB_REF_ALL

    END SEQUENCE

    SELECT CALCS

    RETURN( xReturn )


*------------------------------------------------------*
*   Выбор должности по которой происходит начисление вида оплаты

    FUNCTION WagesPostSelect( nPost, nStav, nRazr, xStav, nDays, nWork, lHours, cWagescode, lTarif, dDate)
*------------------------------------------------------*
    // nPost - должность
    // nStav - кол-во ставок
    // nRazr - разряд

    // Сохраним установки на JOBTB
    LOCAL nRecno
    LOCAL nOrder
    LOCAL aSelectCode
    LOCAL aTemp
    LOCAL aScope
    LOCAL cFilter
    LOCAL cAlias := ALIAS()

    LOCAL aSelectTarif, aTarif, xTarif

    DEFAULT lHours IS .F.
    DEFAULT cWagescode IS WAGES->CODE
    DEFAULT lTarif IS .F.
    DEFAULT dDate  IS MEMVAR->DATE

    BEGIN SEQUENCE

    IF nStav <> NIL.AND.nRazr <> NIL
        nPost := { nPost, nStav, nRazr, xStav[2],nDays, nWork, "" }
    ENDIF

    IF SELECT( "JOBTB" ) = 0
        BREAK
    ENDIF

    SaveSet()

    nRecno  := JOBTB->( RECNO() )
    nOrder  := JOBTB->( INDEXORD() )
    aScope  := JOBTB->( SaveScope() )
    cFilter := JOBTB->( DBFILTER() )

    SELECT JOBTB
    SET FILTER TO
    DB_SETORDER( "CODE" ) // По месяцу и коду

    SET SCOPE TO DTOS( BOM( dDate ) ) + cWagescode
    GO TOP

    DBSELECT FILE ( "JOBTB" );
        INDEX ( "CODE" );
        SAYBLOCK ( 'PADRIGHT( SayPost(POST,SUBJECT,SUBJTYPE,20), 40 )' );
        RETVAL ( { "POST","TRRECCODE","NORMDAYS","WRKDDAYS","NORMHOURS","WRKDHOURS", "TARIFCODE", "TARIFDATE" } );
        HEADER   ( "Выбор должности сотрудника" );
        WINDOW_H (5);
        OPENWINDOW ( YES );
        COLOR ( {|| IF( FIELD->MAINPOST, ColorBlock( "AUTO" ), ColorBlock( "NUMERIC" ) ) } );
    TO aSelectCode

    IF ! EMPTY( aSelectCode )
        IF !lTarif
            IF nStav == NIL.AND.nRazr == NIL
                nPost := aSelectCode[ 1 ]
            ELSE
                aTemp := EXTRACT({0,"",0},"VAL", FILE_NAME("TRREC",MEMVAR->ENT), {"KSTAV","RAZ", xStav[1]}, {"RECCODE", aSelectCode[2], aSelectCode[2]} )
                nPost := { aSelectCode[1], aTemp[1], aTemp[2], aTemp[3], IF(!lHours, aSelectCode[3],aSelectCode[5]),IF(!lHours,aSelectCode[4],aSelectCode[6]), "" }

            ENDIF
        ELSE
            IF !MODINIT( { "TARIF", "TRREC" }, ,, MEMVAR->ENT )
                BREAK
            ENDIF

            aTarif := { {}, {}, {} }

            TARIF->( DB_SETORDER( "TARIFDATE" ) )
            TARIF->( ORDSCOPE( 0, JOBTB->CODE + JOBTB->JOBSCODE + DTOS( EOM( dDate ) ) ) )
            TARIF->( ORDSCOPE( 1, JOBTB->CODE + JOBTB->JOBSCODE ) )
            TARIF->( DBGOTOP() )
            IF TARIF->( !EOF() )
                WHILE BOM( TARIF->TARIFDATE ) == BOM( dDate )
                    // есть перетарификация
                    TRREC->( DB_SETORDER( "TARCODE" ) )
                    TRREC->( ORDSCOPE( 0, TARIF->TARIFCODE ) )
                    TRREC->( ORDSCOPE( 1, TARIF->TARIFCODE ) )
                    TRREC->( DBGOTOP() )
                    WHILE TRREC->( !EOF() )
                        IF TRREC->POSTCODE == aSelectCode[ 1 ]
                            AADD( aTarif[ 2 ], SayDate( TARIF->TARIFDATE, "DD MMMMM YYYY") )
                            AADD( aTarif[ 1 ], TRREC->RECCODE )
                        ENDIF
                        TRREC->( D_SKIP() )
                    END
                    TARIF->( D_SKIP() )
                END

                TRREC->( DB_SETORDER( "TARCODE" ) )
                TRREC->( ORDSCOPE( 0, TARIF->TARIFCODE ) )
                TRREC->( ORDSCOPE( 1, TARIF->TARIFCODE ) )
                TRREC->( DBGOTOP() )
                WHILE TRREC->( !EOF() )
                    IF TRREC->POSTCODE == aSelectCode[ 1 ]
                        AADD( aTarif[ 2 ], SayDate( TARIF->TARIFDATE, "DD MMMMM YYYY") )
                        AADD( aTarif[ 1 ], TRREC->RECCODE )
                    ENDIF
                    TRREC->( D_SKIP() )
                END

                IF !EMPTY( xTarif := SprSelect( aTarif[ 2 ],,,,,"Выберите дату тарификации") )
                    xTarif := aTarif[ 1 ][ xTarif ]
                ELSE
                    xTarif := aSelectCode[ 2 ]
                ENDIF

                aTemp := EXTRACT({0,"",0,CTOD("")},"VAL", FILE_NAME("TRREC",MEMVAR->ENT), {"KSTAV","RAZ", xStav[1], "TARIFDATE"}, {"RECCODE", xTarif, xTarif } )

                IF nStav == NIL.AND.nRazr == NIL
                    nPost := { aSelectCode[ 1 ], aTemp[ 4 ] }
                ELSE
                    nPost := { aSelectCode[1], aTemp[1], aTemp[2], aTemp[3], IF(!lHours, aSelectCode[3],aSelectCode[5]),IF(!lHours,aSelectCode[4],aSelectCode[6]), aTemp[ 4 ] }
                ENDIF

            ENDIF

        ENDIF
    ENDIF

    RestSet()

    // Восстановим установки на JOBTB
    JOBTB->( SETFILTER(cFilter) )
    JOBTB->( DB_SETORDER( nOrder ) )
    JOBTB->( RestScope(aScope) )
    JOBTB->( DBGOTO( nRecno ) )

    END SEQUENCE
    DBSELECTAREA(cAlias)

    RETURN( nPost )

*------------------------------------------------------*
*   Расчет суммы "По тарифу"

    FUNCTION SumByTarif( x, lStatus, aCount, lCalcECH, lLogAllWages )
*   aCount - что пересчитывать { тариф, автоначисл, автоудерж. }
*    В базе CALCS поле MODE может принимать следующие значения:
*
*    10 - По тарификации        - Подлежит удалению
*    20 - Разовые начисления
*    30 - Автоначисления        - Подлежит удалению
*    40 - Разовые удержания
*    50 - Автоудержания         - Подлежит удалению
*    lLogAllWages               - какой лог заполняем при обновлении - одного сотрудника или всего списка (.T.)
*------------------------------------------------------*

    LOCAL nTarifSum := 0
    LOCAL nPlusSum  := 0
    LOCAL nMinusSum := 0
    LOCAL lLocked   := WAGES->( IsLocked() )
    LOCAL aPayI
    LOCAL aDay  :={}
    LOCAL nP
    LOCAL aScope
    LOCAL nPost
    LOCAL cTemp
    LOCAL nCount
    LOCAL aDeletedDolg := {}
    LOCAL cOldFilter
    LOCAL aAlias := {}

    PRIVATE opWagesLog

    DEFAULT lCalcECH     IS .F.
    DEFAULT lLogAllWages IS .F.

    IF WAGES->TYPE = 10
        // Штатные сотрудники
        RestoreWageRelation()
    ELSEIF WAGES->TYPE = 20
        // Нештатные сотрудники
        RestoreUnWageRelation()
    ENDIF


    // Запись по зарплате блокирована
    IF WAGES->LOCKED .OR. WagesClose()
        RETURN( x )
    ENDIF

    IF BOM( WAGES->MONTH ) != BOM( MEMVAR->DATE )
        ALERT( "!Внимание! Текущая дата отличается от даты просмотра архива зарплаты. Расчет з/п произведен не будет. Рекомендуется перезапустить модуль 'Персонал'." )
        RETURN( x )
    ENDIF

    IF EMPTY(SELECT("POSTS")) .AND. !ReferInit({"POSTS"})
        BREAK
    ENDIF

    IF IsOtrSys( MEMVAR->DATE ) //отраслевая система оплаты
        IF EMPTY(SELECT("NSGRP"))
            IF !MODINIT( { "NSGRP" },,, MEMVAR->ENT )
                BREAK
            ENDIF
            AADD(aAlias, "NSGRP")
        ENDIF

        IF EMPTY(SELECT("STAFF"))
            IF ! OpenStaffByDate( MEMVAR->DATE, MEMVAR->ENT )
                BREAK
            ENDIF
            AADD(aAlias, "STAFF")
        ENDIF

        IF EMPTY(SELECT("QUALCAT"))
            IF !OpenSettingsTable("QUALCAT")
                BREAK
            ENDIF
            AADD(aAlias, "QUALCAT")
        ENDIF

        IF EMPTY(SELECT("STAJKOEF"))
            IF !OpenSettingsTable("STAJKOEF")
                BREAK
            ENDIF
            AADD(aAlias, "STAJKOEF")
        ENDIF

        IF EMPTY(SELECT("PERCR"))
            IF !MODINIT( { "PERCR" }, MEMVAR->YEAR,, MEMVAR->ENT )
                BREAK
            ENDIF
            AADD(aAlias, "PERCR")
        ENDIF

        IF EMPTY(SELECT("SQUAL"))
            IF !MODINIT( { "SQUAL" },, ,MEMVAR->ENT )
                BREAK
            ENDIF
            AADD(aAlias, "SQUAL")
        ENDIF
    ENDIF

    opWagesLog := XLSLog():new("WAGESLOG", "local", "",.T.)
    opWagesLog:ADDCaption( "msg", "Сообщения" )

    SaveSet()

    SELECT WAGES

    IF ! lLocked
        IF ! ReferLock()
            RestSet()
            RETURN( x )
        ENDIF
    ENDIF

    DEFAULT lStatus IS .T.
    // 1- тариф, 2-автоначисл, 3-автоудерж.
    DEFAULT aCount  IS { .T., .T., .T. }

    IF lStatus .AND. CalcSheets():IsInFinalSheet( ,, .F. )
        IF ALERT( "!Существуют окончательные ведомости по данному сотруднику!", { "Продолжить", "Прервать" } ) != 1
            RestSet()
            RETURN( x )
        ENDIF
    ENDIF

    BeginStatus()

    SayStatus( SayFio(.T.) + ";Подготовка информации" )

    IF aCount[ 1 ] .AND. aCount[ 2 ] .AND. aCount[ 3 ]
        SBT_Delete( { 10, 30, 50 },,, @aDeletedDolg )
    ELSEIF ! aCount[ 1 ] .AND. aCount[ 2 ] .AND. aCount[ 3 ]
        SBT_Delete( { 30, 50 },,, @aDeletedDolg )
    ELSEIF ! aCount[ 1 ] .AND. ! aCount[ 2 ] .AND. aCount[ 3 ]
        SBT_Delete( { 50 },,, @aDeletedDolg )
    ENDIF

    SELECT PYMNT
    DB_SETORDER( "CODE" )
    SET SCOPE TO

    IF aCount[ 1 ]
        // *** Перенос суммы из тарификации
        SBT_Tarif( aDeletedDolg, lLogAllWages )
    ENDIF

    // Если нужны автоначисления
    IF aCount[ 2 ]

        // *** Перенос сумм из больничных
        // переносим суммы из больничных для тех типов физических для которых он начислен
        SBT_Hospital()
        SBT_Hospital( 1, .T. )
        SBT_Hospital( 1, .F. )

        // Пособия до 1,5 лет в соответствии с 207-ФЗ не
        // должны переходить в з/плату ранее 01.01.2007
        IF MEMVAR->YEAR >= 2007
            SBT_Benifit()
        ENDIF
        // *** Перенос сумм из отпускных
        SBT_Vocation()

        IF SELECT( "JOBTB" ) > 0

            // *** расчет сумм за ночные и праздничные
            SBT_Night()

            // *** расчет сумм за доп.часы
            SBT_DopTabel()

            SBT_Replace()
        ENDIF
    ENDIF

    // Долг за работником
    IF aCount[ 3 ]
        PYMNT->( SaveSet() )
        SBT_Income()
        PYMNT->( ORDSCOPE( 0, "" ) )
        PYMNT->( ORDSCOPE( 1, "" ) )
        PYMNT->( RestSet() )
        PYMNT->( ORDSCOPE( 0, "" ) )
        PYMNT->( ORDSCOPE( 1, "" ) )
    ENDIF

    IF SELECT("JOBTB") > 0 .AND. !EMPTY( aPayI := EXTRACT( {}, "ARR", "PYMNT", "CODE", {"GROUP", "21", "21" } ) )

        SayStatus( SayFio(.T.) + ";разовая премия по табелю..." )

        SELECT CALCS
        DB_SETORDER( "GROUP" )
        ORDSCOPE(0, DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE)
        ORDSCOPE(1, DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE)

        cOldFilter := CALCS->( DBFILTER() )

        FOR nCount := 1 TO LEN( aPayI )
            SETFILTER("FIELD->PAYTYPE == '" +aPayI[ nCount ] + "' .AND. (FIELD->MODE==20 .OR. FIELD->MODE==30)")
            DBGOTOP()

            WHILE !EOF()

                cTemp := LEFT( SUBSTR(CALCS->PARAM, RAT("/", CALCS->PARAM ) + 1 ), UQ_CodeLen() )
                IF !EMPTY( cTemp ) .AND. !EMPTY( aDay := EXTRACT( NIL, "VAL", "JOBTB", {"NORMDAYS", "WRKDDAYS"},;
                         {"ANYPOST", DTOS(BOM(WAGES->MONTH)) + WAGES->CODE + WAGES->JOBSCODE + cTemp } ) ) .AND. ReferLock()
                    CALCS->SUMMA:=ROUND( VAL( TOKEN(CALCS->PARAM, "/",1 ) ) * D( aDay[2], aDay[1] ), 2 )
                    UN_LOCK()
                ENDIF

                CALCS->( D_SKIP() )
            ENDDO
        NEXT

        CALCS->( SETFILTER(cOldFilter) )
    ENDIF

    // *** Перенос сумм из таблицы оснований

    SayStatus( "Долг за предприятием" )
    UpdateOutcmEntDolg( .F. )

    // Восстановим все RELATION
    IF WAGES->TYPE = 10
        // Штатные сотрудники
        InitWageRelations()
    ELSEIF WAGES->TYPE = 20
        // Нештатные сотрудники
        InitUnWageRelations()
    ENDIF

    BEGIN SEQUENCE
        SELECT CALCS
        DB_SETORDER( "WAGESCODE" )
        SET SCOPE TO WAGES->RECCODE + "10",;
                     WAGES->RECCODE + "60"
        DBGOTOP()

        SBT_Koef( aCount, aDeletedDolg )
    END SEQUENCE

    UpdateProfit()

    IF aCount[ 3 ]
        // расчет П/Н в зарплате
        SayStatus( SayFio(.T.) + ";НДФЛ" )
        aPayI := SBT_Tax()
        // Исполнительные листы
        SayStatus( SayFio(.T.) + ";Исполнительные листы" )
        SBT_Penalty( aPayI )

    ENDIF

    SayStatus( "Долг за работником по ведомостям" )
    UpdateOutcmVedDolg( .F. )

    RemovePayTypesAsManual( { { 50, 40 } } )

    IF aCount[ 3 ]
        SayStatus( SayFio(.T.) + ";Перечисления в банк" )
        SBT_Bank()
    ENDIF

    SayStatus( SayFio(.T.) + ";Расчет сумм..." )
    SELECT CALCS
    DB_SETORDER( "WAGESCODE" )
    SET SCOPE TO WAGES->RECCODE + "10",;
                 WAGES->RECCODE + "60" // Начисления - Удержания
    DBGOTOP()
    DO WHILE ! EOF()
        IF FIELD->MODE = 10
            nTarifSum += FIELD->SUMMA
        ELSEIF FIELD->MODE >= 20 .AND. FIELD->MODE <= 30
            nPlusSum += FIELD->SUMMA
        ELSEIF FIELD->MODE >= 40 .AND. FIELD->MODE <= 50 .AND. FIELD->GROUP != 80
            nMinusSum += FIELD->SUMMA
        ENDIF
        SKIP
    ENDDO

    // Накопления
    WAGES->TARIF  := nTarifSum
    WAGES->PLUS   := nPlusSum
    WAGES->MINUS  := nMinusSum
    WAGES->SUM    := WAGES->TARIF + WAGES->PLUS

    aPayI := GetWageSumByAcc( ,,,.T.,,,,,.T. )
    nPlusSum := 0
    AEVAL( aPayI[3], {|x| nPlusSum += IF( x[2] > 0, x[2], 0 ) } )
    WAGES->BYHAND := nPlusSum

    SELECT WAGES

    EndStatus()

    // Признак того, что запись полностью рассчитана
    WAGES->ISCALC := .T.

    MEMVAR->apRegenWages := { .F., .F., .F. }

        UpDatProfS()

        // расчет ЕСН, если в настройке ЗП
        // стоит признак автоматического расчета ЕСН, а
        // ПН рассчитывается по начисленному доходу

    IF opWagesLog:GetMessageCount() > 0 .AND. ALERT("Просмотреть отчет о расчете заработной платы", {"Просмотреть отчет", "Продолжить"}) == 1
        opWagesLog:Save()
        opWagesLog:Show()
    ENDIF

    IF ! lLocked
        UN_LOCK()
    ENDIF
    RestSet()

    FOR nCount := 1 TO LEN(aAlias)
        DBCLOSE(aAlias[nCount])
    NEXT

    RETURN( WAGES->TARIF )

*------------------------------------------------------*
*   получение суммы, уплаченной по данному листу
    FUNCTION GetExSheetSum(cCode,cPaytype,cReccode, sDate, fDate)
*------------------------------------------------------*
    LOCAL nSum, cFilter, cAlimFilter
    LOCAL nYear1, nYear2, nYear
    LOCAL aScope, nRecno
    LOCAL cFilename, nAmount
    LOCAL oUT := UTables():new()
    LOCAL aEnts := Extract( {}, "ARR", MEMVAR->SprPath + "such.dbf", "ENT", "FIELD->ACCENT=='" + MEMVAR->ENT + "'" )
    LOCAL nI, aX

    nSum := 0

    aX := Extract( "", "VAL", MEMVAR->SprPath + "such.dbf", "ACCENT", "FIELD->ENT=='" + MEMVAR->ENT + "'" )
    IF ! EMPTY( aX )
        AADD( aEnts, aX )
        aX := Extract( {}, "ARR", MEMVAR->SprPath + "such.dbf", "ENT", "FIELD->ACCENT=='" + aX + "'" )
        FOR nI := 1 TO LEN( aX )
            AADD( aEnts, aX[ nI ] )
        NEXT
    ENDIF

    AADD( aEnts, MEMVAR->ENT )

    SaveSet()
    //сохраняем состояния CALCS
    aScope := CALCS->( SaveScope() )
    nRecno := CALCS->( RECNO() )
    cFilter := CALCS->( DBFILTER() )

    BEGIN SEQUENCE
        IF EMPTY(sDate) .OR. EMPTY(fDate)
            BREAK
        ENDIF
        nYear1 := Year( sDate )
        nYear2 := MIN( Year( fDate ), YEAR( MEMVAR->DATE ) )

        FOR nI := 1 TO LEN( aEnts )

            FOR nYear := nYear1 TO nYear2
                IF oUT:select( "CALCS", aEnts[nI], , nYear )
                    cAlimFilter := "FIELD->PAYTYPE=='"+cPaytype+"' .AND. ('"+cReccode+"' $ FIELD->SUMTYPE) .AND. DTOS(FIELD->MONTH)<='"+;
                        DTOS(EOM(MEMVAR->DATE))+"'"
                    nAmount := Extract(0,"SUM",ALIAS(),"SUMMA",{"AVERAGE",cCode,cCode,cAlimFilter})
                    nSum    += nAmount
                ENDIF
            NEXT

        NEXT

    END SEQUENCE

    oUT:Destroy()

    //восстанавливаем состояния CALCS
    RestSet()
    CALCS->( RestScope(aScope) )
    CALCS->( SetFilter(cFilter) )
    CALCS->( DbGoto(nRecno) )


    RETURN nSum

*------------------------------------------------------*
*   Исполнительные листы

    STATIC PROCEDURE SBT_Penalty( aSumTax )
*------------------------------------------------------*
    LOCAL nFSum
    LOCAL nRevSum
    LOCAL aPays
    LOCAL nPays
    LOCAL aEntTb
    LOCAL nI, nJ
    LOCAL nSumAll
    LOCAL nCount
    LOCAL oGroups := Hash():new()
    LOCAL nSum, aGroups := {}, aParam := {}
    LOCAL cFilter, nAlimAll, nPayPer
    LOCAL aScope, nRecno
    PRIVATE pAlimAmount := 0

    IF ! MODINIT( { "EXSHT" } ) .OR. ! ReferInit( { "PYMNT" } )
        RETURN
    ENDIF

    SaveSet()
    // формирование алиментов
    SELECT EXSHT
    DB_SETORDER( "CODE" )
    SET SCOPE TO WAGES->CODE
    GO TOP

    DO WHILE !EOF()
        IF BOM(FIELD->SDATE) <= BOM(MEMVAR->DATE)  .AND. ( EMPTY( FIELD->FDATE ) .OR. BOM(MEMVAR->DATE) <= BOM(FIELD->FDATE) )
            BEGIN SEQUENCE
            aPays := EXTRACT( {}, "ARR", "CALCS", { "PAYTYPE", "SUMMA", "0", "POST" }, { "WAGESCODE", WAGES->RECCODE + "10", WAGES->RECCODE + "30" } )
            aEntTb := EXTRACT( {}, "ARR", MEMVAR->SprPath + "enttb.dbf", { "SLAVE", "PERCENT" }, { "MASTER", EXSHT->PAYMNT, EXSHT->PAYMNT } )
            // сумма начислений
            nPays := 0
            FOR nI := 1 TO LEN( aPays )
                nCount := ASCAN( aEntTb, {|x| x[1] == aPays[nI][1] } )
                IF nCount != 0
                    IF aEntTb[nCount][2] > 0
                        nPays += aPays[nI][2]
                    ENDIF
                ENDIF
            NEXT
            // заменяемый блок - неберем то что не имеет вхождения в подоходный

            // Сумма от которой считаются алименты
            nFSum := nPays
            // минус подоходный налог
            IF !EMPTY( aSumTax )
                FOR nI := 1 TO LEN(aSumTax)
                    nFSum -= aSumTax[nI]
                NEXT
            ENDIF

            ///////////////////////////////////////////////////
            // разобьем облагаемый доход по суммам начислений
            ///////////////////////////////////////////////////
            nRevSum := 0

            // заменяемый блок - неберем то что не имеет вхождения в подоходный
            FOR nI := 1 TO LEN( aPays ) - 1
                nCount := ASCAN( aEntTb, {|x| x[1] == aPays[nI][1] } )
                IF nCount != 0
                    IF aEntTb[nCount][2] > 0
                        aPays[nI][3] := D( nFSum * aPays[nI][2], nPays )
                        nRevSum += aPays[nI][3]
                    ENDIF
                ENDIF
            NEXT

            IF LEN( aPays ) > 0
                aPays[ LEN( aPays ) ][ 3 ] := nFSum - nRevSum
            ENDIF

            //сохраняем состояния CALCS
            aScope := CALCS->( SaveScope() )
            nRecno := CALCS->( RECNO() )
            cFilter := CALCS->( DBFILTER() )
            DO WHILE ! EOF()
                IF BOM(FIELD->SDATE) <= BOM(MEMVAR->DATE)  .AND. ( EMPTY( FIELD->FDATE ) .OR. BOM(MEMVAR->DATE) <= BOM(FIELD->FDATE) )
                    IF !EMPTY(EXSHT->TOPLIM)
                        //получение суммы, уплаченной по данному листу
                        nAlimAll := GetExSheetSum(WAGES->CODE, EXSHT->PAYMNT, EXSHT->RECCODE, EXSHT->SDATE, EXSHT->FDATE)
                    ELSE
                        nAlimAll :=0
                    ENDIF
                    // вычисление облагаемой суммы доходов в соответствие с таблицей входимости данного вида алиментов
                    aEntTb := EXTRACT( {}, "ARR", MEMVAR->SprPath + "enttb.dbf", { "SLAVE", "PERCENT" }, { "MASTER", EXSHT->PAYMNT, EXSHT->PAYMNT } )
                    nFSum   := 0
                    nSumAll := 0
                    FOR nI := 1 TO LEN( aPays )
                        nJ := ASCAN( aEntTb, {|x| x[ 1 ] == aPays[ nI ][ 1 ] } )
                        IF nJ != 0
                            nFSum += aPays[ nI ][ 3 ] * aEntTb[ nJ ][ 2 ] / 100
                            nSumAll += aPays[ nI ][ 2 ] * aEntTb[ nJ ][ 2 ] / 100
                        ELSE
                            nFSum += aPays[ nI ][ 3 ]
                            nSumAll += aPays[ nI ][ 2 ]
                        ENDIF
                    NEXT

                    IF EXSHT->GROUP!=0
                        //групповая обработка записей
                        //не считаем почтовый сбор          1     2       3              4            5      6    7       10
                        CountMethod( EXSHT->PAYMNT, "0", { nFSum, 0, WAGES->CODE, WAGES->JOBSCODE, nSumAll, .T., .F.,,,nAlimAll } )
                        nSum := oGroups:get(EXSHT->GROUP,0)
                        oGroups:put(EXSHT->GROUP, nSum + MEMVAR->pAlimAmount)
                    ELSE                                            //  1    2      3              4            5       6        10
                        nRevSum := CountMethod( EXSHT->PAYMNT, "0", { nFSum, 0, WAGES->CODE, WAGES->JOBSCODE, nSumAll, .T.,,,,nAlimAll } )
                    ENDIF
                ENDIF

                SELECT EXSHT
                SKIP
            ENDDO

            //вычисление почтового сбора для каждой группы
            aGroups := oGroups:ArrGet()
            FOR nI := 1 TO Len(aGroups)
                EXSHT->( SetFilter("FIELD->GROUP="+RemAll(Str(aGroups[nI][1]))) )
                GO TOP
                IF !EOF()
                    nSum    := aGroups[nI][2]
                    //считаем только почтовый сбор от суммы
                    //                                 1  2       3              4         5   6    7   8   9
                    CountMethod( EXSHT->PAYMNT, "0", { 0, 0, WAGES->CODE, WAGES->JOBSCODE, 0, .T., .T.,.T.,nSum} )
                ENDIF
            NEXT

            END SEQUENCE
            //восстанавливаем состояния CALCS
            RestScope(aScope)
            CALCS->( SetFilter(cFilter) )
            CALCS->( DbGoto(nRecno) )
            EXIT
        ENDIF
        SKIP
    ENDDO

    DBCLEARFILTER()

    RestSet()

    RETURN



*------------------------------------------------------*
*   Подоходный налог

    STATIC FUNCTION SBT_Tax()
*------------------------------------------------------*
    #define SAVE     .T.
    #define NOT_SAVE .F.

    LOCAL aTax, aArr, nSum
    LOCAL nCount
    LOCAL aSumTax := ARRAY( LEN(asType) )
    LOCAL aSumEntry, nI, nSumEntry
    LOCAL nSumAll, nSumTax
    LOCAL lNotCountTax
    LOCAL xTemp
    LOCAL lAddCalc := .F.
    LOCAL oCalcAcc
    LOCAL cErrorMsg
    LOCAL cDacc

    IF ! MODINIT( { "PROFT" }, MEMVAR->YEAR )
        RETURN 0
    ENDIF

    PROFT->( DB_SETORDER( "JOBSCODE" ) )
    PROFT->( ORDSCOPE( 0, NIL ), ORDSCOPE( 1, NIL ) )

    IF WAGES->TYPE <> 10
        lNotCountTax := Extract( .F., "VAL", MEMVAR->SprPath+"prsct.dbf", "TAX_MODE", {"CODE", STRZERO( WAGES->TYPE, 2 ), STRZERO( WAGES->TYPE, 2 ) } )
    ELSE
        lNotCountTax := .F.
    ENDIF

    aTax := TestTaxes( WAGES->CODE, WAGES->JOBSCODE, MEMVAR->DATE, !lNotCountTax, WAGES->TOFINAL, NOT_SAVE )

    // проверяем и заполняем хеш
    CheckAndUpdateTaxHash()

    IF lNotCountTax
        RETURN AFILL( ARRAY( LEN( asType ) ), 0 )
    ENDIF

    SELECT CALCS
    DB_SETORDER( "GROUP" )
    SET SCOPE TO

    FOR nCount := 1 TO LEN( asType )

        nSumTax := 0
        nSumAll := ROUND( aTax[nCount*2-1] + aTax[nCount*2], 2 )
        IF !EMPTY( nSumAll )
            IF ! DBSEEK( DTOS(BOM(MEMVAR->DATE)) + WAGES->CODE + WAGES->RECCODE + "40" + PADR(asType[nCount],6) )

                SaveSet()

                aSumEntry := { {} }

                SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + "10", ;
                             DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + "30"

                GO TOP

                nSumEntry := 0

                DO WHILE ! EOF()
                    IF MEMVAR->ohTax:get( FIELD->PAYTYPE ) != NIL .AND. ! CalcSheets():CalcWasPayed()
                        // Входит
                        oCalcAcc := CalcsAccs():new()

                        oCalcAcc:lMinus := .T.

                        IF ! oCalcAcc:LoadFromCalcs()
                            RETURN {}
                        ENDIF
                        cDacc := oCalcAcc:cFullSeekValue
                        xTemp := CALCS->SUMMA*GetEntryDefault( PADR( asType[ nCount ], 6 ), CALCS->PAYTYPE ) / 100
                        IF ( nI := ASCAN( aSumEntry[ 1 ], {|x| x[1] == CALCS->POST .AND. x[5] == cDacc } ) ) = 0
                            AADD( aSumEntry[ 1 ], { CALCS->POST,, xTemp, oCalcAcc, cDacc } )
                        ELSE
                            aSumEntry[ 1 ][ nI ][ 3 ] += xTemp
                        ENDIF
                        nSumEntry += xTemp
                    ENDIF
                    SKIP
                ENDDO

                FOR nI := 1 TO LEN( aSumEntry[ 1 ] )
                    IF nI < LEN( aSumEntry[ 1 ] )
                        xTemp := ROUND( D( aSumEntry[ 1 ][ nI ][ 3 ], nSumEntry ) * nSumAll, 0 )
                        aSumEntry[ 1 ][ nI ][ 3 ] := xTemp
                        nSumTax += xTemp
                    ELSE
                        aSumEntry[ 1 ][ nI ][ 3 ] := nSumAll - nSumTax
                    ENDIF
                NEXT

                nSumTax := 0

                SET SCOPE TO

                RestSet()

                IF WAGES->TOFINAL .AND. EMPTY( aSumEntry[ 1 ] )
// В случае "по расчет", даже если нет начислений - вонзаем сумму НДФЛ
                    oCalcAcc := CalcsAccs():new()
                    cErrorMsg := ""
                    oCalcAcc:lIsPlus := .F.
                    oCalcAcc:lMinus  := .F.

                    IF ! oCalcAcc:LoadFromPymnt( PADR( asType[ nCount ], 6 ), MEMVAR->ENT, WAGES->MAINPOST, WAGES->TYPE, @cErrorMsg )
                        Message( "S" + cErrorMsg )
                        RETURN {}
                    ENDIF
                    aSumEntry[ 1 ] := { { WAGES->MAINPOST,, nSumAll, ;
                                          oCalcAcc } }
                ENDIF
                IF ! EMPTY(aSumEntry ) .AND. ! EMPTY(aSumEntry[ 1 ] )
                    IF PYMNT->( DBSEEK( PADR( asType[ nCount ], 6 ) ) )
                        FOR nI := 1 TO LEN( aSumEntry[ 1 ] )
                            // подготавливаем корреспонденцию будущего вида оплаты
                            oCalcAcc := CalcsAccs():new()
                            oCalcAcc:lIsPlus := .F.
                            oCalcAcc:lMinus  := .F.

                            IF ! oCalcAcc:LoadFromPymnt( PADR( asType[nCount], 6 ), MEMVAR->ENT, aSumEntry[ 1 ][ nI ][ 1 ], WAGES->TYPE, @cErrorMsg )
                                Message( "S" + cErrorMsg )
                                LOOP
                            ENDIF
                            IF aSumEntry[ 1 ][ nI ][ 4 ] != NIL
                                oCalcAcc:join( aSumEntry[ 1 ][ nI ][ 4 ]:wacc, JoinAnalitHash( aSumEntry[ 1 ][ nI ][ 4 ]:ohAnalit, oCalcAcc:ohAnalit, PADR( asType[nCount], 6 ) ) )
                            ENDIF
                            IF CalcMayBeModified( PADR( asType[ nCount ], 6 ), 50, aSumEntry[ 1 ][ nI ][ 1 ], WAGES->JOBSCODE,;
                                     ,,, oCalcAcc:wacc,,,,.F. )
                                SOFT_APPEND()
                                FIELD->RECCODE  := UQ_CODE()       // Код записи
                                FIELD->MONTH    := MEMVAR->DATE    // Месяц
                                FIELD->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                FIELD->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                FIELD->CODE     := WAGES->CODE     // Табельный
                                FIELD->PRIORITY := PYMNT->PRIORITY        // приоритет вычисл
                                FIELD->GROUP    := PYMNT->GROUP //aSumEntry[ 2 ][ 3 ]       // группа
                                FIELD->POST     := aSumEntry[ 1 ][ nI ][ 1 ]
                                CalcsObjectToTable( oCalcAcc )

                                FIELD->MODE     := 50                        // Режим
                                FIELD->COMMENT  := PYMNT->NAME //aSumEntry[ 2 ][ 2 ]       // Примечание
                                FIELD->PAYTYPE  := PADR( asType[nCount], 6 )            // Вид оплаты
                                FIELD->SUMMA    := aSumEntry[ 1 ][ nI ][ 3 ] // Сумма-результат
                                nSumTax += aSumEntry[ 1 ][ nI ][ 3 ]
                            ENDIF
                        NEXT
                    ELSE
                        ALERT( "SВид оплаты с кодом '" + PADR( asType[nCount], 6 ) + "' не найден в справочнике видов оплат" )
                    ENDIF
                ENDIF
            ELSE
                nSumTax := 0

            ENDIF
        ENDIF
        // Засуняваем П/Н в PROFT
        IF !EMPTY( nSumTax )
            SELECT PROFT

            IF ! DBSEEK( WAGES->JOBSCODE + "2" + PADR( asProftType[nCount], 4 ) )
                SOFT_APPEND()
                FIELD->CODE     := WAGES->CODE
                FIELD->JOBSCODE := WAGES->JOBSCODE
                FIELD->ENT      := MEMVAR->ENT
                FIELD->RECCODE  := UQ_CODE()
                FIELD->PCODE    := asProftType[nCount]
                FIELD->PROFIT   := 2
                UN_LOCK()
            ENDIF
            IF ReferLock()
                FIELD->&( "MONTH" + STRZERO( MONTH( WAGES->MONTH ), 2 ) ) += nSumTax
                FIELD->PRSUM := SumRecord( "MONTH01", "MONTH" + STRZERO( MONTH( WAGES->MONTH ), 2 ) )
                UN_LOCK()
            ENDIF
        ENDIF
        SELECT PROFT
        IF DBSEEK( WAGES->JOBSCODE + "2" + PADR( asProftType[nCount], 4 ) )
            aSumTax[nCount] := FIELD->&( "MONTH" + STRZERO( MONTH( WAGES->MONTH ), 2 ) )
        ELSE
            aSumTax[nCount] := 0
        ENDIF
        SELECT CALCS
    NEXT

    SELECT WAGES
    TestTaxes( WAGES->CODE, WAGES->JOBSCODE, MEMVAR->DATE, .F., WAGES->TOFINAL, SAVE )

    RETURN aSumTax


*------------------------------------------------------*
*   Учет долга за работником

    STATIC PROCEDURE SBT_Income()
*------------------------------------------------------*
    LOCAL aIncome := GetWageIncome( 0, "OUTCOME" )
    LOCAL nCount
    LOCAL aGrouped := {}
    LOCAL nI
    LOCAL oCalcsAcc
    LOCAL cErrorMsg

    FOR nCount := 1 TO LEN( aIncome )
        IF aIncome[ nCount ][ 5 ] >= 50
            aIncome[ nCount ][ 2 ] := -aIncome[ nCount ][ 2 ]
        ENDIF

        nI := ASCAN( aGrouped, {|x| x[ 1 ] == aIncome[ nCount ][ 1 ] .AND. x[ 3 ] == aIncome[ nCount ][ 3 ] .AND. ;
             x[ 4 ] == aIncome[ nCount ][ 4 ] } )
        IF EMPTY( nI )
            AADD( aGrouped, ACLONE( aIncome[ nCount ] ) )
        ELSE
            aGrouped[ nI ][ 2 ] += aIncome[ nCount ][ 2 ]
        ENDIF

    NEXT

    IF !EMPTY( aIncome )
        FOR nCount := 1 TO LEN( aIncome )
            IF aIncome[ nCount ][ 2 ] > 0
                PYMNT->( DB_SETORDER( "GROUP" ) )
                IF ! PYMNT->( DBSEEK( "85" ) )
                    ALERT( "Обнаружено наличие долга за работником.;В справочнике ВО долг за работником не обнаружен;Добавьте вид оплаты с кодом группы 85 (долг за работником)" )
                    RETURN
                ENDIF
                oCalcsAcc := CalcsAccs():new()
                oCalcsAcc:lIsPlus := .F.

                IF LEN( aIncome[ nCount ] ) > 5 .AND. ! EMPTY( aIncome[ nCount ][ 6 ]:acc )
                    oCalcsAcc:dacc := aIncome[ nCount ][ 6 ]
                ENDIF
                oCalcsAcc:FillAnalitHash()
                IF aIncome[ nCount ][ 2 ] <> 0 .AND. CalcMayBeModified( PYMNT->CODE,;         // 1 Вид оплаты
                         50,;                  // 2 Режим
                         aIncome[ nCount ][ 3 ],;                  // 3 Должность сотрудника
                         WAGES->JOBSCODE,;              // 4
                         NIL, ;             // 5
                         NIL, ;              // 6 (не используется)
                         NIL, ;                 // 7 (не используется)
                         oCalcsAcc:wacc, ;                  // 8 Счет
                         NIL, ;            // 9 Проверять ли включенность в ведомость (не используется)
                         NIL, ;                   // 10 ФКР
                         NIL, ;                // 11 Вид деятельности
                         NIL, ;                // 12
                         NIL, ;                // 13
                         NIL ;         // 14 проверять существующие начисления
                        )
*------------------------------------------------------*
                    AddCalcsRec( PYMNT->CODE, 50 )
                    CALCS->SUMMA := aIncome[ nCount ][ 2 ]
                    CALCS->POST  := aIncome[ nCount ][ 3 ]
                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                ENDIF
            ELSEIF aIncome[ nCount ][ 2 ] < 0
                IF !CheckPymntGroup84()
                    RETURN
                ENDIF
                oCalcsAcc := CalcsAccs():new()
                oCalcsAcc:lIsPlus := .F.

                IF LEN( aIncome[ nCount ] ) > 5 .AND. ! EMPTY( aIncome[ nCount ][ 6 ]:acc )
                    oCalcsAcc:dacc := aIncome[ nCount ][ 6 ]
                ENDIF
                oCalcsAcc:FillAnalitHash()
                IF aIncome[ nCount ][ 2 ] <> 0 .AND. CalcMayBeModified( PYMNT->CODE,;         // 1 Вид оплаты
                         50,;                  // 2 Режим
                         aIncome[ nCount ][ 3 ],;                  // 3 Должность сотрудника
                         WAGES->JOBSCODE,;              // 4
                         NIL, ;             // 5
                         NIL, ;              // 6 (не используется)
                         NIL, ;                 // 7 (не используется)
                         oCalcsAcc:wacc, ;                  // 8 Счет
                         NIL, ;            // 9 Проверять ли включенность в ведомость (не используется)
                         NIL, ;                   // 10 ФКР
                         NIL, ;                // 11 Вид деятельности
                         NIL, ;                // 12
                         NIL, ;                // 13
                         NIL ;         // 14 проверять существующие начисления
                        )
                    AddCalcsRec( PYMNT->CODE, 50 )
                    CALCS->SUMMA := aIncome[ nCount ][ 2 ]
                    CALCS->POST  := aIncome[ nCount ][ 3 ]
                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                ENDIF
            ENDIF
        NEXT
    ENDIF

    RETURN


*------------------------------------------------------*
*   Перенос сумм из тарификации предыдущего месяца

    STATIC FUNCTION SBT_PM_Tarif( dMonth, lIgnoreMessage )
*------------------------------------------------------*
    LOCAL dEndTarif
    LOCAL lTarExist
    LOCAL aCount
    LOCAL nTarifSum := 0
    LOCAL bEndTarif := {|| NIL  }
    LOCAL lFound := .F.
    LOCAL oCalcsAcc
    LOCAL nRes

    DEFAULT lIgnoreMessage IS .F.

    // извлечение надбавок из тарификации
    // ищем тарификацию человека на текущий месяц
    SELECT TARIF
    DB_SETORDER( "TABEL" )
    SET SCOPE TO JOBS_->RECCODE + JOBS_->CODE
    GO_BOTTOM()
    // Ищем первую тарификацию, актуальную в данном месяце
    DO WHILE ! BOF() .AND. ( FIELD->TARIFDATE > BOM( dMonth ) )
        SKIP -1
    ENDDO

    IF !lIgnoreMessage
        bEndTarif := {|x| IF( !EMPTY( x := FIELD->END_DATE ) .AND. dEndTarif > x,;
                               MALERT( "По сотруднику;" + SayFIO() +;
                                       ";необходимо произвести перетарификацию;не позднее " +;
                                       XTOC( x + 1 )),;
                               NIL ) }
    ENDIF

    lTarExist := ( FIELD->JOBSCODE == JOBS_->RECCODE )

    IF lTarExist
        // установили указатель на первую необходимую тарификацию
        DO WHILE .NOT. EOF() .AND. ( TARIF->JOBSCODE == JOBS_->RECCODE ) .AND. ( TARIF->TARIFDATE <= EOM( dMonth ) )

            // Определение даты конца действия тарификации
            SaveSet()
            SKIP
            IF FIELD->JOBSCODE == JOBS_->RECCODE
                // Дата на 1 день раньше, чем дата следующей тарификации
                dEndTarif := TARIF->TARIFDATE - 1
            ELSE
                // Последнее число текущего месяца
                dEndTarif := EOM( dMonth )
            ENDIF
            RestSet()

            EVAL( bEndTarif )

            // берем строки тарификации
            SELECT TRREC
            DB_SETORDER( "TARIFCODE" )
            SET SCOPE TO JOBS_->CODE + TARIF->TARIFCODE
            GO TOP
            DO WHILE ! EOF()

                // берем расшифровку строк тарификации
                SELECT TRLIN
                DB_SETORDER( "RECCODE" )

                SET SCOPE TO JOBS_->CODE + TRREC->RECCODE
                GO TOP
                DO WHILE ! EOF()

                    // обработка только те виды начислений, которые рассчитываются по предыдущему месяцу
                    IF ( FIELD->GROUP = 10 .OR. FIELD->GROUP = 27 ) .AND. FIELD->TOWAGE == 2
                        nRes := CheckMethod(TRLIN->PAYTYPE, TRLIN->PARAM)
                        IF !EMPTY(nRes)
                            // Расчет суммы за отработанное время
                            aCount := CountWageSum(;
                                            JOBS_->CODE,;      // Код сотрудника
                                            JOBS_->RECCODE,;   // Код зап. JOBS_
                                            TRLIN->SUMMA,;     // Сумма
                                            TRLIN->TARIFDATE,; // Дата начала тарификации
                                            dEndTarif,;        // Дата конца тарификации
                                            TRREC->POSTCODE,;  // Код должности
                                            TRREC->SUBJ,;      // Предмет
                                            TRREC->TYPE,;      // Тип
                                            0,;    // Способ отражения в зарплате
                                            dMonth )           // предыдущий месяц
                        ENDIF

                        // Если сумма не равна нулю
                        IF !EMPTY(aCount) .AND. !EMPTY( aCount[ 1 ] )

                            oCalcsAcc := GetPymntAccObject( TRLIN->PAYTYPE, TRREC->POSTCODE )
              *------------------------------------------------------*
              *   Возвращает .T., если можно добавить или изменить начисление с заданными параметрами
                            IF CalcMayBeModified( TRLIN->PAYTYPE,;         // 1 Вид оплаты
                                       10,;                  // 2 Режим
                                       TRREC->POSTCODE,;                  // 3 Должность сотрудника
                                       WAGES->JOBSCODE,;              // 4
                                       TRLIN->CALCRCODE,;             // 5
                                       NIL,;              // 6 (не используется)
                                       NIL,;                 // 7 (не используется)
                                       oCalcsAcc:wacc,;                  // 8 Счет
                                       NIL,;            // 9 Проверять ли включенность в ведомость (не используется)
                                       NIL,;                   // 10 ФКР
                                       NIL, ;                // 11 Вид деятельности
                                       NIL, ;                // 12
                                       NIL, ;                // 13
                                       NIL ;         // 14 проверять существующие начисления
                                      )
              *------------------------------------------------------*
                                nTarifSum += aCount[ 1 ]
                                SayStatus( SayFio(.T.) + ";" + REMALL( TRLIN->COMMENT ) )
                                // Мягкое добавление записи
                                CALCS->( SOFT_APPEND() )
                                CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                CALCS->CODE     := JOBS_->CODE     // Табельный
                                CALCS->POST     := TRREC->POSTCODE // Должность
                                CALCS->CALCRCODE:= TRLIN->CALCRCODE// код записи основания
                                CALCS->PRIORITY := TRLIN->PRIORITY // приоритет вычисл
                                CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                                CALCS->GROUP    := TRLIN->GROUP    // группа
                                CALCS->MODE     := 10              // Признак тарификации
                                CALCS->SUMMA    := ROUND( aCount[ 1 ], 2 )
                                CALCS->LDAY     := aCount[ 2 ]
                                CALCS->TOTAL    := aCount[ 3 ]
                                CALCS->WORK     := aCount[ 4 ]
                                CALCS->COMMENT  := TRLIN->COMMENT  // Примечание
                                CALCS->PAYTYPE  := TRLIN->PAYTYPE  // Вид оплаты
                                CALCS->PARAM    := TRLIN->PARAM    // Параметры расчета
                                CALCS->SUMTYPE  := TRLIN->SUMTYPE  // Параметры расчета
                                CALCS->COUNTSUM := TRLIN->COUNTSUM // Параметры расчета
                                CALCS->TARIFDATE:= TARIF->TARIFDATE // Дата тарификации
                            ENDIF
                        ENDIF
                    ENDIF

                    SKIP
                ENDDO

                SELECT TRREC
                SKIP

            ENDDO

            SELECT TARIF
            SKIP

        ENDDO
    ELSE
        ALERT( "Сотрудник " + SayFio() + " не обнаружен в тарификации",,"Некорректная ситуация" )

    ENDIF

    RETURN( nTarifSum )

//------------------------------------------------------*
//   Взятие сумм из тарификации
//   lUseTabel  - с учетом отработанного времени
    FUNCTION GetTarifSum( dDate, cPost, lType, lUseTabel  )
//------------------------------------------------------*
    LOCAL dEndTarif
    LOCAL lTarExist
    LOCAL aCount
    LOCAL lFound := .F.
    LOCAL aReturn, nPay
    LOCAL nSum := 0

    DEFAULT lUseTabel IS .T.

    SaveSet()

    // ищем тарификацию человека на текущий месяц
    DBSELECTAREA("TARIF")
    DB_SETORDER( "TABEL" )
    ORDSCOPE(0, JOBS_->RECCODE + JOBS_->CODE)
    ORDSCOPE(1, JOBS_->RECCODE + JOBS_->CODE)
    GO_BOTTOM()

    // Ищем первую тарификацию, актуальную в данном месяце
    WHILE ! BOF() .AND. ( FIELD->TARIFDATE > BOM( dDate ) )
        D_SKIP( -1 )
    ENDDO

    lTarExist := ( FIELD->JOBSCODE == JOBS_->RECCODE )
    aReturn   := {}

    IF lTarExist
        // установили указатель на первую необходимую тарификацию
        WHILE !EOF() .AND. ( TARIF->JOBSCODE == JOBS_->RECCODE ) .AND. ( TARIF->TARIFDATE <= EOM( dDate ) )

            // Определение даты конца действия тарификации
            SaveSet()
            D_SKIP()
            IF !EOF() .AND. FIELD->JOBSCODE == JOBS_->RECCODE
                // Дата на 1 день раньше, чем дата следующей тарификации
                dEndTarif := TARIF->TARIFDATE - 1
            ELSE
                // Последнее число текущего месяца
                dEndTarif := EOM( dDate )
            ENDIF
            RestSet()

            // берем строки тарификации
            DBSELECTAREA("TRREC")
            DB_SETORDER( "TARIFCODE" )
            ORDSCOPE(0, JOBS_->CODE + TARIF->TARIFCODE )
            ORDSCOPE(1, JOBS_->CODE + TARIF->TARIFCODE )
            DBGOTOP()

            WHILE ! EOF()

                // берем расшифровку строк тарификации
                DBSELECTAREA("TRLIN")
                DB_SETORDER( "RECCODE" )
                ORDSCOPE(0, JOBS_->CODE + TRREC->RECCODE )
                ORDSCOPE(1, JOBS_->CODE + TRREC->RECCODE )
                DBGOTOP()

                WHILE ! EOF()
                    // Отследить начисления в тарификации,
                    //  для которых есть основания
                    //  и стоит дата окончания действия в текущем месяце
                    // Если есть основание проверим его актуальность
                    IF ! EMPTY( FIELD->CALCRCODE )
                        // Проверим запись на наличие в таблице оснований
                        CALCR->( DB_SETORDER( "RECCODE" ) )
                        CALCR->( ORDSCOPE( 0, "" ) )
                        CALCR->( ORDSCOPE( 1, "" ) )
                        IF CALCR->( DBSEEK( TRLIN->CALCRCODE ) )
                            // Если дата окончания <= первого числа текущего месяца
                            IF ! EMPTY( CALCR->FDATE ) .AND. CALCR->FDATE <= EOM( MEMVAR->DATE )
                                ALERT( "В тарификации присутствует начисление " + TRLIN->COMMENT +;
                                    ";которое имеет основание начисления,;"+;
                                        "но действие данного основания заканчивается " + DTOC( CALCR->FDATE ) +;
                                            ";Возможно, необходимо провести перетарификацию сотрудника",,"Предупреждение" )
                            ENDIF
                        ENDIF
                    ENDIF

                    // Исключим коэффициенты и суммы, которые не надо учитывать в з/п
                    IF ( FIELD->GROUP = 10 .OR. FIELD->GROUP = 27 ) .AND. ( FIELD->TOWAGE <> 2 .AND. FIELD->TOWAGE <> 3 )

                        IF lUseTabel
                           // вид ЗП - по табелю или в виде суммы
                           // Расчет суммы за отработанное время
                           aCount := CountWageSum(;
                                           JOBS_->CODE,;      // Код сотрудника
                                           JOBS_->RECCODE,;   // Код зап. JOBS_
                                           TRLIN->SUMMA,;     // Сумма
                                           TRLIN->TARIFDATE,; // Дата начала тарификации
                                           dEndTarif,;        // Дата конца тарификации
                                           TRREC->POSTCODE,;  // Код должности
                                           TRREC->SUBJ,;      // Предмет
                                           TRREC->TYPE,;      // Тип
                                           FIELD->TOWAGE,;    // Способ отражения в зарплате
                                           dDate )            // дата
                            IF ! EMPTY( aCount[ 1 ] )
                                nSum := aCount[ 1 ]
                            ENDIF
                        ELSE
                            nSum := TRLIN->SUMMA
                        ENDIF
                        // Если сумма не равна нулю
                        IF ! EMPTY( nSum ) .AND. ( EMPTY(cPost) .OR. TRREC->POSTCODE == cPost )

                             IF lType
                                 // если надо расшифровать по видам оплат
                                 nPay := ASCAN( aReturn, {|x| ALLTRIM( x[1] ) == ALLTRIM( TRLIN->PAYTYPE ) .AND. x[4] == TRREC->POSTCODE } )
                             ELSE
                                 // без расшифровки по видам оплат
                                 nPay := ASCAN( aReturn, {|x| x[4] == TRREC->POSTCODE } )
                             ENDIF

                             IF EMPTY( nPay )
                                 //                      1                2           3            4               5            6             7               8
                                 AADD( aReturn, { TRLIN->PAYTYPE, TRLIN->PAYTYPE, { 0, 0 }, TRREC->POSTCODE, TRLIN->GROUP, TRLIN->PARAM, TRLIN->SUMTYPE, TARIF->TARIFDATE} )
                                 nPay := LEN( aReturn )
                             ENDIF

                            aReturn[ nPay ][ 3 ][ 1 ] += ROUND( nSum, 2 )
                        ENDIF

                    ENDIF

                    D_SKIP()
                ENDDO

                DBSELECTAREA("TRREC")
                D_SKIP()

            ENDDO

            DBSELECTAREA("TARIF")
            D_SKIP()
        ENDDO
    ENDIF

    RestSet()

    RETURN aReturn

*------------------------------------------------------*
*   проверка стажа, квалификации и разряда сотрудника, наличие выплаты за качество в основаниях
*   aPayTypes    - массив в/о с методами NS_EXP и NS_QUAL ( Arr[PAYTYPE][ALLTRIM(METOD)] )
*   lLogAllWages - бежим по всем сотрудникам (oLog,caption:"MSG")
    PROCEDURE CheckNSTarifInWage( aPayTypes, lLogAllWages )
*-----------------------------------------------------*
    MEMVAR oLog, opWagesLog
    LOCAL aExistPayTypes := {}
    LOCAL cPaytype  := ""
    LOCAL nI, nIndex
    LOCAL aPost, nIndustry, nPKG, nQualLevel, nCateg, nMinRaz, nMaxRaz
    LOCAL cStr  := ""
    LOCAL nPerc := 0
    LOCAL nExp, lNeedCritPymnt
    LOCAL oPersonCrit   := PersonCrit():new()
    LOCAL aCritPayTypes := EXTRACT({},"ARR",SprPath+"pymnt.dbf", "CODE", "FIELD->METOD=='W_NSPREM'")

    PRIVATE aLog := {}

    DEFAULT lLogAllWages IS .F.

    SaveSet()
    BEGIN SEQUENCE

        SayStatus( SayFio(.T.) + ";Проверка тарификации" )

        // проверка на наличие выплаты за качество в основаниях
        IF !EMPTY(nPerc := oPersonCrit:GetBonusSum(JOBS_->RECCODE, JOBS_->CODE, TRREC->POSTCODE, ;
                             BOM(MEMVAR->DATE), MEMVAR->ENT, "PERCR") )  // денюшки должны быть
            lNeedCritPymnt := .T.
            DBSELECTAREA("CALCR")
            DB_SETORDER("ENTCODE")
            ORDSCOPE(0,MEMVAR->ENT+TARIF->CODE)
            ORDSCOPE(1,MEMVAR->ENT+TARIF->CODE)
            GO TOP
            DO WHILE !EOF()
                IF !EMPTY(FIELD->SDATE) .AND. FIELD->SDATE<=TARIF->TARIFDATE .AND. ;
                           (EMPTY(FIELD->FDATE) .OR. FIELD->FDATE>TARIF->TARIFDATE)
                    IF EMPTY(aCritPayTypes) .OR. !EMPTY(ASCAN(aCritPayTypes,FIELD->PAYTYPE))
                        lNeedCritPymnt := .F.
                    ENDIF
                ENDIF
                SKIP
            ENDDO
            IF lNeedCritPymnt
                cStr := " у сотрудника "+SayFIO(.F.)+IF(TRREC->(OrdKeyCount())>1,", по должности "+ SayPost(TRREC->POSTCODE),"")
                AADD(aLog, {"ERR","В основаниях не найдена выплата за качество " + cStr + ", сумма: " + ALLTRIM(STR(nPerc,15,2))})
            ENDIF
        ENDIF

        DBSELECTAREA("TRLIN")
        DB_SETORDER("RCCODE")
        ORDSCOPE(0, TRREC->RECCODE)
        ORDSCOPE(1, TRREC->RECCODE)
        GO TOP

        DO WHILE !EOF()
            IF (nIndex := ASCAN( aPayTypes, {|x| x[ 1 ] == FIELD->PAYTYPE } ))>0
                AADD(aExistPayTypes,{FIELD->PAYTYPE,aPayTypes[nIndex][2],RECNO()})
            ENDIF
            SKIP
        ENDDO

        DBSELECTAREA("TRLIN")
        DB_SETORDER("RCPTYPE")
        GO TOP

        aPost := EXTRACT({}, "VAL", MEMVAR->SprPath + "posts.dbf", {"INDUSTRY", "PKG", "QLEV", "MINRAZ", "MAXRAZ"}, ;
                      {"CODE", TRREC->POSTCODE, TRREC->POSTCODE})

        nIndustry   := 0
        nPKG        := 0
        nQualLevel  := 0
        nMinRaz     := 0
        nMaxRaz     := 0

        IF !EMPTY(aPost)
            nIndustry   := aPost[1]
            nPKG        := aPost[2]
            nQualLevel  := aPost[3]
            nMinRaz     := aPost[4]
            nMaxRaz     := aPost[5]
        ENDIF
        cStr := " у сотрудника "+SayFIO(.F.)+IF(TRREC->(OrdKeyCount())>1,", по должности "+ SayPost(TRREC->POSTCODE),"")
        IF !TRREC->CONTR
            CheckGrade(aLog, nIndustry, nMinRaz, nMaxRaz, nPKG, nQualLevel,cStr)
        ENDIF

        FOR nI := 1 TO LEN(aExistPayTypes)
            cPaytype := aExistPayTypes[nI][1]
            IF aExistPayTypes[nI][2]=="NS_EXP"
                CheckExp(aLog, cPaytype, nIndustry, nPKG, nQualLevel,aExistPayTypes[nI][3],cStr)
            ELSEIF aExistPayTypes[nI][2]=="NS_QUAL"
                CheckQual(aLog, cPaytype, nIndustry, nPKG, nQualLevel,aExistPayTypes[nI][3],cStr)
            ELSEIF aExistPayTypes[nI][2]=="TKTAT"   //проверка лимита Компенсации
                CheckCompLim(aLog, cPaytype,cStr)
            ENDIF
        NEXT

        //проверка отсутствия в/о надбавки за стаж и квал-ю.
        IF ASCAN(aExistPayTypes, {|x| UR(x[2]) == "NS_EXP"}) == 0
            nExp  := GetExpNS( TARIF->CODE, TARIF->TARIFDATE, TRREC->POSTCODE )
            nPerc := GetExpCoef( nIndustry, nPKG, nQualLevel, nExp, WCNFG->CODE)
            IF nPerc > 0
                AADD(aLog, {"ERR","Не найдена надбавка за стаж" + cStr})
            ENDIF
        ENDIF

        IF ASCAN(aExistPayTypes, {|x| UR(x[2]) == "NS_QUAL"}) == 0
            nCateg := GetCategoryNS( TARIF->CODE, TARIF->TARIFDATE, TRREC->POSTCODE )
            nPerc  := GetQualCoef( nIndustry, nPKG, nQualLevel, nCateg, WCNFG->CODE)
            IF nPerc > 0
                AADD(aLog, {"ERR","Не найдена надбавка за квалификацию " + cStr})
            ENDIF
        ENDIF

        FOR nI := 1 TO LEN(aLog)
            IF lLogAllWages
                oLog:AddMessage( 'msg', aLog[nI][2] )
            ELSE
                opWagesLog:AddMessage( 'msg', aLog[nI][2] )
            ENDIF
        NEXT

    END SEQUENCE
    RestSet()

    RETURN


*------------------------------------------------------*
*   проверка компенсации РТ
    PROCEDURE CheckCompens( aPayTypes, lLogAllWages )
*-----------------------------------------------------*
    MEMVAR oLog, opWagesLog
    LOCAL nI, nIndex
    LOCAL aExistPayTypes := {}
    LOCAL cPaytype       := ""
    LOCAL cStr           := " у сотрудника "+SayFIO(.F.)+IF(TRREC->(OrdKeyCount())>1,", по должности "+;
                                                                            SayPost(TRREC->POSTCODE),"")
    LOCAL cAlias         := ALIAS()
    LOCAL aTRLINScope    := TRLIN->(SaveScope())

    PRIVATE aLog := {}

    DEFAULT lLogAllWages IS .F.

    TRLIN->(SaveSet())
    BEGIN SEQUENCE

        SayStatus( SayFio(.T.) + ";Проверка компенсации РТ" )

        SELECT TRLIN
        DB_SETORDER("RCCODE")
        ORDSCOPE(0, TRREC->RECCODE)
        ORDSCOPE(1, TRREC->RECCODE)
        GO TOP

        DO WHILE !EOF()
            IF (nIndex := ASCAN( aPayTypes, FIELD->PAYTYPE ))>0
                AADD(aExistPayTypes,{FIELD->PAYTYPE,aPayTypes[nIndex][2],RECNO()})
            ENDIF
            SKIP
        ENDDO

        FOR nI := 1 TO LEN(aExistPayTypes)
            cPaytype := aExistPayTypes[nI][1]
            IF aExistPayTypes[nI][2]=="TKTAT"   //проверка лимита Компенсации
                CheckCompLim(aLog, cPaytype,cStr)
            ENDIF
        NEXT

        FOR nI := 1 TO LEN(aLog)
            IF lLogAllWages
                oLog:AddMessage( 'msg', aLog[nI][2] )
            ELSE
                opWagesLog:AddMessage( 'msg', aLog[nI][2] )
            ENDIF
        NEXT

    END SEQUENCE

    TRLIN->(RestSet())
    TRLIN->(RestScope(aTRLINScope))
    SELECT (cALias)

    RETURN


*------------------------------------------------------*
*   Перенос сумм из тарификации

    STATIC FUNCTION SBT_Tarif( aUserDolg, lLogAllWages )
*------------------------------------------------------*

    LOCAL dEndTarif
    LOCAL lTarExist
    LOCAL aCount
    LOCAL nTarifSum
    LOCAL bEndTarif := {|| NIL  }
    LOCAL lFound := .F.
    LOCAL xTemp
    LOCAL oCalcsAcc
    LOCAL nRes
    LOCAL aPayTypes := EXTRACT({},"ARR",SprPath+"pymnt.dbf",{"CODE","ALLTRIM(METOD)"},"ALLTRIM(FIELD->METOD)$'NS_EXP;NS_QUAL;TKTAT'") // для ОСОТ: в/о с методами NS_QUAL и NS_EXP для проверки стажа, квалификации и разряда

    DEFAULT lLogAllWages IS .F.

    nTarifSum := SBT_PM_Tarif( ADDMONTH( MEMVAR->DATE, -1 ), .T. )

    // ищем тарификацию человека на текущий месяц
    SELECT TARIF
    DB_SETORDER( "TABEL" )
    SET SCOPE TO JOBS_->RECCODE + JOBS_->CODE
    GO_BOTTOM()
    // Ищем первую тарификацию, актуальную в данном месяце
    DO WHILE ! BOF() .AND. ( FIELD->TARIFDATE > BOM( MEMVAR->DATE ) )
        SKIP -1
    ENDDO

    IF FIELDNUM("END_DATE") != 0
        bEndTarif := {|x| IF( !EMPTY( x := FIELD->END_DATE ) .AND. dEndTarif > x,;
                               MALERT( "По сотруднику;" + SayFIO() +;
                                       ";необходимо произвести перетарификацию;не позднее " +;
                                       XTOC( x + 1 )),;
                               NIL ) }
    ENDIF

    lTarExist := ( FIELD->JOBSCODE == JOBS_->RECCODE )

    IF lTarExist
        // установили указатель на первую необходимую тарификацию
        DO WHILE .NOT. EOF() .AND. ( TARIF->JOBSCODE == JOBS_->RECCODE ) .AND. ( TARIF->TARIFDATE <= EOM( MEMVAR->DATE ) )

            // Определение даты конца действия тарификации
            SaveSet()
            SKIP
            IF !EOF() .AND. FIELD->JOBSCODE == JOBS_->RECCODE
                // Дата на 1 день раньше, чем дата следующей тарификации
                dEndTarif := TARIF->TARIFDATE - 1
            ELSE
                // Последнее число текущего месяца
                dEndTarif := EOM( MEMVAR->DATE )
            ENDIF
            RestSet()

            EVAL( bEndTarif )

            // берем строки тарификации
            SELECT TRREC
            DB_SETORDER( "TARIFCODE" )
            SET SCOPE TO JOBS_->CODE + TARIF->TARIFCODE
            GO TOP

            DO WHILE ! EOF()

                IF TRREC->ISREPL // если это замещение
                    SKIP
                    LOOP
                ENDIF

                IF IsOtrSys( TARIF->TARIFDATE )
                    //ОСОТ: проверка стажа, квалификации и разряда сотрудника, наличие выплаты за качество в основаниях
                    CheckNSTarifInWage( aPayTypes, lLogAllWages/*бежим по всем сотрудникам (oLog,caption:"MSG")*/ )
                ENDIF
                // проверка на лимит компенсации РТ
                CheckCompens( aPayTypes, lLogAllWages )

                // берем расшифровку строк тарификации
                SELECT TRLIN
                DB_SETORDER( "RECCODE" )

                SET SCOPE TO JOBS_->CODE + TRREC->RECCODE
                GO TOP
                DO WHILE ! EOF()
                    // Отследить начисления в тарификации,
                    //  для которых есть основания
                    //  и стоит дата окончания действия в текущем месяце
                    // Если есть основание проверим его актуальность
                    IF ! EMPTY( FIELD->CALCRCODE )
                        // Проверим запись на наличие в таблице оснований
                        CALCR->( DB_SETORDER( "RECCODE" ) )
                        CALCR->( ORDSCOPE( 0, "" ) )
                        CALCR->( ORDSCOPE( 1, "" ) )
                        IF CALCR->( DBSEEK( TRLIN->CALCRCODE ) )
                            // Если дата окончания <= первого числа текущего месяца
                            IF ! EMPTY( CALCR->FDATE ) .AND. ( ;
                                    ( EMPTY( JOBS_->FDATE ) .AND. CALCR->FDATE <= EOM( MEMVAR->DATE ) ) .OR. ;
                                    (!EMPTY( JOBS_->FDATE ) .AND. JOBS_->FDATE > CALCR->FDATE ) )
                                ALERT( "В тарификации присутствует начисление " + TRLIN->COMMENT +;
                                    ";которое имеет основание начисления,;"+;
                                        "но действие данного основания заканчивается " + DTOC( CALCR->FDATE ) +;
                                            ";Возможно, необходимо провести перетарификацию сотрудника",,"Предупреждение" )
                            ENDIF
                        ENDIF
                    ENDIF

                    // Исключим коэффициенты и суммы, которые не надо учитывать в з/п
                    IF ( FIELD->GROUP = 10 .OR. FIELD->GROUP = 27 ) .AND. ( FIELD->TOWAGE <> 2 .AND. FIELD->TOWAGE <> 3 )

                        CheckMethod(TRLIN->PAYTYPE, TRLIN->PARAM)
                        // вид ЗП - по табелю или в виде суммы
                        // Расчет суммы за отработанное время
                        aCount := CountWageSum(;
                                        JOBS_->CODE,;      // Код сотрудника
                                        JOBS_->RECCODE,;   // Код зап. JOBS_
                                        TRLIN->SUMMA,;     // Сумма
                                        TRLIN->TARIFDATE,; // Дата начала тарификации
                                        dEndTarif,;        // Дата конца тарификации
                                        TRREC->POSTCODE,;  // Код должности
                                        TRREC->SUBJ,;      // Предмет
                                        TRREC->TYPE,;      // Тип
                                        FIELD->TOWAGE,;    // Способ отражения в зарплате
                                        NIL, ;
                                        TRREC->RECCODE )
                        // Если сумма не равна нулю
                        IF !EMPTY(aCount) .AND. !EMPTY( aCount[ 1 ] )

                            oCalcsAcc := GetPymntAccObject( TRLIN->PAYTYPE, TRREC->POSTCODE )

                            //проверяем, нет ли в среди начислений аналогичных записей
                            IF CalcMayBeModified( TRLIN->PAYTYPE, 10, TRREC->POSTCODE, WAGES->JOBSCODE,;
                                     TRLIN->CALCRCODE,, TRLIN->PARAM, oCalcsAcc:wacc )
                                nTarifSum += aCount[ 1 ]
                                SayStatus( SayFio(.T.) + ";" + REMALL( TRLIN->COMMENT ) )
                                // Мягкое добавление записи
                                CALCS->( SOFT_APPEND() )
                                CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                CALCS->CODE     := JOBS_->CODE     // Табельный
                                CALCS->POST     := TRREC->POSTCODE // Должность
                                CALCS->CALCRCODE:= TRLIN->CALCRCODE// код записи основания
                                CALCS->PRIORITY := TRLIN->PRIORITY // приоритет вычисл
                                CALCS->GROUP    := TRLIN->GROUP    // группа
                                CALCS->MODE     := 10              // Признак тарификации
                                CALCS->SUMMA    := ROUND( aCount[ 1 ], 2 )
                                CALCS->LDAY     := aCount[ 2 ]
                                CALCS->TOTAL    := aCount[ 3 ]
                                CALCS->WORK     := aCount[ 4 ]
                                CALCS->COMMENT  := TRLIN->COMMENT  // Примечание
                                CALCS->PAYTYPE  := TRLIN->PAYTYPE  // Вид оплаты
                                CALCS->PARAM    := TRLIN->PARAM    // Параметры расчета
                                CALCS->SUMTYPE  := TRLIN->SUMTYPE  // Параметры расчета
                                CALCS->COUNTSUM := TRLIN->COUNTSUM // Параметры расчета
                                CALCS->TARIFDATE:= TARIF->TARIFDATE // Дата тарификации
                                CALCS->( CalcsObjectToTable( oCalcsAcc ) )

                                xTemp := ASCAN( aUserDolg, {|x| x:mode == CALCS->MODE .AND. x:paytype == CALCS->PAYTYPE .AND. x:post == CALCS->POST } )
                                IF !EMPTY( xTemp )
                                    CALCS->SUMMADP := aUserDolg[ xTemp ]:summadp
                                ENDIF

                            ENDIF
                        ENDIF

                    ENDIF

                    SKIP
                ENDDO

                SELECT TRREC
                SKIP

            ENDDO

            SELECT TARIF
            SKIP

        ENDDO
    ELSE
        ALERT( "Сотрудник " + SayFio() + " не обнаружен в тарификации",,"Некорректная ситуация" )

    ENDIF

    RETURN( nTarifSum )


*------------------------------------------------------*
*   Добавление записи в CALCS

    PROCEDURE AddCalcsRec( cPayType, nMode )
*------------------------------------------------------*
    LOCAL aInfo

    CALCS->( SOFT_APPEND() )
    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
    CALCS->MONTH    := MEMVAR->DATE    // Месяц
    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
    CALCS->CODE     := WAGES->CODE     // Табельный
    CALCS->MODE     := nMode           // Режим
    CALCS->PAYTYPE  := cPayType        // Вид оплаты
    CALCS->POST     := WAGES->MAINPOST // Должность

    aInfo := GetPrimaryFkr()
    CALCS->DFKR     := aInfo[1]
    CALCS->REFBU    := aInfo[2]

    aInfo := Extract( {}, "VAL", "PYMNT", { "NAME", "PRIORITY", "GROUP" },;
        { "CODE", cPayType } )

    CALCS->COMMENT  := aInfo[ 1 ] // Примечание
    CALCS->PRIORITY := aInfo[ 2 ] // приоритет вычисл
    CALCS->GROUP    := aInfo[ 3 ] // группа

    RETURN

*------------------------------------------------------*
*   Перенос сумм из Больничных

    STATIC PROCEDURE SBT_Hospital( nType, lMustEmpl )
    // nType - NIL или 0 - обычные обльничные
    // nType - 1 - необычные больничые (УСН, ЕНВД)
*------------------------------------------------------*
    LOCAL aDayStav
    LOCAL nIndex, nI
    LOCAL nIllSum, nIllSumByJobs
    LOCAL cCode
    LOCAL xVar
    LOCAL nStrDay
    LOCAL nFinDay
    LOCAL nIllSumKor := 0
    LOCAL cPlusFullSeekValue
    LOCAL lIsEmpl
    LOCAL lFound
    LOCAL cParam
    LOCAL aTemp
    LOCAL cJobsCode
    LOCAL oCalcAcc
    LOCAL aFkr
    LOCAL lAddCalc, aFlag, cFilter
    LOCAL cErrorMsg, aPost, cJobtbName
    LOCAL lMayBeRecalced
    LOCAL nCalcsSum

    BEGIN SEQUENCE

    IF SELECT( "HDYST" ) > 0 .AND. ! AliasToName( "HDYST" ) == ALLTRIM( File_Name( "HDYST",,, MEMVAR->YEAR ) )
        DBCLOSE( "HDYST" )
    ENDIF

    IF MODINIT( { "DEHSS", "HSSHT" } ) .AND. MODINIT( { "HDYST" }, MEMVAR->YEAR )
        SELECT HSSHT
        DB_SETORDER( "CODE" )
        SET SCOPE TO /*MEMVAR->ENT + */JOBS_->CODE + DTOS( BOM( MEMVAR->DATE ) )
        GO TOP
        // По основному файлу больничных
        DO WHILE ! EOF()
            IF ( EMPTY( nType ) .AND. ! EMPTY( HSSHT->VERSION ) ) .OR. ;
                ( ! EMPTY( nType ) .AND. EMPTY( HSSHT->VERSION ) )
                d_skip()
                LOOP
            ENDIF
            // Если это именно то сотрудник
            lMayBeRecalced := .F.
            SELECT DEHSS
            DB_SETORDER( "HSCODE" )
            SET SCOPE TO HSSHT->RECCODE
            GO TOP
            // По файлу расшифровки больничных
            DO WHILE ! EOF()
// За счет средств работодателя, или ФСС?
                lIsEmpl := DEHSS->ISEMPL .OR. ( ! EMPTY( nType ) .AND. lMustEmpl )
                cCode   := HSSHT->TYPE

                IF lIsEmpl
                    IF PYMNT->( DBSEEK( HSSHT->TYPE ) )
                        cCode := Extract( {},"ARR","PYMNT","CODE",{ "GROUP", "16", "16","LEFT(FIELD->PARAM,6)=='"+LEFT(HSSHT->TYPE,6)+"'" })
                        IF EMPTY(cCode)
                            ALERT("Вид оплаты '"+HSSHT->TYPE+ "' не привязан в справочнике видов оплат;"+;
                                  "к виду оплаты 'Больничные за счет средств работодателя'.;"+;
                                  "Продолжение переноса пособия в з/плату невозможно.;"+;
                                  "Проверьте информацию о привязке и попробуйте снова.")
                            SKIP
                            LOOP
                        ELSEIF LEN(cCode) > 1
                            ALERT("К виду оплаты '"+HSSHT->TYPE+ "' привязано в справочнике видов оплат;"+;
                                  "более одного вида оплаты 'Больничные за счет средств работодателя'.;"+;
                                  "Продолжение переноса пособия в з/плату невозможно.;"+;
                                  "Проверьте информацию о привязке и попробуйте снова.")
                            SKIP
                            LOOP
                        ELSE
                            cCode := cCode[1]
                        ENDIF
                    ENDIF
                ENDIF

                IF PYMNT->( DBSEEK( cCode ) )
                    SayStatus( SayFio(.T.) + ";" + REMALL( PYMNT->NAME ) )
                    // Если не пуста сумма больничных
                    IF ! EMPTY( DEHSS->ILLSUM ) .AND. ;
                            ( EMPTY( nType ) .OR. ( lMustEmpl .AND. ! EMPTY( DEHSS->ILLEMPLSUM ) ) .OR. ;
                                                  ( ! lMustEmpl .AND. ! EMPTY( DEHSS->ILLSUMFSS ) ) )

                        //проверка на необходимость перерасчета
                        IF DEHSS->DATE < BOM( MEMVAR->Date )

                            IF DEHSS->DATE = BOM( HSSHT->SDATE )
                                nStrDay := DAY( HSSHT->SDATE )
                            ELSE
                                nStrDay := 1
                            ENDIF
                            IF DEHSS->DATE = BOM( HSSHT->FDATE )
                                nFinDay := DAY( HSSHT->FDATE )
                            ELSE
                                nFinDay := DAY( EOM( HSSHT->FDATE ) )
                            ENDIF
                            xVar := {}
                            DO WHILE nStrDay <= nFinDay
                                AADD( xVar, "DAY"+STRZERO( nStrDay, 2 ) )
                                nStrDay++
                            ENDDO

                            xVar := Extract( {}, "VAL", File_Name("JOBTB",MEMVAR->ENT,,YEAR(DEHSS->DATE)), xVar, {"ANYPOST",DTOS(DEHSS->DATE)+WAGES->CODE+WAGES->JOBSCODE} )
                            nFinDay := WAGES->NOTE
                            nStrDay := 1
                            DO WHILE nStrDay <= LEN( xVar )
                                IF VAL( UR( xVar[ nStrDay ] ) ) > 0
                                    IF AT( "Треб.перерасч.", nFinDay ) <> 0
                                        EXIT
                                    ELSE
                                        WAGES->NOTE := LEFT("Треб.перерасч.;"+REMALL( nFinDay), LEN( nFinDay ) )
                                        EXIT
                                    ENDIF
                                ENDIF
                                nStrDay++
                            ENDDO
                        ENDIF

                        // Если дневная ставка не введена вручную
                        IF ! DEHSS->BYHAND .AND. ! EMPTY( DEHSS->SELECT )
                            // Просматриваем расшифровку дневной ставки
                            SELECT HDYST

                            DB_SETORDER( "DEHSCODE" )
                            SET SCOPE TO DEHSS->HDYSTCODE

                            GO TOP
                            // Собираем массив счетов и суммы начислений
                            aTemp := {}
                            DO WHILE ! EOF()
                                // расчет больничных только в тех типах физических лиц для которых он начислен
                                IF !EMPTY( HDYST->DAYSUM )

                                    PYMNT->( SaveSet() )//пимант
                                    IF !PYMNT->( DBSEEK( HDYST->PYMNT ) )
                                        ALERT("Вид оплаты с кодом '"+HDYST->PYMNT+"' присутствует в;"+;
                                              "расшифровке среднедневной ставки но не найден в справочнике;"+;
                                              "видов оплат. Продолжение переноса пособия в з/плату;"+;
                                              "невозможно. Восстановите информацию о виде оплаты в;"+;
                                              "справочнике и попробуйте снова",{"Прервать"},"Пособие по временной нетрудоспособности",,,,,"!")
                                        PYMNT->( RestSet() )//пимант
                                        BREAK
                                    ELSE
                                        oCalcAcc := CalcsAccs():new()
                                        IF ! oCalcAcc:LoadFromCalcs( "HDYST", HDYST->PYMNT )
                                            PYMNT->( RestSet() )//пимант
                                            BREAK
                                        ENDIF
                                        IF ! lIsEmpl

                                            // начисление обычного больничного
                                            IF EMPTY( oCalcAcc:dacc:fkr ) .OR. EMPTY( LEFT( oCalcAcc:dacc:acc, 1 ) )
                                                xVar := GetPrimaryFkr( HSSHT->TYPE, HDYST->ENTER, HDYST->POST, HDYST->TYPE )
                                                oCalcAcc:dacc:fkr := IF( EMPTY( HDYST->DFKR ), xVar[1], HDYST->DFKR )
                                                IF EMPTY( LEFT( oCalcAcc:dacc:acc, 1 ) )
                                                    oCalcAcc:dacc:acc := IF( EMPTY( HDYST->REFBU ), xVar[2], HDYST->REFBU )
                                                ENDIF
                                            ENDIF

                                            // не за счет ср-в работодателя
                                            IF ! oCalcAcc:LoadFromPymnt( HSSHT->TYPE, HDYST->ENTER, HDYST->POST, HDYST->TYPE, @cErrorMsg, oCalcAcc:dacc )
                                                Message( "S" + cErrorMsg )
                                                PYMNT->( RestSet() )
                                                BREAK
                                            ENDIF
                                        ELSE

                                            IF HDYST->MONTH < CTOD( "01/01/2011" )
                                                xVar := GetPrimaryFkr( HDYST->PYMNT, HDYST->ENTER, HDYST->POST, HDYST->TYPE )
                                                oCalcAcc:dacc:fkr := IF( EMPTY( HDYST->DFKR ), xVar[1], HDYST->DFKR )
                                                IF EMPTY( LEFT( oCalcAcc:dacc:acc, 1 ) )
                                                    oCalcAcc:dacc:acc := IF( EMPTY( HDYST->REFBU ), xVar[2], HDYST->REFBU )
                                                ENDIF
                                                IF ! oCalcAcc:LoadFromPymnt( HDYST->PYMNT, HDYST->ENTER, HDYST->POST, HDYST->TYPE, @cErrorMsg, oCalcAcc:dacc )
                                                    Message( "S" + cErrorMsg )
                                                    PYMNT->( RestSet() )
                                                    BREAK
                                                ENDIF

                                            ELSE
                                                // начисление за счет работодателя
                                                IF EMPTY( oCalcAcc:dacc:acc ) .AND. EMPTY( oCalcAcc:kacc:acc )
                                                // Сконвертированная больничная - грузим из пимента
                                                // за счет ср-в работодателя
                                                    xVar := GetPrimaryFkr( HDYST->PYMNT, HDYST->ENTER, HDYST->POST, HDYST->TYPE )
                                                    oCalcAcc:dacc:fkr := IF( EMPTY( HDYST->DFKR ), xVar[1], HDYST->DFKR )
                                                    IF EMPTY( LEFT( oCalcAcc:dacc:acc, 1 ) )
                                                        oCalcAcc:dacc:acc := IF( EMPTY( HDYST->REFBU ), xVar[2], HDYST->REFBU )
                                                    ENDIF
                                                    IF ! oCalcAcc:LoadFromPymnt( HDYST->PYMNT, HDYST->ENTER, HDYST->POST, HDYST->TYPE, @cErrorMsg, oCalcAcc:dacc )
                                                        Message( "S" + cErrorMsg )
                                                        PYMNT->( RestSet() )
                                                        BREAK
                                                    ENDIF
                                                ENDIF
                                                IF EMPTY( oCalcAcc:dacc:fkr ) .OR. EMPTY( LEFT( oCalcAcc:dacc:acc, 1 ) )
                                                    xVar := GetPrimaryFkr( HSSHT->TYPE, HDYST->ENTER, HDYST->POST, HDYST->TYPE )
                                                    oCalcAcc:dacc:fkr := IF( EMPTY( HDYST->DFKR ), xVar[1], HDYST->DFKR )
                                                    oCalcAcc:kacc:fkr := IF( EMPTY( HDYST->DFKR ), xVar[1], HDYST->DFKR )
                                                    IF EMPTY( LEFT( oCalcAcc:dacc:acc, 1 ) )
                                                        oCalcAcc:dacc:acc := IF( EMPTY( HDYST->REFBU ), xVar[2], HDYST->REFBU ) + SUBSTR( oCalcAcc:dacc:acc, 2 )
                                                        oCalcAcc:kacc:acc := IF( EMPTY( HDYST->REFBU ), xVar[2], HDYST->REFBU ) + SUBSTR( oCalcAcc:kacc:acc, 2 )
                                                    ENDIF
                                                ENDIF
                                            ENDIF
                                        ENDIF
                                        cPlusFullSeekvalue := oCalcAcc:cPlusFullSeekValue
                                    ENDIF
                                    PYMNT->( RestSet() )

                                    cFilter := "(EMPTY(FIELD->FDATE) .OR. DTOS(FIELD->FDATE) >= '" + DTOS(HSSHT->FDATE) + ;
                                        "') .AND. DTOS(FIELD->SDATE) <= '" + DTOS(HSSHT->SDATE) + "'"
                                    aFlag := EXTRACT( {}, "ARR", "JOBS_", { "CODE","RECCODE", "FDATE"}, ;
                                        {"KEY", HSSHT->CODE + HDYST->ENTER, HSSHT->CODE + HDYST->ENTER, ;
                                        cFilter})

                                    cJobsCode := IF( !EMPTY(HDYST->JOBSCODE), HDYST->JOBSCODE, HSSHT->JOBSCODE  )
                                    IF ASCAN(aFlag, {|x| x[2] == cJobsCode}) == 0
                                        cJobsCode := HSSHT->JOBSCODE
                                    ENDIF

                                    IF EMPTY( nIndex := ASCAN( aTemp, {|x| x[ 1 ] == cJobsCode } ) )
                                        AADD( aTemp, { cJobsCode, {}, 0 } )
                                        nIndex := LEN(aTemp)
                                    ENDIF

                                    // Если в массиве информации о дневной ставке есть данные по такому счету и должности
                                    // Если за счет средств работодателя - все рабиваем по счетам и должностям
                                        IF ( nI := ASCAN( aTemp[nIndex][2], {|x| x[ 1 ] == cPlusFullSeekValue } ) ) > 0
                                            aTemp[nIndex][2][ nI ][ 3 ] += HDYST->DAYSUM
                                        ELSE
                                            AADD( aTemp[nIndex][2], { cPlusFullSeekValue, WAGES->MAINPOST, HDYST->DAYSUM, oCalcAcc } )
                                        ENDIF
                                    // подсчитаем сумму больничного для случая больничный считается из всех типов физ.лиц
                                    aTemp[nIndex][3] += HDYST->DAYSUM

                                ENDIF
                                SKIP
                            ENDDO

                            aDayStav := {}
                            xVar := 0
                            nIllSumByJobs := 0
                            IF LEN(aTemp) > 0

                                ASORT( aTemp,,,{|x,y| x[1] <= y[1] } )

                                IF ( nIndex := ASCAN( aTemp, {|x| x[ 1 ] == WAGES->JOBSCODE } ) ) > 0
                                    aDayStav := ACLONE( aTemp[nIndex][2] )
                                    xVar := aTemp[nIndex][3]
                                ENDIF

                                IF EMPTY( nType )
                                    nIllSum := DEHSS->ILLSUM
                                ELSE
                                    IF lMustEmpl
                                        nIllSum := DEHSS->ILLEMPLSUM
                                    ELSE
                                        nIllSum := DEHSS->ILLSUMFSS
                                    ENDIF
                                ENDIF

                                IF YEAR( HSSHT->SDATE ) < 2011 .OR. ALLTRIM( HSSHT->PERIOD ) == "0000"
                                    nCalcsSum := DEHSS->CALCSUM
                                ELSE
                                    nCalcsSum := DEHSS->YEAR01 + DEHSS->YEAR02
                                ENDIF

                                IF nIndex == LEN(aTemp)
                                    nIllSumByJobs := 0
                                    FOR nI := 1 TO LEN(aTemp)-1
                                        nIllSumByJobs += IF(EMPTY(DEHSS->ILLSUMMAX) .OR. DEHSS->ILLSUMMA < DEHSS->ILLSUMMAX,; /* Если пусто ограничение больничного, или сумма больничного меньше максимальной суммы */
                                                         ROUND( ROUND( ROUND(D( aTemp[nI][3], DEHSS->CALCDAYS),4) * IF(DEHSS->LDAY,DEHSS->ILLHOURS,DEHSS->ILL), 2 ) * DEHSS->PERCENT / 100, 2 ),;
                                                         D( aTemp[nI][3], nCalcsSum ) * nIllSum )
                                    NEXT
                                    nIllSumByJobs := nIllSum - nIllSumByJobs
                                ELSE
                                    nIllSumByJobs := IF(EMPTY(DEHSS->ILLSUMMAX) .OR. DEHSS->ILLSUMMA < DEHSS->ILLSUMMAX,;
                                                         ROUND( ROUND( ROUND(D( xVar, DEHSS->CALCDAYS),4) * IF(DEHSS->LDAY,DEHSS->ILLHOURS,DEHSS->ILL), 2 ) * DEHSS->PERCENT / 100, 2 ),;
                                                         D( xVar, nCalcsSum ) * nIllSum )
                                ENDIF

                            ENDIF

                            IF !lIsEmpl
                                // Если это больничный за счет ФСС, не разбиваем по счетам и должностям, все ставим на главное
                            ENDIF

                            nIllSumKor := 0

                            IF LEN( aDayStav ) > 0
                                lMayBeRecalced := .T.
                            ENDIF

                            FOR nIndex := 1 TO LEN( aDayStav )
// Вычисляем сумму для данной должности и счета
                                IF nIndex < LEN( aDayStav )
                                    nIllSum    := ROUND( D( aDayStav[ nIndex ][ 3 ], xVar ) * nIllSumByJobs, 2 )
                                    nIllSumKor += nIllSum
                                ELSE
                                    nIllSum := nIllSumByJobs - nIllSumKor
                                ENDIF

                                IF nIllSum <> 0
                                    IF !DEHSS->LDAY
                                        cParam    := "/////////" + ALLTRIM( STR(DEHSS->ILL,5,0) ) + "д, " + ;
                                                            ZR( XTOC( DEHSS->PERCENT ) ) + "%, " + ;
                                                            STRZERO( MONTH( DEHSS->DATE ), 2 ) + "." + ;
                                                            RIGHT( STRZERO( YEAR( DEHSS->DATE ), 4 ), 2 ) + ;
                                                            " ("+ STRZERO( DAY( HSSHT->SDATE ), 2 ) + "." + ;
                                                                 STRZERO( MONTH( HSSHT->SDATE ), 2 ) + "." + ;
                                                            RIGHT( STRZERO( YEAR( HSSHT->SDATE ), 4 ), 2 ) + ;
                                                             ")" // Примечание
                                    ELSE

                                        cParam    := "/////////" + ALLTRIM( STR(DEHSS->ILLHOURS,5,0) ) + "ч, " + ;
                                                            ZR( XTOC( DEHSS->PERCENT ) ) + "%, " + ;
                                                            STRZERO( MONTH( DEHSS->DATE ), 2 ) + "." + ;
                                                            RIGHT( STRZERO( YEAR( DEHSS->DATE ), 4 ), 2 ) + ;
                                                            " ("+ STRZERO( DAY( HSSHT->SDATE ), 2 ) + "." + ;
                                                                 STRZERO( MONTH( HSSHT->SDATE ), 2 ) + "." + ;
                                                            RIGHT( STRZERO( YEAR( HSSHT->SDATE ), 4 ), 2 ) + ;
                                                             ")" // Примечание
                                    ENDIF

                                    IF CalcMayBeModified( PYMNT->CODE, 30, aDayStav[ nIndex ][ 2 ], WAGES->JOBSCODE,;
                                                         ,, cParam,aDayStav[ nIndex ][ 4 ]:wacc,.F.,,,, )
                                        CALCS->( SOFT_APPEND() )
                                        CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                        CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                        CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                        CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                        CALCS->CODE     := JOBS_->CODE     // Табельный
                                        CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                                        CALCS->GROUP    := PYMNT->GROUP    // группа
                                        CALCS->( CalcsObjectToTable( aDayStav[ nIndex ][ 4 ] ) )
                                        CALCS->MODE     := 30              // Режим
                                        CALCS->COMMENT  := PYMNT->NAME     // Описание
                                        CALCS->PAYTYPE  := PYMNT->CODE  // Вид оплаты
                                        CALCS->PARAM    := cParam
                                        // В виде конкретной суммы
                                        CALCS->SUMTYPE  := "08##"+XTOC(nIllSum)+"###"
                                        CALCS->COUNTSUM := ROUND( nIllSum, 2 )
                                        CALCS->SUMMA    := ROUND( nIllSum, 2 )
                                        CALCS->POST     := aDayStav[ nIndex ][ 2 ]
                                        CALCS->CALCRCODE:= DEHSS->RECCODE
                                    ENDIF
                                ENDIF
                            NEXT
                            // Если массив больничных содержит в себе только один счет
//                            IF LEN( aDayStav ) = 1

                        // Дневная ставка введена вручную
                        // и мы игнорируем расшифровку дневной ставки

                        // если ставка вручную, то начисляем только по штaтным сотрудникам
                        ELSEIF WAGES->JOBSCODE == HSSHT->JOBSCODE
                            // Сумма больничных берется без вычисления
                            IF EMPTY( nType )
                                nIllSum := DEHSS->ILLSUM
                            ELSE
                                IF lMustEmpl
                                    nIllSum := DEHSS->ILLEMPLSUM
                                ELSE
                                    nIllSum := DEHSS->ILLSUMFSS
                                ENDIF
                            ENDIF

                            lMayBeRecalced := .T.
                            // Если сумма больничных больше нуля
                            IF nIllSum <> 0
                                oCalcAcc := CalcsAccs():new()
                                IF ! oCalcAcc:LoadFromPymnt( PYMNT->CODE, MEMVAR->ENT, WAGES->MAINPOST, WAGES->TYPE, @cErrorMsg )
                                    Message( "S" + cErrorMsg )
                                    BREAK
                                ENDIF
                                IF CalcMayBeModified( PYMNT->CODE, 30, WAGES->MAINPOST,;
                                        WAGES->JOBSCODE,,,, oCalcAcc:wacc,, )
                                    CALCS->( SOFT_APPEND() )
                                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                    CALCS->CODE     := JOBS_->CODE     // Табельный
                                    CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                                    CALCS->GROUP    := PYMNT->GROUP    // группа
                                    CALCS->( CalcsObjectToTable( oCalcAcc ) )
                                    CALCS->MODE     := 30              // Режим
                                    CALCS->COMMENT  := PYMNT->NAME     // Описание
                                    IF !DEHSS->LDAY
                                        CALCS->PARAM    := "/////////" + XTOC(DEHSS->ILL) + "дн.по " +;
                                                            ZR( XTOC( DEHSS->PERCENT ) ) + "% за " +;
                                                            SayDate( DEHSS->DATE, "MMM YYYY" ) // Примечание
                                    ELSE
                                        CALCS->PARAM    := "/////////" + XTOC(DEHSS->ILL) + "ч.по " +;
                                                            ZR( XTOC( DEHSS->PERCENT ) ) + "% за " +;
                                                            SayDate( DEHSS->DATE, "MMM YYYY" ) // Примечание
                                    ENDIF
                                    CALCS->PAYTYPE  := PYMNT->CODE  // Вид оплаты

                                    // В виде конкретной суммы
                                    CALCS->SUMTYPE  := "08##"+XTOC(nIllSum)+"###"
                                    CALCS->COUNTSUM := nIllSum
                                    CALCS->SUMMA    := ROUND( nIllSum, 2 )
                                    CALCS->POST     := WAGES->MAINPOST
                                    CALCS->CALCRCODE:= DEHSS->RECCODE
                                ENDIF
                            ENDIF

                        ENDIF
                        SELECT DEHSS
                    ENDIF
                ELSE
                    ALERT( "В реестре больничных по сотруднику;"+SayFio()+";"+;
                           "присутствует вид пособия по врем.нетрудосп.'"+cCode+"';"+;
                           "который не найден в справочнике видов оплат. Продолжение;"+;
                           "переноса пособия в з/плату невозможно. Восстановите"+;
                           "информацию о виде выплаты и попробуйте снова",{"Прервать"},"Внимание",,,,,"!" )
                ENDIF
                SKIP
            ENDDO
            IF BOM(MEMVAR->DATE) > BOM(HSSHT->SDATE) .AND. (JOBS_->TYPE == 10) .AND. lMayBeRecalced
                SBT_Pereraschet(JOBS_->CODE, WAGES->JOBSCODE, HSSHT->SDATE, HSSHT->FDATE)
            ENDIF
            SELECT HSSHT
            SKIP
        ENDDO
    ENDIF

    END SEQUENCE

    SELECT HSSHT

    RETURN

*------------------------------------------------------*
*   Перенос сумм из Пособий

    STATIC PROCEDURE SBT_Benifit()
*------------------------------------------------------*
    LOCAL aDayStav
    LOCAL nIndex, nI
    LOCAL nIllSum, nIllSumByJobs
    LOCAL cCode
    LOCAL xVar
    LOCAL nStrDay
    LOCAL nFinDay
    LOCAL nIllSumKor := 0
    LOCAL nAcc
    LOCAL lFound
    LOCAL cParam
    LOCAL aTemp
    LOCAL cJobsCode
    LOCAL aFkr
    LOCAL nPaySum
    LOCAL oCalcsAcc
    LOCAL cPlusFullSeekValue
    LOCAL cErrorMsg
    LOCAL nCalcsSum

    BEGIN SEQUENCE

    IF MODINIT( { "BNFIT" } )
        SELECT BNFIT
        DB_SETORDER( "CODE" )
        SET SCOPE TO JOBS_->CODE
        GO TOP
        // По основному файлу пособий
        DO WHILE ! EOF()
            IF SELECT( "HDYST" ) > 0 .AND. ! AliasToName( "HDYST" ) == ALLTRIM( File_Name( "HDYST",,, YEAR( BNFIT->SDATE ) ) )
                DBCLOSE( "HDYST" )
            ENDIF
            IF ! EMPTY( BNFIT->WDATE ) .AND. BOM( BNFIT->WDATE ) > BOM( MEMVAR->DATE )
                SKIP
                LOOP
            ENDIF
            IF MODINIT( { "HDYST" }, YEAR( BNFIT->SDATE ) )
            // Если это именно то сотрудник
                cCode   := BNFIT->TYPE
                IF PYMNT->( DBSEEK( cCode ) )
                    SayStatus( SayFio(.T.) + ";" + REMALL( PYMNT->NAME ) )

                    nPaySum := GetBenifitPaySum( MEMVAR->DATE )
                    // Если не пуста сумма пособий
                    IF ! EMPTY( nPaySum )
                        // Если дневная ставка не введена вручную
                        IF ! BNFIT->BYHAND .AND. ! EMPTY( BNFIT->DAYST )
                            // Просматриваем расшифровку дневной ставки
                            SELECT HDYST

                            DB_SETORDER( "DEHSCODE" )
                            SET SCOPE TO BNFIT->HDYSTCODE

                            GO TOP
                            // Собираем массив счетов и суммы начислений

                            aTemp := {}
                            DO WHILE ! EOF()
                                // расчет пособий только в тех типах физических лиц для которых он начислен
                                IF !EMPTY( HDYST->DAYSUM )

                                    PYMNT->( SaveSet() )
                                    IF !PYMNT->( DBSEEK( HDYST->PYMNT ) )
                                        ALERT("Вид оплаты с кодом '"+HDYST->PYMNT+"' присутствует в;"+;
                                              "расшифровке среднедневной ставки но не найден в справочнике;"+;
                                              "видов оплат. Продолжение переноса пособия в з/плату;"+;
                                              "невозможно. Восстановите информацию о виде оплаты в;"+;
                                              "справочнике и попробуйте снова",{"Прервать"},"Пособие по уходу за ребенком",,,,,"!")
                                        PYMNT->( RestSet() )
                                        BREAK
                                    ELSE
                                        oCalcsAcc := CalcsAccs():new()
                                        IF ! oCalcsAcc:LoadFromPymnt( BNFIT->TYPE, HDYST->ENTER, WAGES->MAINPOST, HDYST->TYPE, @cErrorMsg )
                                            Message( "S" + cErrorMsg )
                                            PYMNT->( RestSet() )
                                            BREAK
                                        ENDIF
                                        cPlusFullSeekValue := oCalcsAcc:cPlusFullSeekValue
                                    ENDIF
                                    PYMNT->( RestSet() )

                                    cJobsCode := IF(!EMPTY(HDYST->JOBSCODE),HDYST->JOBSCODE,BNFIT->JOBSCODE)

                                    IF EMPTY( nIndex := ASCAN( aTemp, {|x| x[ 1 ] == cJobsCode } ) )
                                        AADD( aTemp, { cJobsCode, {}, 0 } )
                                        nIndex := LEN(aTemp)
                                    ENDIF

                                    // Если в массиве информации о дневной ставке есть данные по такому счету и должности
                                    // Если за счет средств работодателя - все рабиваем по счетам и должностям
                                        IF ( nI := ASCAN( aTemp[nIndex][2], {|x| x[ 1 ] == cPlusFullSeekValue } ) ) > 0
                                            aTemp[nIndex][2][ nI ][ 3 ] += HDYST->DAYSUM
                                        ELSE
                                            AADD( aTemp[nIndex][2], { cPlusFullSeekValue, WAGES->MAINPOST, HDYST->DAYSUM, oCalcsAcc } )
                                        ENDIF
                                    // подсчитаем сумму больничного для случая больничный считается из всех типов физ.лиц
                                    aTemp[nIndex][3] += HDYST->DAYSUM

                                ENDIF
                                SKIP
                            ENDDO

                            aDayStav := {}
                            xVar := 0
                            nIllSumByJobs := 0

                            IF LEN(aTemp) > 0

                                ASORT( aTemp,,,{|x,y| x[1] <= y[1] } )

                                IF ( nIndex := ASCAN( aTemp, {|x| x[ 1 ] == WAGES->JOBSCODE } ) ) > 0
                                    aDayStav := ACLONE( aTemp[nIndex][2] )
                                    xVar := aTemp[nIndex][3]
                                ENDIF

                                IF YEAR( BNFIT->SDATE ) > 2010
                                    nCalcsSum := BNFIT->YEAR01 + BNFIT->YEAR02
                                ELSE
                                    nCalcsSum := BNFIT->CALCSUM
                                ENDIF

                                IF nIndex == LEN(aTemp)
                                    nIllSumByJobs := 0
                                    FOR nI := 1 TO LEN(aTemp)-1
                                        nIllSumByJobs += D( aTemp[nI][3], nCalcsSum ) * nPaySum
                                    NEXT
                                    nIllSumByJobs := nPaySum - nIllSumByJobs
                                ELSE
                                    nIllSumByJobs := D( xVar, nCalcsSum ) * nPaySum
                                ENDIF

                            ENDIF

                            nIllSumKor := 0

                            FOR nIndex := 1 TO LEN( aDayStav )
// Вычисляем сумму для данной должности и счета
                                IF nIndex < LEN( aDayStav )
                                    nIllSum    := ROUND( D( aDayStav[ nIndex ][ 3 ], xVar ) * nIllSumByJobs, 2 )
                                    nIllSumKor += nIllSum
                                ELSE
                                    nIllSum := nIllSumByJobs - nIllSumKor
                                ENDIF

                                IF nIllSum <> 0
                                    cParam    := "/////////" + ;
                                                        STRZERO( MONTH( MEMVAR->DATE ), 2 ) + "." + ;
                                                        RIGHT( STRZERO( YEAR( MEMVAR->DATE ), 4 ), 2 ) + ;
                                                        " ("+ STRZERO( DAY( BNFIT->SDATE ), 2 ) + "." + ;
                                                             STRZERO( MONTH( BNFIT->SDATE ), 2 ) + "." + ;
                                                        RIGHT( STRZERO( YEAR( BNFIT->SDATE ), 4 ), 2 ) + "-" + ;
                                                        STRZERO( DAY( BNFIT->FDATE ), 2 ) + "." + ;
                                                             STRZERO( MONTH( BNFIT->FDATE ), 2 ) + "." + ;
                                                        RIGHT( STRZERO( YEAR( BNFIT->FDATE ), 4 ), 2 ) + ;
                                                         ")" // Примечание
                                    IF CalcMayBeModified( PYMNT->CODE, 30, aDayStav[ nIndex ][ 2 ], WAGES->JOBSCODE,;
                                             ,, cParam,aDayStav[ nIndex ][ 4 ]:wacc,,,, )

                                        CALCS->( SOFT_APPEND() )
                                        CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                        CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                        CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                        CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                        CALCS->CODE     := JOBS_->CODE     // Табельный
                                        CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                                        CALCS->GROUP    := PYMNT->GROUP    // группа
                                        CALCS->MODE     := 30              // Режим
                                        CALCS->COMMENT  := PYMNT->NAME     // Описание
                                        CALCS->PAYTYPE  := PYMNT->CODE  // Вид оплаты
                                        CALCS->PARAM    := cParam
                                        // В виде конкретной суммы
                                        CALCS->SUMTYPE  := "08##"+XTOC(nIllSum)+"###"
                                        CALCS->COUNTSUM := ROUND( nIllSum, 2 )
                                        CALCS->SUMMA    := ROUND( nIllSum, 2 )
                                        CALCS->POST     := aDayStav[ nIndex ][ 2 ]
                                        CALCS->CALCRCODE:= BNFIT->RECCODE
                                        CALCS->( CalcsObjectToTable( aDayStav[ nIndex ][ 4 ] ) )
                                    ENDIF
                                ENDIF

                            NEXT
                        // Дневная ставка введена вручную
                        // и мы игнорируем расшифровку дневной ставки

                        // если ставка вручную, то начисляем только по штaтным сотрудникам
                        ELSEIF WAGES->JOBSCODE == BNFIT->JOBSCODE
                            // Сумма больничных берется без вычисления

                            // Если сумма больничных больше нуля
                            IF nPaySum <> 0
                                oCalcsAcc := CalcsAccs():new()
                                IF ! oCalcsAcc:LoadFromPymnt( PYMNT->CODE, MEMVAR->ENT, WAGES->MAINPOST, WAGES->TYPE, @cErrorMsg )
                                    Message( "S" + cErrorMsg )
                                    BREAK
                                ENDIF
                                IF CalcMayBeModified ( PYMNT->CODE, 30, WAGES->MAINPOST,;
                                        WAGES->JOBSCODE,,,,oCalcsAcc:wacc,, )
                                    CALCS->( SOFT_APPEND() )
                                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                    CALCS->CODE     := JOBS_->CODE     // Табельный
                                    CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                                    CALCS->GROUP    := PYMNT->GROUP    // группа
                                    CALCS->MODE     := 30              // Режим
                                    CALCS->COMMENT  := PYMNT->NAME     // Описание
                                    CALCS->PAYTYPE  := PYMNT->CODE  // Вид оплаты

                                    cParam    := "/////////" + ;
                                                        STRZERO( MONTH( MEMVAR->DATE ), 2 ) + "." + ;
                                                        RIGHT( STRZERO( YEAR( MEMVAR->DATE ), 4 ), 2 ) + ;
                                                        " ("+ STRZERO( DAY( BNFIT->SDATE ), 2 ) + "." + ;
                                                             STRZERO( MONTH( BNFIT->SDATE ), 2 ) + "." + ;
                                                        RIGHT( STRZERO( YEAR( BNFIT->SDATE ), 4 ), 2 ) + "-" + ;
                                                        STRZERO( DAY( BNFIT->FDATE ), 2 ) + "." + ;
                                                             STRZERO( MONTH( BNFIT->FDATE ), 2 ) + "." + ;
                                                        RIGHT( STRZERO( YEAR( BNFIT->FDATE ), 4 ), 2 ) + ;
                                                         ")" // Примечание
                                    CALCS->PARAM    := cParam
                                    // В виде конкретной суммы
                                    CALCS->SUMTYPE  := "08##"+XTOC(nPaySum)+"###"
                                    CALCS->COUNTSUM := nPaySum
                                    CALCS->SUMMA    := ROUND( nPaySum, 2 )
                                    CALCS->POST     := WAGES->MAINPOST
                                    CALCS->CALCRCODE:= BNFIT->RECCODE
                                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                                ENDIF
                            ENDIF

                        ENDIF
                    ENDIF
                ELSE
                    ALERT( "В реестре пособий до 1,5 лет по сотруднику;"+SayFio()+";"+;
                           "присутствует вид пособия по уходу за ребенком'"+cCode+"';"+;
                           "который не найден в справочнике видов оплат. Продолжение;"+;
                           "переноса пособия в з/плату невозможно. Восстановите;"+;
                           "информацию о виде выплаты и попробуйте снова", {"Прервать"}, "Внимание",,,,,"!" )
                ENDIF
            ENDIF
            SELECT BNFIT
            SKIP
        ENDDO
    ENDIF

    END SEQUENCE

    RETURN

*------------------------------------------------------*
*   Перенос сумм из Отпускных

    STATIC PROCEDURE SBT_Vocation()
*------------------------------------------------------*
    LOCAL aDayStav
    LOCAL nIndex
    LOCAL nVacSum
    LOCAL nMode := MEMVAR->aCfgFio[14]
    LOCAL aTmpSum
    LOCAL aMonth
    LOCAL nVacSumKor
    LOCAL cPlusFullSeekValue
    LOCAL nCount
    LOCAL aTemp      := {}
    LOCAL aMonthTemp
    LOCAL nHoliDays
    LOCAL nI, xVar
    LOCAL aDays      := {}
    LOCAL cParam
    LOCAL cJobsCode
    LOCAL aFkr
    LOCAL cFilter
    LOCAL oCalcAcc
    LOCAL cErrorMsg
    LOCAL cPost

    MEMVAR Date

    BEGIN SEQUENCE

    IF nMode
        nMode := 1
    ELSE
        nMode := 0
    ENDIF

    IF MODINIT( { "VACTN" } ) .AND. MODINIT( { "DEVAC" }, MEMVAR->YEAR )

        SELECT VACTN
        cFilter := SaveFilter()
        DB_SETORDER( "CODE" )
        SET SCOPE TO JOBS_->CODE
        SETFILTER( "LEFT(DTOS(FIELD->MONTH),6) =='" + LEFT( DTOS( MEMVAR->DATE ), 6 ) + "'" )
        GO TOP
        // По основному файлу отпускных
        DO WHILE ! EOF()
            // Если это именно тот сотрудник
                IF PYMNT->( DBSEEK( VACTN->TYPE ) )
                    // Если не пуста сумма отпускных
                    IF ! EMPTY( VACTN->VACSUM )

                        IF EMPTY( VACTN->SDATE ) .OR. EMPTY( VACTN->DAYS )
                            ALERT( "Неправильно задана дата начала отпуска;или его продолжительность;"+;
                                   "Отпускные не будут перенесены;в расчет заработной платы!" )
                            BREAK
                        ENDIF
                        // Если сумма не введена вручную
                        IF ! VACTN->BYHAND
                            // Просматриваем расшифровку дневной ставки
                            SELECT DEVAC
                            DB_SETORDER( "VACCODE" )
                            SET SCOPE TO VACTN->RECCODE
                            GO TOP

                            // Собираем массив счетов и суммы начислений
                            aTemp := {}
                            DO WHILE ! EOF()
                                IF !EMPTY( DEVAC->DAYSUM )

                                    PYMNT->( SaveSet() )
                                    IF !PYMNT->( DBSEEK( DEVAC->PYMNT ) )
                                        ALERT("Вид оплаты с кодом '"+DEVAC->PYMNT+"' присутствует в;"+;
                                              "расшифровке среднедневной ставки но не найден в справочнике;"+;
                                              "видов оплат. Продолжение переноса отпуска в з/плату;"+;
                                              "невозможно. Восстановите информацию о виде оплаты в;"+;
                                              "справочнике и попробуйте снова",{"Прервать"},"Отпускные",,,,,"I")
                                        PYMNT->( RestSet() )
                                        BREAK
                                    ELSE
                                        oCalcAcc := CalcsAccs():new()
                                        IF ! oCalcAcc:LoadFromCalcs( "DEVAC", DEVAC->PYMNT )
                                            BREAK
                                        ENDIF
                                        IF GetMethodProperty( VACTN->TYPE, "SUPRESS_CR", .F. )
                                            // учитываем, нужно ли жестко подменять проводки из ВО
                                            IF ! oCalcAcc:LoadFromPymnt( VACTN->TYPE, DEVAC->ENTER, IF( EMPTY(VACTN->POST), WAGES->MAINPOST, VACTN->POST ), DEVAC->TYPE, @cErrorMsg, oCalcAcc:dacc )
                                                Message( "S" + cErrorMsg )
                                                BREAK
                                            ENDIF
                                        ENDIF

                                        IF EMPTY( oCalcAcc:dacc:acc ) .AND. EMPTY( oCalcAcc:kacc:acc )
                                            // пуст и дебет и кредит - запись сконвертирована, грузим корреспонденцию из пимента
                                            xVar := GetPrimaryFkr( DEVAC->PYMNT, DEVAC->ENTER, IF( EMPTY(VACTN->POST), WAGES->MAINPOST, VACTN->POST ), DEVAC->TYPE )
                                            oCalcAcc:dacc:fkr := IF( EMPTY( DEVAC->DFKR ), xVar[1], DEVAC->DFKR )
                                            oCalcAcc:dacc:acc := IF( EMPTY( DEVAC->REFBU ), xVar[2], DEVAC->REFBU )
                                            IF ! oCalcAcc:LoadFromPymnt( DEVAC->PYMNT, DEVAC->ENTER, IF( EMPTY(VACTN->POST), WAGES->MAINPOST, VACTN->POST ), DEVAC->TYPE, @cErrorMsg, oCalcAcc:dacc )
                                                Message( "S" + cErrorMsg )
                                                BREAK
                                            ENDIF
                                        ENDIF
                                        cPlusFullSeekValue := oCalcAcc:cPlusFullSeekValue
                                    ENDIF
                                    PYMNT->( RestSet() )
                                    cJobsCode := IF(!EMPTY(DEVAC->JOBSCODE),DEVAC->JOBSCODE,VACTN->JOBSCODE)

                                    IF EMPTY( nIndex := ASCAN( aTemp, {|x| x[ 1 ] == cJobsCode } ) )
                                        AADD( aTemp, { cJobsCode, {}, 0 } )
                                        nIndex := LEN(aTemp)
                                    ENDIF

                                    // Если в массиве информации о дневной ставке есть данные по такому счету
                                    IF ( nI := ASCAN( aTemp[nIndex][2], {|x| x[ 1 ] == cPlusFullSeekValue } ) ) > 0
                                        aTemp[nIndex][2][ nI ][ 2 ] += DEVAC->DAYSUM
                                    ELSE
                                        AADD( aTemp[nIndex][2], { cPlusFullSeekValue, DEVAC->DAYSUM, oCalcAcc } )
                                    ENDIF

                                    aTemp[nIndex][3] += DEVAC->DAYSUM

                                ENDIF
                                SKIP
                            ENDDO

                            aDayStav := {}
                            xVar := 0
                            IF LEN(aTemp) > 0

                                ASORT( aTemp,,,{|x,y| x[1] <= y[1] } )

                                IF ( nIndex := ASCAN( aTemp, {|x| x[ 1 ] == WAGES->JOBSCODE } ) ) > 0
                                    aDayStav := ACLONE( aTemp[nIndex][2] )
                                    xVar := aTemp[nIndex][3]
                                ENDIF

                                IF nIndex == LEN(aTemp)
                                    nVacSum := 0
                                    FOR nI := 1 TO LEN(aTemp)-1
                                        nVacSum += ROUND(ROUND(D(aTemp[nI][3],VACTN->CALCDAYS),4) * VACTN->DAYS * IF(EMPTY(VACTN->CALCHOURS),1,VACTN->CALCHOURS*MacroRun(Memvar->ModSysPath+'DAYHOURS.MAC')),2)
                                    NEXT
                                    xVar := VACTN->VACSUM - nVacSum
                                ELSE
                                    xVar := ROUND(ROUND(D(xVar,VACTN->CALCDAYS),4) * VACTN->DAYS * IF(EMPTY(VACTN->CALCHOURS),1,VACTN->CALCHOURS*MacroRun(Memvar->ModSysPath+'DAYHOURS.MAC')),2)
                                ENDIF

                            ENDIF

                            // Выясняем реальную сумму отпускных (итого по всем месяцам, счетам и типам физ.лиц)
                            // это необходимо для контроля за суммой, переходящей в з/плату в разрезе счетов и пр.
                            // Бежим по массиву сумм по счетам
                            nVacSumKor := 0
                            FOR nIndex := 1 TO LEN( aDayStav )

                                // Вычислим сумму отпускных по текущему счету
                                nVacSum := ROUND( ( D( aDayStav[ nIndex ][ 2 ], VACTN->CALCDAYS ) ) * VACTN->DAYS, 2 )
                                //корректировка копеек
                                IF nIndex = LEN( aDayStav )
                                    nVacSum := xVar - nVacSumKor
                                ENDIF
                                nVacSumKor += ROUND( nVacSum, 2 )

                                IF !EMPTY( nMode ) .AND. nVacSum <> 0  .AND. EMPTY( VACTN->TYPEACC ) .AND. ! EMPTY( VACTN->FDATE )
                                    //получаем из помесячной разбивки периодичную
                                    aMonth := MonthVac( 1 )
                                    aTmpSum := { { 0, 0, 0, 0 }, { 0, 0, 0, 0 } }
                                    aMonthTemp := { {0,,}, {0,,}, {0,,}, {0,,} }

                                    DO WHILE LEN( aMonth ) > 0

// разбивка на 3 периода (bor)

                                        IF aMonth[1][2] = BOM( VACTN->SDATE ) //1 период
                                            aTmpSum[1][1] += aMonth[1][3]
                                            // запись даты начала и конца и кол-ва дней
                                            aMonthTemp[1][2] := VACTN->SDATE  //дата начала
                                            aMonthTemp[1][3] := IF(BOM(aMonth[1][2])=BOM(VACTN->FDATE),VACTN->FDATE,EOM(aMonth[1][2])) //дата конца на тек.период
                                            nHoliDays := GetVacDays(aMonthTemp[1][2],aMonthTemp[1][3])
                                            aMonthTemp[1][1] := aMonthTemp[1][3] - aMonthTemp[1][2] + 1 - nHoliDays // продолжительность
                                        ELSEIF aMonth[1][2] > BOM( VACTN->SDATE ).AND.aMonth[1][2] < BOM( VACTN->FDATE ) // 2 период
                                            aTmpSum[1][2] += aMonth[1][3]  //после
                                            // запись даты начала и конца и кол-ва дней
                                            aMonthTemp[2][2] := BOM(aMonth[1][2])  //дата начала
                                            aMonthTemp[2][3] := EOM(aMonth[1][2]) //дата конца на тек.период
                                            nHoliDays := GetVacDays(aMonthTemp[2][2],aMonthTemp[2][3])
                                            aMonthTemp[2][1] := aMonthTemp[2][3] - aMonthTemp[2][2] + 1 - nHoliDays  // продолжительность
                                        ELSEIF aMonth[1][2] = BOM( VACTN->FDATE ) // 2 период
                                            aTmpSum[1][3] += aMonth[1][3]  //после
                                            // запись даты начала и конца и кол-ва дней
                                            aMonthTemp[3][2] := BOM(aMonth[1][2])  //дата начала
                                            aMonthTemp[3][3] := IF(BOM(VACTN->FDATE)=BOM(aMonth[1][2]),VACTN->FDATE, EOM(aMonth[1][2]))      //дата конца на тек.период
                                            nHoliDays := GetVacDays(aMonthTemp[3][2],aMonthTemp[3][3])
                                            aMonthTemp[3][1] := aMonthTemp[3][3] - aMonthTemp[3][2] + 1  - nHoliDays // продолжительность
                                        ELSE
                                            aTmpSum[1][4] += aMonth[1][3]
                                            // запись даты начала и конца и кол-ва дней
                                            aMonthTemp[4][2] := IF(BOM(aMonth[1][2])=VACTN->SDATE,VACTN->SDATE,BOM(aMonth[1][2]) )  //дата начала
                                            aMonthTemp[4][3] := IF(BOM(VACTN->FDATE)=BOM(aMonth[1][2]),VACTN->FDATE, EOM(aMonth[1][2]))      //дата конца на тек.период
                                            nHoliDays := GetVacDays(aMonthTemp[4][2],aMonthTemp[1][3])
                                            aMonthTemp[4][1] := aMonthTemp[4][3] - aMonthTemp[4][2] + 1  - nHoliDays // продолжительность
                                        ENDIF

                                        ADEL( aMonth, 1 )
                                        ASIZE( aMonth, LEN( aMonth )-1 )
                                    ENDDO

                                    //делим сумму по счету на периоды
                                    aTmpSum[2][1] := ROUND( nVacSum * ( D( aTmpSum[1][1], ABS(aTmpSum[1][1]+aTmpSum[1][2]+aTmpSum[1][3]+aTmpSum[1][4]) ) ), 2 )
                                    aTmpSum[2][2] := ROUND( nVacSum * ( D( aTmpSum[1][2], ABS(aTmpSum[1][1]+aTmpSum[1][2]+aTmpSum[1][3]+aTmpSum[1][4]) ) ), 2 )
                                    aTmpSum[2][3] := nVacSum - ( aTmpSum[2][1]+aTmpSum[2][2] )

                                ELSEIF nVacSum <> 0
                                    aTmpSum := { ,{nVacSum}}
                                    aMonthTemp := { {0,,}, {0,,}, {0,,}, {0,,} }
                                    aMonthTemp[1][2] := VACTN->SDATE  //дата начала
                                    aMonthTemp[1][3] := VACTN->FDATE  //дата конца на тек.период
                                    aMonthTemp[1][1] := VACTN->DAYS // продолжительность
                                ENDIF

                                nCount := 0
                                aTemp  := EXTRACT( {}, "ARR", MEMVAR->SprPath + "pymnt.dbf","CODE",{"GROUP","25"} )

                                DO WHILE LEN( aTmpSum[2] ) > 0
                                    IF !EMPTY( aTmpSum[2][1] )

                                        nCount++

                                        // проверяем все ли правильно разбито (bor)
                                        IF LEN(aTmpSum[2]) > 1
                                            IF (ASCAN( aTemp, {|x| x==LEFT( VACTN->TYPE, 5 ) + STRZERO(nCount,1) } ) ) = 0
                                                ALERT("В справочнике видов оплат выплата; с кодом '"+LEFT( VACTN->TYPE, 5 ) +;
                                                STRZERO(nCount,1)+"' не существует.; Сделайте разбивку отпускных заново."  )
                                                EXIT
                                            ENDIF
                                        ENDIF

                                        cParam    := /*IF(!EMPTY(aDayStav[ nIndex ][ 1 ]),ZR(XTOC(aDayStav[ nIndex ][ 1 ])),"")+*/"/////////"+;
                                            IF(EMPTY(nMode), XTOC(VACTN->DAYS) + " дн. с " +;
                                            SayDate( VACTN->SDATE, "DD-MMM-YY" ) + " по " + SayDate( VACTN->FDATE, "DD-MMM-YY" )+; // Примечание
                                            "(все)", IF(EMPTY(aMonthTemp[1][2]).OR.EMPTY(aMonthTemp[1][1]),"Сумма коррекции (копейки)",;
                                            XTOC(aMonthTemp[1][1]) + " дн. с" +;
                                            SayDate(aMonthTemp[1][2], "DD-MM-YY") + " по " + SayDate( aMonthTemp[1][3], "DD-MM-YY" )+; // Примечание
                                            "(все)") )

                                        IF EMPTY( VACTN->POST ) //bas: по всем должностям
                                            cPost := WAGES->MAINPOST
                                        ELSE
                                            cPost := VACTN->POST
                                        ENDIF
                                        IF CalcMayBeModified( IF( LEN( aTmpSum[2] ) > 1, LEFT( VACTN->TYPE, 5 ) + STRZERO(nCount,1) , VACTN->TYPE ), ;
                                                     30, cPost, WAGES->JOBSCODE,,, cParam, aDayStav[ nIndex ][ 3 ]:wacc,, ) ;
                                                     .AND. ABS( ROUND( aTmpSum[2][1], 2 ) ) > 0.005
                                            CALCS->( SOFT_APPEND() )
                                            CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                            CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                            CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                            CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                            CALCS->CODE     := JOBS_->CODE     // Табельный
                                            CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                                            CALCS->GROUP    := PYMNT->GROUP    // группа
                                            CALCS->CALCRCODE:= VACTN->RECCODE
                                            CALCS->( CalcsObjectToTable( aDayStav[ nIndex ][ 3 ] ) )
                                            CALCS->MODE     := 30              // Режим
                                            CALCS->COMMENT  := PYMNT->NAME     // Описание

                                            CALCS->PARAM    := cParam

                                            IF LEN( aTmpSum[2] ) > 1
                                                CALCS->PAYTYPE  := LEFT( VACTN->TYPE, 5 ) + STRZERO(nCount,1)
                                            ELSE
                                                CALCS->PAYTYPE  := VACTN->TYPE  // Вид оплаты
                                            ENDIF
                                            // В виде конкретной суммы
                                            CALCS->SUMTYPE  := "08##"+XTOC(aTmpSum[2][1])+"###"
                                            CALCS->COUNTSUM := aTmpSum[2][1]
                                            CALCS->SUMMA    := ROUND( aTmpSum[2][1], 2 )

                                            CALCS->POST := cPost
                                        ENDIF
                                    ENDIF

                                    ADEL( aMonthTemp, 1 )
                                    ASIZE( aMonthTemp, LEN( aMonthTemp )-1 )

                                    ADEL( aTmpSum[2], 1 )
                                    ASIZE( aTmpSum[2], LEN( aTmpSum[2] )-1 )
                                ENDDO

                            NEXT
                        ELSEIF WAGES->JOBSCODE == VACTN->JOBSCODE
                            nVacSum := VACTN->VACSUM

                            IF !EMPTY( nMode ) .AND. nVacSum <> 0 .AND. EMPTY( VACTN->TYPEACC ) .AND. ! EMPTY( VACTN->FDATE )
                                //получаем из помесячной разбивки периодичную
                                aMonth := MonthVac( 1 )
                                aTmpSum := { { 0, 0, 0, 0 }, { 0, 0, 0, 0 } }
                                aMonthTemp := { {0,,}, {0,,}, {0,,}, {0,,} }

                                DO WHILE LEN( aMonth ) > 0
                                    IF aMonth[1][2] = BOM( VACTN->SDATE )//1 период
                                        aTmpSum[1][1] += aMonth[1][3]
                                        // запись даты начала и конца и кол-ва дней
                                        aMonthTemp[1][2] := VACTN->SDATE  //дата начала
                                        aMonthTemp[1][3] := IF(BOM(aMonth[1][2])=BOM(VACTN->FDATE),VACTN->FDATE,EOM(aMonth[1][2])) //дата конца на тек.период
                                        nHoliDays := GetVacDays(aMonthTemp[1][2],aMonthTemp[1][3])
                                        aMonthTemp[1][1] := aMonthTemp[1][3] - aMonthTemp[1][2] + 1 - nHoliDays // продолжительность
                                    ELSEIF aMonth[1][2] > BOM( VACTN->SDATE ).AND.aMonth[1][2] < BOM( VACTN->FDATE ) // 2 период
                                        aTmpSum[1][2] += aMonth[1][3]  //после
                                        // запись даты начала и конца и кол-ва дней
                                        aMonthTemp[2][2] := BOM(aMonth[1][2])  //дата начала
                                        aMonthTemp[2][3] := EOM(aMonth[1][2]) //дата конца на тек.период
                                        nHoliDays := GetVacDays(aMonthTemp[2][2],aMonthTemp[2][3])
                                        aMonthTemp[2][1] := aMonthTemp[2][3] - aMonthTemp[2][2] + 1 - nHoliDays  // продолжительность
                                    ELSEIF aMonth[1][2] = BOM( VACTN->FDATE ) // 2 период
                                        aTmpSum[1][3] += aMonth[1][3]  //после
                                        // запись даты начала и конца и кол-ва дней
                                        aMonthTemp[3][2] := BOM(aMonth[1][2])  //дата начала
                                        aMonthTemp[3][3] := IF(BOM(VACTN->FDATE)=BOM(aMonth[1][2]),VACTN->FDATE, EOM(aMonth[1][2]))      //дата конца на тек.период
                                        nHoliDays := GetVacDays(aMonthTemp[3][2],aMonthTemp[3][3])
                                        aMonthTemp[3][1] := aMonthTemp[3][3] - aMonthTemp[3][2] + 1  - nHoliDays // продолжительность
                                    ELSE
                                        aTmpSum[1][4] += aMonth[1][3]
                                        // запись даты начала и конца и кол-ва дней
                                        aMonthTemp[4][2] := IF(BOM(aMonth[1][2])=VACTN->SDATE,VACTN->SDATE,BOM(aMonth[1][2]) )  //дата начала
                                        aMonthTemp[4][3] := IF(BOM(VACTN->FDATE)=BOM(aMonth[1][2]),VACTN->FDATE, EOM(aMonth[1][2]))      //дата конца на тек.период
                                        nHoliDays := GetVacDays(aMonthTemp[4][2],aMonthTemp[1][3])
                                        aMonthTemp[4][1] := aMonthTemp[4][3] - aMonthTemp[4][2] + 1  - nHoliDays // продолжительность
                                    ENDIF

                                    ADEL( aMonth, 1 )
                                    ASIZE( aMonth, LEN( aMonth )-1 )
                                ENDDO
                            ELSEIF nVacSum <> 0
                                aMonthTemp := { {0,,}, {0,,}, {0,,}, {0,,} }
                                aMonthTemp[1][2] := VACTN->SDATE  //дата начала
                                aMonthTemp[1][3] := VACTN->FDATE  //дата конца на тек.период
                                aMonthTemp[1][1] := VACTN->DAYS // продолжительность
                                aTmpSum := {{nVacSum},{0} }
                            ENDIF

                            nCount := 0

                            DO WHILE LEN( aTmpSum[1] ) > 0

                                IF !EMPTY( aTmpSum[1][1] )

                                    nCount++

                                    cParam    := "/////////" + IF(EMPTY(nMode), XTOC(VACTN->DAYS) + " дн. с " +;
                                                        SayDate( VACTN->SDATE, "DD-MMM-YY" ) + " по " + SayDate( VACTN->FDATE, "DD-MMM-YY" )+; // Примечание
                                                        "(все)",IF(EMPTY(aMonthTemp[1][2]).OR.EMPTY(aMonthTemp[1][1]),"Сумма коррекции (копейки)",;
                                                        XTOC(aMonthTemp[1][1]) + " дн. с " +;
                                                        SayDate(aMonthTemp[1][2], "DD-MM-YY") + " по " + SayDate( aMonthTemp[1][3], "DD-MM-YY" )+; // Примечание
                                                        "(все)") )

                                    oCalcAcc := CalcsAccs():new()
                                    IF ! oCalcAcc:LoadFromPymnt( VACTN->TYPE, MEMVAR->ENT, WAGES->MAINPOST, WAGES->TYPE, @cErrorMsg )
                                        Message( "S" + cErrorMsg )
                                        BREAK
                                    ENDIF

                                    IF CalcMayBeModified( IF(LEN( aTmpSum[2] ) > 1, LEFT( VACTN->TYPE, 5 ) + STRZERO(nCount,1) , ;
                                        VACTN->TYPE ), 30, IF(EMPTY(VACTN->POST), WAGES->MAINPOST,VACTN->POST), ;
                                        WAGES->JOBSCODE,,, cParam, oCalcAcc:wacc,,) .AND. ABS( ROUND( aTmpSum[1][1], 2 ) ) > 0.005
                                        CALCS->( SOFT_APPEND() )
                                        CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                        CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                        CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                        CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                        CALCS->CODE     := JOBS_->CODE     // Табельный
                                        CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                                        CALCS->GROUP    := PYMNT->GROUP    // группа
                                        CALCS->MODE     := 30              // Режим
                                        CALCS->COMMENT  := PYMNT->NAME     // Описание
                                        CALCS->CALCRCODE:= VACTN->RECCODE
                                        CALCS->PARAM    := cParam

                                        CALCS->( CalcsObjectToTable( oCalcAcc ) )

                                        IF LEN( aTmpSum[2] ) > 1
                                            CALCS->PAYTYPE  := LEFT( VACTN->TYPE, 5 ) +  STRZERO(nCount,1)
                                        ELSE
                                            CALCS->PAYTYPE  := VACTN->TYPE  // Вид оплаты
                                        ENDIF

                                        // В виде конкретной суммы
                                        CALCS->SUMTYPE  := "08##"+XTOC(aTmpSum[1][1])+"###"
                                        CALCS->COUNTSUM := aTmpSum[1][1]
                                        CALCS->SUMMA    := ROUND( aTmpSum[1][1],2 )
                                        IF EMPTY( VACTN->POST ) //bas: по всем доожностям
                                            CALCS->POST := WAGES->MAINPOST
                                        ELSE
                                            CALCS->POST := VACTN->POST
                                        ENDIF
                                    ENDIF
                                ENDIF

                                ADEL( aMonthTemp, 1 )
                                ASIZE( aMonthTemp, LEN( aMonthTemp )-1 )

                                ADEL( aTmpSum[1], 1 )
                                ASIZE( aTmpSum[1], LEN( aTmpSum[1] )-1 )
                            ENDDO
                        ENDIF
                        SELECT VACTN
                    ENDIF
                ELSE
                    ALERT( "В реестре отпускных по сотруднику;"+SayFio()+";присутствует вид отпуска '" +;
                        VACTN->TYPE + "';который не найден в справочнике видов оплат" )
                ENDIF
            SKIP
        ENDDO
        RestFilter( cFilter )
    ENDIF

    RECOVER

    IF cFilter != NIL .AND. SELECT( "VACTN" ) > 0
        VACTN->( RestFilter( cFilter ) )
    ENDIF

    END SEQUENCE

    RETURN

*------------------------------------------------------*
*   Перенос сумм из Оснований для начислений

    STATIC PROCEDURE SBT_Koef( aCount, aUserDolg )
*------------------------------------------------------*
    LOCAL nValue
    LOCAL lPercent
    LOCAL nCount
    LOCAL aFact
    LOCAL aCombination := {}
    LOCAL nIndex
    LOCAL aParam
    LOCAL nSum
    LOCAL nDebet
    LOCAL aRecNo, nX
    LOCAL xTemp
    LOCAL cFkr := SPACE(5)
    LOCAL oCalcsAcc

    LOCAL aKoef

    LOCAL nTotalDays := 0
    LOCAL nFactDays  := 0
    LOCAL lFound := .F.
    LOCAL oParams, oHash, lAddCalc
    LOCAL aScope, cKey, nRecNo

    LOCAL nBegin := IF( aCount[ 2 ], 0, 1 )
    LOCAL cErrorMsg

    IF ! aCount[ 2 ] .AND. ! aCount[ 3 ]
        RETURN
    ENDIF

    BEGIN SEQUENCE

    SayStatus( SayFio(.T.) + ";" + "Определение должностей и счетов" )

    SELECT CALCR
    DB_SETORDER( "ENTCODE" )

    FOR nCount := nBegin TO 1

        // Отфильтруем только начисления - 0 (удержания - 1) текущего сотрудника
        SET SCOPE TO MEMVAR->ENT + WAGES->CODE + XTOC( nCount )
        GO TOP

        aRecNo := {}

        DO WHILE !EOF()
            // По дате начисление подходит
            IF CALCR->SDATE <= EOM( MEMVAR->DATE ) .AND.;
                ( CALCR->FDATE >= BOM( MEMVAR->DATE ) .OR. EMPTY( CALCR->FDATE ) );
                .AND. ( EMPTY( CALCR->TYPE ) .OR. CALCR->TYPE = MEMVAR->npFacesType );
                .AND. ( EMPTY( CALCR->ENTER ) .OR. CALCR->ENTER == MEMVAR->Ent );
                .AND. ( EMPTY( CALCR->JOBSCODE ) .OR. CALCR->JOBSCODE == WAGES->JOBSCODE )
                IF PYMNT->( DBSEEK( CALCR->PAYTYPE ) )
                    AADD( aRecNo, { PYMNT->PRIORITY, RECNO(), CALCR->PAYTYPE } )
                ELSE
                    ALERT( "В таблице оснований для начислений сотрудника;"+SayFio()+";присутствует вид начисления '" +;
                        CALCR->PAYTYPE + "';который не найден в справочнике видов оплат" )
                ENDIF
            ENDIF
            SKIP
        ENDDO

        IF !EMPTY(aRecNo)

            ASORT( aRecNo,,, {|x,y| x[1] < y[1] } )
            aKoef := {}
            FOR nX := 1 TO LEN(aRecNo)

                DBGOTO( aRecNo[nX][2] )
                IF PYMNT->( DBSEEK( aRecNo[nX][3] ) )
                    // Добавим только коэффициенты или другие виды оплат
                    // не отраженные в тарификации или тарификации нет в принципе
                    IF IF( nCount = 0, ! CALCR->TARIF, .T. ) .OR. PYMNT->GROUP=30 .OR. WAGES->TYPE != 10

                        SayStatus( SayFio(.T.) + ";" + REMALL( PYMNT->NAME ) )

                        // Определим список должностей на которые действует данная надбавка
                        // Если данная надбавка действует на одну должность
                        // Если надбавка действует на несколько должностей

                        // Если требуется по всем должностям
                        // и это есть начисление
                        // если по конкретной должности, то все-равно нужны счета

                        // Массив комбинаций счетов и должностей по умолчанию
                        SaveSet()

                        aCombination := {}
                        endstatus()
                        IF ! XTOX( GetMethodHash( PYMNT->CODE ):get( "NOENTRYUSE", ".F." ), "L" )
                            // Определение списка счетов и должностей по умолчанию
                            // На которые будут начисляться коэффициенты
                            SELECT CALCS
                            GO TOP
                            DO WHILE ! EOF()
                                oCalcsAcc := CalcsAccs():new()
                                oCalcsAcc:lIsPlus := .T.
                                oCalcsAcc:lMinus  := .F.

                                // Анализируются только начисления
                                IF ! oCalcsAcc:LoadFromCalcs()
                                    EXIT
                                ENDIF

                                SELECT PYMNT
                                SaveSet()
                                DB_SETORDER( "CODE" )
                                IF DBSEEK( CALCS->PAYTYPE )
                                    IF nCount = 0
                                        nDebet := oCalcsAcc:cPlusFullSeekValue
                                    ELSE
                                        nDebet := oCalcsAcc:cFullSeekValue
                                    ENDIF
                                ELSE
                                    ALERT("Вид оплаты с кодом '"+CALCS->PAYTYPE+"' присутствует в начислениях, "+;
                                          "но не найден в справочнике видов оплат и удержаний. "+;
                                          "Восстановите информацию о виде оплаты и попробуйте вновь",{"Прервать"},"Расчет коэффициентов",,,,,"I")
                                    RestSet()
                                    EXIT
                                ENDIF
                                RestSet()
                                SELECT CALCS
                                IF WAGES->TYPE = 10
                                    IF ! EMPTY( CALCS->POST ).AND.(IF(!EMPTY(CALCR->POST), CALCR->POST==CALCS->POST,.T. ) )
                                        // В массиве нет такой должности     КБК                  Вид деят.
                                        IF ASCAN( aCombination, {|x| x[ 1 ] == CALCS->POST .AND. x[ 2 ] == nDebet } ) = 0
                                            AADD( aCombination, { IF(EMPTY(CALCR->POST),CALCS->POST,CALCR->POST), nDebet, oCalcsAcc } )
                                        ENDIF
                                    ENDIF
                                ELSE
                                    IF ASCAN( aCombination, {|x| x[ 2 ] == nDebet/* .AND. x[3] == xTemp[1] .AND. x[4] == xTemp[2]*/ } ) = 0
                                        AADD( aCombination, { SPACE( UQ_CodeLen() ), nDebet, oCalcsAcc/*, xTemp[1], xTemp[2]*/ } )
                                    ENDIF
                                ENDIF
                                SKIP
                            ENDDO
                        ENDIF
                        beginstatus()
                        RestSet()
                        aFact := aCombination
                        // Требуется начислять только по одной должности

                        // Возьмем параметр
                        nValue   := VAL( CALCR->SUMMA )
                        lPercent := "%" $ CALCR->SUMMA

                        // Параметр не указан
                        // Значит возьмем его из справочника
                        IF EMPTY( nValue )
                            nValue := VAL( PYMNT->PARAM )
                            lPercent := "%" $ PYMNT->PARAM
                        ENDIF

                        // Если это фиксированная сумма
                        // То она должна быть начислена либо по должности
                        // которая указана в CALCR либо по главной
                        // Поэтому урежем массив должностей и счетов до одного элемента
                        IF ! lPercent .OR. EMPTY( aFact )
                            oCalcsAcc := CalcsAccs():new()
                            oCalcsAcc:lIsPlus := ( nCount = 0 )
                            IF ! oCalcsAcc:LoadFromPymnt( PYMNT->CODE,, IF( EMPTY( CALCR->POST ), WAGES->MAINPOST, CALCR->POST ),, @cErrorMsg )
                                Message( "S" + cErrorMsg )
                                BREAK
                            ENDIF
                            aFact := { { IF( EMPTY( CALCR->POST ), WAGES->MAINPOST, CALCR->POST ), IF( nCount = 0, oCalcsAcc:cPlusFullSeekValue, oCalcsAcc:cFullSeekValue ), oCalcsAcc/*GetWageAcc( PYMNT->CODE, nCount == 1 ),/* xTemp[1], xTemp[2]*/ } }
                        ENDIF
                        // Цикл по массиву должностей и счетов
                        FOR nIndex := 1 TO LEN( aFact )
                            nSum := NIL
                            // Если есть метод
                            IF UPPER( LEFT( PYMNT->METOD, 2 ) ) == "W_"
                                // Переменная в которую можно при желании записать параметры
                                // Прямо из выполняющегося макроса
                                PRIVATE cpMethodParam
                                // Вычислим результат COUNTMETOD
                                nSum   := CountMethod( PYMNT->CODE, "EMPTY", IF(!EMPTY(CALCR->SUMMA),CALCR->SUMMA,PYMNT->PARAM), aFact[ nIndex ] )
                            ENDIF

                            // Это начисление или удержание имеет метод расчета
                            // Относящийся к заработной плате
                            // Это процентное начисление/удержание
                            IF lPercent .AND. VALTYPE( nSum ) <> "N"
                                // Тип суммы для расчета по таблице входимости
                                nSum := CALCS->( RefWageCs(;
                                                 CALCR->PAYTYPE,;
                                                 aFact[ nIndex ][ 1 ],;
                                                 aFact[ nIndex ][ 2 ], nCount ) )
                                aParam := { "06#####",;
                                             nSum,;
                                             "////////"+ZR(XTOC(nValue)),;
                                             nSum * nValue / 100 }

                            // Это фиксированная сумма
                            ELSEIF ! lPercent .AND. VALTYPE( nSum ) <> "N"
                                // Если сумма расчитывается календарно
                                // Или это не штатные сотрудники
                                IF ! CALCR->CALCTYPE .OR. MEMVAR->npFacesType > 10
                                    // Сумма заканчивается в данном месяце
                                    IF ! EMPTY( CALCR->FDATE ) .AND. BOM( CALCR->FDATE ) = BOM( MEMVAR->Date )
                                        IF BOM( CALCR->SDATE ) = BOM( MEMVAR->Date )
                                            nValue := D( nValue, BInfoMonth( BOM( MEMVAR->Date ), EOM( MEMVAR->Date ), 3, .T. ) ) * ;
                                                 BInfoMonth( CALCR->SDATE, CALCR->FDATE, 3, .T. )
                                        ELSE
                                            nValue := D( nValue, BInfoMonth( BOM( MEMVAR->Date ), EOM( MEMVAR->Date ), 3, .T. ) ) * ;
                                                 BInfoMonth( BOM( MEMVAR->Date ), CALCR->FDATE, 3, .T. )
                                        ENDIF
                                    // Сумма начинается в данном месяце
                                    ELSEIF BOM( CALCR->SDATE ) = BOM( MEMVAR->Date )
                                        nValue := D( nValue, BInfoMonth( BOM( MEMVAR->Date ), EOM( MEMVAR->Date ), 3, .T. ) ) * ;
                                             BInfoMonth( CALCR->SDATE, EOM( MEMVAR->Date ), 3, .T. )
                                    // Вся сумма должна быть начислена
                                    ELSE
                                        nValue := nValue
                                    ENDIF
                                // Сумма расчитывается по табелю
                                ELSE
                                    // Расчет суммы за отработанное время
                                    nValue := CountWageSum(;
                                                    WAGES->CODE,;      // Код сотрудника
                                                    WAGES->JOBSCODE,;   // Код зап. JOBS_
                                                    nValue,;           // Сумма
                                                    IF( EMPTY(CALCR->SDATE), CTOD( "01/01/1900" ), CALCR->SDATE ),; // Дата начала тарификации
                                                    IF( EMPTY( CALCR->FDATE ), CTOD( "01/01/2200" ), CALCR->FDATE ),;   // Дата конца тарификации
                                                    CALCR->POST,;  // Код должности
                                                    NIL,;      // Предмет
                                                    NIL,;      // Тип
                                                    NIL )[ 1 ] // Способ отражения в зарплате - стандартный
                                ENDIF
                                // В виде конкретной суммы
                                aParam := {  "08##"+XTOC(nValue)+"###",;
                                             nValue,;
                                             "///////"+XTOC(nValue)+"//",;
                                             nValue }
                            ELSE
                                IF VALTYPE( nSum ) <> "N"
                                    ALERT( "Метод расчета вида оплаты '" + PYMNT->CODE + "', которая указана в основаниях;"+;
                                        "работает неправильно. Начисление не может быть проведено" )
                                ELSE

                                    // По специальному алгоритму
                                    aParam := { "09#####",;
                                                nSum,;
                                                IF( EMPTY( MEMVAR->cpMethodParam ),;
                                                "///////"+XTOC(nSum)+"//",;
                                                MEMVAR->cpMethodParam ),;
                                                nSum }
                                ENDIF
                            ENDIF

                            // Если посчитанная сумма не равна нулю
                            IF ! EMPTY( aParam[ 2 ] )
                                // Добавим в массив коэффициентов
                                // Если это коэффициент
                                IF PYMNT->GROUP = 30 .AND. lPercent
                                    IF ASCAN( aKoef, {|x| x[ 1 ] == PYMNT->CODE } ) = 0
                                        AADD( aKoef, { PYMNT->CODE, nValue } )
                                    ENDIF
                                ENDIF

                                // Формируем корреспонденцию для будущего вида оплаты
                                IF nCount = 0
                                    oCalcsAcc := aFact[ nIndex ][ 3 ]
                                ELSE
                                    oCalcsAcc := CalcsAccs():new()
                                    oCalcsAcc:lIsPlus := ( nCount = 0 )
                                    IF ! oCalcsAcc:LoadFromPymnt( CALCR->PAYTYPE, MEMVAR->ENT, aFact[ nIndex ][ 1 ], WAGES->TYPE, @cErrorMsg )
                                        Message( "S" + cErrorMsg )
                                        BREAK
                                    ENDIF
                                    oCalcsAcc:join( aFact[ nIndex ][ 3 ]:wacc, JoinAnalitHash( aFact[ nIndex ][ 3 ]:ohAnalit, oCalcsAcc:ohAnalit, CALCR->PAYTYPE ) )
                                ENDIF

                                lAddCalc := .F.
                                //проверяем, нет ли в среди начислений аналогичных записей, добавленных вручную
                                IF CalcIsPresent( CALCR->PAYTYPE, IF( nCount = 0, 20, 40 ), aFact[ nIndex ][ 1 ], WAGES->JOBSCODE, ;
                                    CALCR->RECCODE, PYMNT->PRIORITY, aParam[ 3 ] , oCalcsAcc:wacc, .F.,, ;
                                    , CALCR->SDATE, CALCR->FDATE, .T. ) == 0

                                    IF PYMNT->GROUP == 50
                                        IF (nRecNo := CalcIsPresent( CALCR->PAYTYPE, IF( nCount = 0, 30, 50 ), aFact[ nIndex ][ 1 ],;
                                                WAGES->JOBSCODE, CALCR->RECCODE,,, ;
                                                oCalcsAcc:wacc,,)) > 0
                                            //есть уже такое начисление
                                            //находим запись
                                            aScope := CALCS->( SaveScope() )
                                            CALCS->( SaveSet() )

                                            DBSELECTAREA("CALCS")
                                            DB_SETORDER("GROUP")
                                            cKey := DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( IF( nCount = 0, 30, 50 ), 2 ) + CALCR->PAYTYPE
                                            ORDSCOPE(0, cKey)
                                            ORDSCOPE(1, cKey)
                                            DBGOTOP()
                                            IF !EOF()
                                                DBGOTO(nRecNo)
                                                IF !EOF()
                                                    IF CALCS->CALCRCODE == CALCR->RECCODE
                                                        //если добавляется ранее добавленное основание
                                                        //вычисляем разницу в сумме, которую нужно добавить
                                                        aParam[4] -= CALCS->SUMMA
                                                        lAddCalc := .T.
                                                    ENDIF
                                                ENDIF
                                            ENDIF

                                            CALCS->( RestSet() )
                                            CALCS->( RestScope(aScope) )

                                            DBSELECTAREA("CALCR")

                                        ENDIF
                                    ENDIF

                                    IF !lAddCalc .AND. CalcMayBeModified( CALCR->PAYTYPE, IF( nCount = 0, 30, 50 ), aFact[ nIndex ][ 1 ],;
                                        WAGES->JOBSCODE, CALCR->RECCODE,,, ;
                                        oCalcsAcc:wacc,, )
                                           lAddCalc := .T.
                                    ENDIF
                                ENDIF

                                IF lAddCalc .AND. ABS(aParam[4]) > 0.005
                                    // Добавим новую запись
                                    CALCS->( SOFT_APPEND() )
                                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                    CALCS->CODE     := WAGES->CODE     // Табельный
                                    CALCS->CALCRCODE:= CALCR->RECCODE  // код записи основания
                                    CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                                    CALCS->GROUP    := PYMNT->GROUP    // группа
                                    CALCS->MODE     := IF( nCount = 0, 30, 50 ) // Режим
                                    CALCS->COMMENT  := PYMNT->NAME     // Примечание
                                    CALCS->PAYTYPE  := CALCR->PAYTYPE  // Вид оплаты
                                    // Если это начисление
                                    CALCS->POST  := aFact[ nIndex ][ 1 ]      // Должность
                                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )

                                    // Суммы и их характеристики
                                    CALCS->SUMTYPE   := aParam[ 1 ] // Тип суммы для расчета
                                    CALCS->COUNTSUM  := aParam[ 2 ] // Сумма для расчета
                                    CALCS->PARAM     := aParam[ 3 ] // Параметр для расчета
                                    CALCS->SUMMA     := ROUND( aParam[ 4 ], 2 ) // Сумма-результат

                                    xTemp := ASCAN( aUserDolg, {|x| x:mode == CALCS->MODE .AND. x:paytype == CALCS->PAYTYPE .AND. x:post == CALCS->POST } )
                                    IF !EMPTY( xTemp )
                                        CALCS->SUMMADP := aUserDolg[ xTemp ]:summadp
                                    ENDIF
                                ENDIF
                            ENDIF
                        NEXT
                    ENDIF
                ENDIF
            NEXT
        ENDIF

    NEXT

    END SEQUENCE

    RETURN

*------------------------------------------------------*
*   Получение процента из таблицы входимости
    FUNCTION GetENTTBPercentValue(nENTTBPercent)
*------------------------------------------------------*
    RETURN IF(nENTTBPercent<0, D( 1, ABS(nENTTBPercent) ), nENTTBPercent/100 )

*------------------------------------------------------*
*   Перенос сумм по перечислениям в сбербанк

    STATIC FUNCTION SBT_Bank()
*------------------------------------------------------*
    LOCAL nCountSum
    LOCAL nReturn := 0
    LOCAL aScope
    LOCAL aPayType
    LOCAL aPayTypes
    LOCAL cDacc
    LOCAL nCount
    LOCAL cPost
    LOCAL nUseSum
    LOCAL nSum
    LOCAL cKbk
    LOCAL aKbk
    LOCAL nIndex, nI
    LOCAL aReturn
    LOCAL aSumForCalcs := {}
    LOCAL nCoef := 1
    LOCAL lAppend
    LOCAL aBuf := {}
    LOCAL aArr := {}, nA, nB, aKoef := {}, nS, nJ
    LOCAL nAdd, nKeep, xTmp, nK, nD, nRecNo
    LOCAL oCalcAcc
    LOCAL cErrorMsg
    LOCAL ohTemp
    LOCAL nPaysToBank
    LOCAL nESum, nInd, aEnttb := {}

    IF ! MODINIT( { "PBANK" } )
        RETURN( 0 )
    ENDIF
    IF SELECT( "POSTS" ) = 0
        IF !ReferInit( {"POSTS"} )
            RETURN( 0 )
        ENDIF
    ENDIF

    IF !REFERINIT( { "ENTTB", "PRFSP" } )
        RETURN( 0 )
    ENDIF

    SELECT PRFSP
    DB_SETORDER( "CODE" )
    SET SCOPE TO

    SELECT POSTS
    DB_SETORDER( "CODE" )
    SET SCOPE TO

    SELECT PBANK
    DB_SETORDER( "CODE" )
    SET SCOPE TO WAGES->CODE + WAGES->JOBSCODE
    GO TOP

    aReturn := GetWageSumByAcc( .F., NIL, 80, .T., .F.,, .T.,,.T., .T. )
    nSum := 0
    aKbk := {}

// Накапливаем общую сумму к выдаче
    FOR nIndex := 1 TO LEN( aReturn[3] )
        IF aReturn[3][nIndex][2] > 0.009
            nSum += aReturn[3][nIndex][2]
            IF ( nI := ASCAN( aKbk, {|x| x[1] == aReturn[3][nIndex][1] + aReturn[3][nIndex][3] } ) ) = 0
                AADD( aKbk, { aReturn[3][nIndex][1] + aReturn[3][nIndex][3], aReturn[3][nIndex][2], 0 } )
            ELSE
                aKbk[nI][2] += aReturn[3][nIndex][2]
            ENDIF
        ENDIF
    NEXT

//  aBuf[][1] - ключ (счет + КБК)
//  aBuf[][2] - начисление
//  aBuf[][3] - удержания
    //классификация по статье, виду выплат (начисл. / удержание)
    FOR nIndex := 1 TO LEN( aReturn[3] )
        IF ( nI := ASCAN( aBuf, {|x| x[1] == aReturn[3][nIndex][1] + aReturn[3][nIndex][3] } ) ) = 0
            AADD( aBuf, { aReturn[3][nIndex][1] + aReturn[3][nIndex][3], {}, {} } )
        ENDIF
    NEXT
    //пересборка удержаний
    FOR nIndex := 1 TO LEN( aReturn[2] )
        IF (nI:=ASCAN(aBuf,{ |x| x[1]==aReturn[2][nIndex][1] + aReturn[2][nIndex][3] })) > 0
            //                          счет                  сумма                должность             oCalcsLine
            AADD(aBuf[nI][3], { aReturn[2][nIndex][1], aReturn[2][nIndex][2], aReturn[2][nIndex][3], aReturn[2][nIndex][4] } )
            //       вид оплаты           группа вида оплат
        ENDIF

    NEXT

    // Перенос перечислений по банкам
    DO WHILE ! EOF()
        IF ! EMPTY( PBANK->PAYTYPE ) .AND. ! EMPTY( VAL( PBANK->PERCENT ) ) .AND.;
            PBANK->SDATE <= EOM( MEMVAR->Date ) .AND. ( EMPTY( PBANK->FDATE ) .OR. PBANK->FDATE >= BOM( MEMVAR->Date ) )

            FOR nIndex := 1 TO LEN( aReturn[3] )

                IF "%"$PBANK->PERCENT
                    nUseSum := ( VAL( PBANK->PERCENT ) * aReturn[3][nIndex][2] ) / 100
                ELSE
                    nUseSum := D( VAL( PBANK->PERCENT ) * aReturn[3][nIndex][2], nSum )
                ENDIF
                AEVAL( aBuf, {|x| x[2] := {} } )
                //пересборка начислений
                aEnttb := Extract({},"ARR", "ENTTB", {"SLAVE","PERCENT"}, {"GROUP", PBANK->PAYTYPE, PBANK->PAYTYPE})
                FOR nK := 1 TO LEN( aReturn[1] )
                    IF (nI:=ASCAN(aBuf,{ |x| x[1]==aReturn[1][nK][1] + aReturn[1][nK][3] })) > 0

                        IF EMPTY(nInd := ASCAN(aEnttb, {|x| x[1] == aReturn[1][nK][5] } ))
                            nESum := aReturn[1][nK][2]
                        ELSE
                            IF (aEnttb[nInd][2]<0)
                                nESum := D(aReturn[1][nK][2] , -aEnttb[nInd][2] )
                            ELSE
                                nEsum := D(aReturn[1][nK][2] * aEnttb[nInd][2], 100 )
                            ENDIF
                        ENDIF
                        //                      счет 1         сумма 2    олжность 3        oCalcsLine 4    5
                        AADD(aBuf[nI][2], { aReturn[1][nK][1], nEsum, aReturn[1][nK][3], aReturn[1][nK][4], 0 } )
                        //       вид оплаты           группа вида оплат
                    ENDIF
                NEXT

                IF ( PYMNT->( DBSEEK( PBANK->PAYTYPE ) ) )

                    IF CalcMayBeModified( PBANK->PAYTYPE,;         // 1 Вид оплаты
                                  50,;                  // 2 Режим
                                  aReturn[3][ nIndex ][ 3 ],;                  // 3 Должность сотрудника
                                  WAGES->JOBSCODE,;              // 4
                                  PBANK->RECCODE,;             // 5
                                  NIL,;              // 6 (не используется)
                                  NIL,;                 // 7 (не используется)
                                  aReturn[3][ nIndex ][ 5 ],;                  // 8 Счет
                                  NIL,;            // 9 Проверять ли включенность в ведомость (не используется)
                                  NIL,;                   // 10 ФКР
                                  NIL, ;                // 11 Вид деятельности
                                  NIL, ;                // 12
                                  NIL, ;                // 13
                                  NIL ;         // 14 проверять существующие начисления
                                 )

                        IF "%"$PBANK->PERCENT
                            //                          счет
                            IF ( nK := ASCAN( aBuf, aReturn[3][nIndex][1] ) ) > 0

                                IF LEN(aBuf[nK][2])>0   //если есть начисления

                                    DBSELECTAREA("ENTTB")
                                    DB_SETORDER("GROUP")

                                    //определяем: какая часть удержания относится к каждому начислению
                                    //проход по удержаниям
                                    FOR nI := 1 TO LEN(aBuf[nK][3])

                                        aArr := {}
                                        //
                                        nS := 0     //сумма начислений, входящих в текущее удержание
                                        //проход по начислениям
                                        FOR nJ := 1 TO LEN(aBuf[nK][2])
                                            AADD(aArr,{0,0})
                                            IF aBuf[nK][3][nI][4]:mode == 40
                                                // удержание введено вручную? всегда попадает
                                                nA := 1
                                            ELSE
                                                IF PADR(aBuf[nK][3][nI][4]:paytype,6)$"П/Н   ;П/Нмат;" // с НДФЛ с коэффициентов пока не понятен... Оставляем по таб. входимости
                                                    nA := 0
                                                    nRecNo := PYMNT->( RECNO() )
                                                    // в части НДФЛ анализируем не таблицу входимости, а код дохода ВО
                                                    IF PYMNT->( DBSEEK( aBuf[nK][2][nJ][4]:paytype ) )
                                                        IF ! EMPTY( PYMNT->GNI01 ) .AND. PRFSP->( DBSEEK( PYMNT->GNI01 ) )
                                                            IF PRFSP->TAXMODE = 0 .AND. PADR(aBuf[nK][3][nI][4]:paytype,6) == "П/Н   "
                                                                nA := 1
                                                            ELSEIF PRFSP->TAXMODE = 2 .AND. PADR(aBuf[nK][3][nI][4]:paytype,6) == "П/Нмат"
                                                                nA := 1
                                                            ENDIF
                                                        ENDIF
                                                    ENDIF
                                                    PYMNT->( DBGOTO( nRecNo ) )
                                                ELSE
                                                    //поиск начисления в таблице входимости для удержания
                                                    //                      код удержания                        группа вида оплат                     код начисления
                                                    IF DBSEEK( PADR( aBuf[nK][3][nI][4]:paytype, 6 ) + STRZERO( aBuf[nK][2][nJ][4]:group, 2 ) + aBuf[nK][2][nJ][4]:paytype )
                                                        nA := GetENTTBPercentValue( ENTTB->PERCENT )
                                                    ELSE
                                                        nA := 1 //если не нашли в таблице входимости, то считаем, что удержание входит в начисление
                                                    ENDIF
                                                ENDIF
                                            ENDIF
                                            nS += aBuf[nK][2][nJ][2] * nA
                                            aArr[nJ][1] := nA //процент от начисления
                                        NEXT

                                        xTmp := 0
                                        //проход по начислениям
                                        FOR nJ := 1 TO LEN(aBuf[nK][2])
                                            IF nJ==LEN(aBuf[nK][2]) .AND. nJ>1
                                                IF aArr[nJ][1]>0
                                                    aBuf[nK][2][nJ][5] += aBuf[nK][3][nI][2] - xTmp
                                                ENDIF
                                            ELSE
                                                //определяем: какая часть удержания входит в текущее начисление
                                                nD := aBuf[nK][3][nI][2] * D(aBuf[nK][2][nJ][2] * aArr[nJ][1], nS)
                                                xTmp               += nD
                                                aBuf[nK][2][nJ][5] += nD
                                            ENDIF
                                        NEXT
                                    NEXT

                                    nAdd  := 0  //начислено
                                    nKeep := 0  //удержано
                                    //проход по начислениям
                                    FOR nI := 1 TO LEN(aBuf[nK][2])
                                         //определяем: входит ли начисление в таблицу входимости для перечисления в банк
                                        IF DBSEEK( PADR( PBANK->PAYTYPE, 6 ) + STRZERO( aBuf[nK][2][nI][4]:group, 2 ) + aBuf[nK][2][nI][4]:paytype )
                                            //входит
                                            nAdd  += GetENTTBPercentValue(ENTTB->PERCENT) * aBuf[nK][2][nI][2]
                                            nKeep += GetENTTBPercentValue(ENTTB->PERCENT) * aBuf[nK][2][nI][5]
                                        ELSE
                                            //не входит
                                            nAdd  += aBuf[nK][2][nI][2]
                                            nKeep += aBuf[nK][2][nI][5]
                                        ENDIF
                                    NEXT

                                ELSE
                                    //нет начислений
                                    nAdd  := 0  //начислено
                                    nKeep := 0  //удержано
                                    //проход по удержаниям
                                    FOR nI := 1 TO LEN(aBuf[nK][3])
                                        //cуммируем удержания
                                        nKeep += aBuf[nK][3][nI][2]
                                    NEXT
                                ENDIF

                                //считаем сумму к выдаче
                                nUseSum := (nAdd - nKeep) * VAL(PBANK->PERCENT) / 100
                                DBSELECTAREA("PBANK")
                            ENDIF
                        ENDIF

                        //получение удержанной суммы
                        IF ( nI := ASCAN( aSumForCalcs, {|x| x:PBankLine:reccode == PBANK->RECCODE .AND. x:FullSeekLine == aReturn[ 3 ][ nIndex ][ 1 ] ;
                                    .AND. x:post == aReturn[3][ nIndex ][ 3 ] .AND. x:PBankLine:paytype == PBANK->PAYTYPE } ) ) = 0

                            ohTemp := HashIVar():new()
                            ohTemp:PBankLine    := PBANK->( ReadRecordToHash( NIL, HashIVar():new() ) )
                            ohTemp:FullSeekLine := aReturn[3][ nIndex ][ 1 ]
                            ohTemp:Post         := aReturn[3][ nIndex ][ 3 ]
                            ohTemp:UseSum       := nUseSum
                            ohTemp:Pymnt        := HashIVar():new()
                                ohTemp:Pymnt:Name     := PYMNT->NAME
                                ohTemp:Pymnt:Priority := PYMNT->PRIORITY
                                ohTemp:Pymnt:Group    := PYMNT->GROUP
                            ohTemp:CalcsLine    := aReturn[3][nIndex][4]

                           AADD( aSumForCalcs, ohTemp )
                        ELSE
                            aSumForCalcs[nI]:UseSum += nUseSum
                        ENDIF

                        IF ( nI := ASCAN( aKbk, {|x| x[1] == aReturn[3][nIndex][1] + aReturn[3][nIndex][3]/* + aReturn[3][nIndex][4]*/ } ) ) = 0
                            AADD( aKbk, { aReturn[3][nIndex][1] + aReturn[3][nIndex][3]/* + aReturn[3][nIndex][4]*/, 0, nUseSum } )
                        ELSE
                            aKbk[nI][3] += nUseSum
                        ENDIF

                        nReturn += nUseSum
                    ENDIF
                ELSEIF PYMNT->(!FOUND())
                    ALERT( "В реестре перечислений в банк сотрудника;"+SayFio()+";присутствует вид перечисления '" +;
                        PBANK->PAYTYPE + "';который не найден в справочнике видов оплат" )
                ENDIF
            NEXT
        ENDIF
        SKIP
    ENDDO

    IF nReturn > nSum
        nCoef := D( nSum, nReturn )
    ENDIF

    nCountSum := nSum
    nReturn   := 0
    FOR nI := 1 TO LEN( aKbk )
        lAppend := .F.
        FOR nIndex := 1 TO LEN( aSumForCalcs )
            IF aKbk[nI][1] == aSumForCalcs[ nIndex ]:FullSeekLine + aSumForCalcs[ nIndex ]:Post
                nK := NIL
                    CALCS->( SOFT_APPEND() )
                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                    CALCS->CODE     := WAGES->CODE     // Табельный
                    CALCS->CALCRCODE:= aSumForCalcs[ nIndex ]:PBankLine:reccode  // код записи основания
                    CALCS->PRIORITY := aSumForCalcs[ nIndex ]:Pymnt:priority // приоритет вычисл
                    CALCS->GROUP    := aSumForCalcs[ nIndex ]:Pymnt:group // группа

                    CALCS->MODE     := 50              // Режим
                    CALCS->COMMENT  := aSumForCalcs[ nIndex ]:Pymnt:name     // Примечание

                    CALCS->POST     := aSumForCalcs[ nIndex ]:post
                    oCalcAcc := CalcsAccs():new()
                    oCalcAcc:lIsPlus := .F.

                    IF ! oCalcAcc:LoadFromPymnt( aSumForCalcs[ nIndex ]:PBankLine:paytype, MEMVAR->ENT, aSumForCalcs[ nIndex ]:post, WAGES->TYPE, @cErrorMsg )
                        Message( "S" + cErrorMsg )
                        BREAK
                    ENDIF
                    // Объект создан и заполнен по-человечески
                    // Теперь заливаем туда з/платный счет и хэш с аналитикой
                    oCalcAcc:Join( aSumForCalcs[ nIndex ]:CalcsLine:CalcsAcc:wacc, JoinAnalitHash( aSumForCalcs[ nIndex ]:CalcsLine:CalcsAcc:ohAnalit, oCalcAcc:ohAnalit, aSumForCalcs[ nIndex ]:PBankLine:paytype ), .F. )
                    CALCS->( CalcsObjectToTable( oCalcAcc ) )
                    // Суммы и их характеристики
                    CALCS->PAYTYPE   := aSumForCalcs[ nIndex ]:PBankLine:paytype// Вид оплаты
                    CALCS->SUMTYPE   := "" // Тип суммы для расчета
                    CALCS->COUNTSUM  := 0 // Сумма для расчета
                    CALCS->PARAM     := ALLTRIM( aSumForCalcs[ nIndex ]:PBankLine:percent ) // Параметр для расчета
                    IF aSumForCalcs[ nIndex ]:UseSum < 0.005
                        CALCS->SUMMA     := 0
                    ELSE
                        lAppend := .T.
                        CALCS->SUMMA     := aSumForCalcs[ nIndex ]:UseSum // Сумма-результат
                        aKbk[nI][IF(nCoef<1,2,3)] -= CALCS->SUMMA
                        nReturn += CALCS->SUMMA
                        nK := CALCS->( RECNO() )
                    ENDIF

                    //*************************************************
                    // Удержание процента за перечисление
                    //*************************************************
                    nPaysToBank := 0

                    IF ! EMPTY( aSumForCalcs[ nIndex ]:PBankLine:PrcPType ) // Вид удержания процента за перечисление в банк
                        // Анализируем, а были ли авансы в тот же банк?
                        FOR nD := 1 TO LEN( aReturn[2] )
                            IF aReturn[2][nD][4]:group == 50 // Учитываем только авансы
                                IF ( aSumForCalcs[ nIndex ]:FullSeekLine + aSumForCalcs[ nIndex ]:Post == aReturn[2][nD][1] + aReturn[2][nD][3] )
                                    // Счет и должность совпали - анализируем, куда был перечислен аванс
                                    IF EMPTY( aReturn[2][nD][4]:paysheet ) .OR. aSumForCalcs[ nIndex ]:PBankLine:bank == aReturn[2][nD][4]:paysheet:cBankCode // тот же банк
                                        // нет ведомости или тот же банк - суммируем
                                        nPaysToBank += aReturn[2][nD][2]
                                    ENDIF
                                ENDIF
                            ENDIF
                        NEXT
                        IF ! PYMNT->( DBSEEK( aSumForCalcs[ nIndex ]:PBankLine:PrcPType ) )
                            Message( "S" + 'Вид оплаты с кодом "' + aSumForCalcs[ nIndex ]:PBankLine:PrcPType + ;
                                     '" не найден в справочнике видов оплат. Исправьте ситуацию и попробуйте вновь' )
                            BREAK
                        ENDIF
                        IF AT( "%", aSumForCalcs[ nIndex ]:PBankLine:PrcPerc ) = 0 .AND. VAL( aSumForCalcs[ nIndex ]:PBankLine:PrcPerc ) < 0.01
                            aSumForCalcs[ nIndex ]:PBankLine:PrcPerc := PYMNT->PARAM
                        ENDIF
                        IF VAL( aSumForCalcs[ nIndex ]:PBankLine:PrcPerc ) > 0.0001
                            IF AT( "%", aSumForCalcs[ nIndex ]:PBankLine:PrcPerc ) == 0 // Просто сумма
                                nS := { "", "", VAL( aSumForCalcs[ nIndex ]:PBankLine:PrcPerc ) }
                            ELSE
                                nS := CountMethod( aSumForCalcs[ nIndex ]:PBankLine:PrcPType, { VAL( aSumForCalcs[ nIndex ]:PBankLine:PrcPerc ), IF( nK = NIL, 0, CALCS->SUMMA ), nPaysToBank } )
                            ENDIF
                            IF ! EMPTY( nS ) .AND. VALTYPE( nS ) == "A" .AND. ROUND( nS[ 3 ], 2 ) > 0.009
                                IF nK != NIL
                                    // Головной записи нет - уменьшать нечего
                                    CALCS->SUMMA -= ROUND( nS[3], 2 )
                                    IF CALCS->SUMMA < 0.01
                                        CALCS->( ReferLoop() )
                                        CALCS->( SOFT_DELETE() )
                                        nK := NIL
                                    ENDIF
                                ENDIF
                                // Добавление удержания процента за перечисление в банк
                                CALCS->( SOFT_APPEND() )
                                CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                                CALCS->MONTH    := MEMVAR->DATE    // Месяц
                                CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                                CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                                CALCS->CODE     := WAGES->CODE     // Табельный
                                CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                                CALCS->GROUP    := PYMNT->GROUP // группа

                                CALCS->MODE     := 50              // Режим
                                CALCS->COMMENT  := PYMNT->NAME     // Примечание

                                CALCS->POST     := aSumForCalcs[ nIndex ]:post
                                oCalcAcc := CalcsAccs():new()
                                oCalcAcc:lIsPlus := .F.

                                IF ! oCalcAcc:LoadFromPymnt( aSumForCalcs[ nIndex ]:PBankLine:PrcPType, MEMVAR->ENT, aSumForCalcs[ nIndex ]:post, WAGES->TYPE, @cErrorMsg )
                                    Message( "S" + cErrorMsg )
                                    BREAK
                                ENDIF
                                // Объект создан и заполнен по-человечески
                                // Теперь заливаем туда з/платный счет и хэш с аналитикой
                                oCalcAcc:Join( aSumForCalcs[ nIndex ]:CalcsLine:CalcsAcc:wacc, JoinAnalitHash( aSumForCalcs[ nIndex ]:CalcsLine:CalcsAcc:ohAnalit, oCalcAcc:ohAnalit, aSumForCalcs[ nIndex ]:PBankLine:PrcPType ), .F. )
                                CALCS->( CalcsObjectToTable( oCalcAcc ) )

                                // Суммы и их характеристики
                                CALCS->PAYTYPE   := aSumForCalcs[ nIndex ]:PBankLine:PrcPType // Вид оплаты
                                CALCS->SUMTYPE   := "" // Тип суммы для расчета
                                CALCS->COUNTSUM  := 0 // Сумма для расчета
                                CALCS->PARAM     := aSumForCalcs[ nIndex ]:PBankLine:PrcPerc // Параметр для расчета
                                CALCS->SUMMA     := ROUND( nS[ 3 ], 2 )//aSumForCalcs[ nIndex ][ 6 ] // Сумма-результат
                            ENDIF
                        ENDIF
                    ENDIF
            ENDIF
        NEXT

        IF lAppend
            IF nK != NIL
                CALCS->( DBGOTO( nK ) )
                IF CALCS->( ReferLoop() )
                    CALCS->SUMMA += aKbk[nI][IF(nCoef<1,2,3)]
                ENDIF
                CALCS->( UN_LOCK() )
                nReturn      += aKbk[nI][IF(nCoef<1,2,3)]
            ENDIF
        ENDIF

    NEXT

    RETURN nReturn
*------------------------------------------------------*
*   Удаление старой суммы по тарифу
*   aUserDolg - сюда будет прописываться виды оплат с заданными пользователем долгами
    STATIC FUNCTION SBT_Delete( aModes, cPayType, nGroup, aUserDolg )
*------------------------------------------------------*
    LOCAL nCount, nDelSum := 0
    LOCAL oObj
    LOCAL oHash, oParam
    LOCAL lDel := .F.

    aUserDolg := {}

    // *** Удаление из заработной платы всех сумм, подлежащих замещению
    SELECT CALCS

    DB_SETORDER( "CODE" )
    SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE
    GO TOP
    DO WHILE !EOF()
        IF ASCAN( aModes, FIELD->MODE ) > 0 .AND. ;
            ( cPayType == NIL .OR. ALLTRIM(FIELD->PAYTYPE) == cPayType ) .AND. ;
            ( nGroup == NIL .OR. FIELD->GROUP == nGroup )

            lDel := .T.

            IF CALCS->GROUP == 50 .AND. !EMPTY(CALCS->CALCRCODE) .AND. ; //аванс из оснований
                CalcSheets():CalcWasPayed()
                    lDel := .F.
            ELSEIF CalcSheets():IsInFinalSheet() == .T. //если начисление/удерж входит в окончательную ведомость,
                lDel := .F.                         //то запись не удаляем
            ENDIF

            IF lDel
                IF !EMPTY( FIELD->SUMMADP )
                    oObj := HashIvar():new()
                    oObj:mode    := FIELD->MODE
                    oObj:paytype := FIELD->PAYTYPE
                    oObj:post    := FIELD->POST
                    oObj:summadp := FIELD->SUMMADP
                    AADD( aUserDolg, oObj )
                ENDIF

                nDelSum += FIELD->SUMMA
            // Мягкое удаление
                SOFT_DELETE()
            ELSE
                SKIP
            ENDIF
            LOOP
        ENDIF
        SKIP
    ENDDO

    SET SCOPE TO

    RETURN nDelSum

*------------------------------------------------------*
*   Расчет суммы по тарификации

    FUNCTION CountWageSum(;
                   cTabel,;     // 1 Код сотрудника
                   cJobsCode,;  // 2 Код зап. JOBS_
                   nSumma,;     // 3 Сумма
                   dBeginTarif,;// 4 Дата начала тарификации
                   dEndTarif,;  // 5 Дата конца тарификации
                   cPostCode,;  // 6 Код должности
                   cSubj,;      // 7 Предмет
                   cType,;      // 8 Тип
                   nToWage,;    // 9 Способ отражения в зарплате
                   dTabelDate,; // 10 месяц извлечения сведений из табеля
                   cTrrecCode,; // 11 код строки тарификации
                   lTarif )     // 12 не выдавать сообщений об ошибках
*------------------------------------------------------*
    LOCAL nCount
    LOCAL nResult := 0
    LOCAL lDay    := .T.
    LOCAL nTotal  := 0
    LOCAL nWork   := 0
    LOCAL lFound  := .F.
    LOCAL nRecNo
    LOCAL cIndexValue

    DEFAULT nToWage    IS 0 // Стандартный способ отражения в зарплате
    DEFAULT dTabelDate IS MEMVAR->DATE
    DEFAULT cTrrecCode IS ""
    DEFAULT lTarif     IS .F.

    SaveSet()

    cTrrecCode := ""

    IF EMPTY( cPostCode ) .AND. cPostCode <> NIL
        cPostCode := NIL
    ENDIF
    lFound := .F.
    IF MEMVAR->opUT:select( "JOBTB", MEMVAR->ENT,, YEAR( dTabelDate ) )
        IF cSubj <> NIL .AND. cType <> NIL .AND. cPostCode <> NIL
            cIndexValue := cTabel + cSubj + cType + cPostCode + DTOS( BOM( dTabelDate ) ) + cJobsCode + cTrrecCode
            DB_SETORDER( "KEY" )
            lFound := DBSEEK( cIndexValue )

            IF lFound .AND. EMPTY( cTrrecCode )
                CheckJobtb( cIndexValue )
            ENDIF

        ELSEIF cPostCode <> NIL
            IF EMPTY(cSubj) .AND. EMPTY(cType)
                cIndexValue := cTabel + cJobscode + cPostCode + DTOS( BOM( dTabelDate ) ) + cTrrecCode
                DB_SETORDER( "ANYPOST2" )
                lFound := DBSEEK( cIndexValue )

                IF lFound .AND. EMPTY( cTrrecCode )
                    CheckJobtb( cIndexValue )
                ENDIF
            ELSE
                IF EMPTY(cSubj)
                    cSubj = SPACE(6)
                ENDIF
                IF EMPTY(cType)
                    cType = SPACE(6)
                ENDIF
                cIndexValue := cTabel + cSubj + cType + cPostCode + DTOS( BOM( dTabelDate ) ) + cJobsCode + cTrrecCode
                DB_SETORDER( "KEY" )
                lFound := DBSEEK( cIndexValue )

                IF lFound .AND. EMPTY( cTrrecCode )
                    CheckJobtb( cIndexValue )
                ENDIF
            ENDIF
        ELSE
            cIndexValue := DTOS( BOM( dTabelDate ) ) + cTabel + cJobsCode + "0"
            DB_SETORDER( "MAINPOST" )
            lFound := DBSEEK( cIndexValue )
            IF lFound
                CheckJobtb( cIndexValue )
            ENDIF
        ENDIF

        // Ищем запись сотрудника по данной должности (или по главной) в табеле
        IF lFound
            dBeginTarif := DAY( MAX( BOM( dTabelDate ), dBeginTarif ) )
            dEndTarif   := DAY( MIN( EOM( dTabelDate ), dEndTarif ) )

            // В днях
            IF ( lDay := ! FIELD->LDAY )
                nTotal := FIELD->NORMDAYS
                FOR nCount := dBeginTarif TO dEndTarif
                    nWork += IF( VAL( REMALL( FIELD->&( "DAY" + STRZERO( nCount, 2 ) ) ) ) > 0, 1, 0 )
                NEXT
            // В часах
            ELSE
                nTotal := FIELD->NORMHOURS
                FOR nCount := dBeginTarif TO dEndTarif
                    nWork += VAL( REMALL( FIELD->&( "DAY" + STRZERO( nCount, 2 ) ) ) )
                NEXT
            ENDIF

            // Если требуется отразить в зарплате стандартным способом
            IF nToWage == 0
                nResult := D( nSumma, nTotal ) * nWork
            // Если по табелю, но не более указанной суммы
            ELSEIF nToWage == 4
                nResult := D( nSumma, nTotal ) * nWork
                IF nResult > nSumma
                    nResult := nSumma
                ENDIF
            // Если в виде суммы
            ELSE
                // Если в данном месяце человек не работал
                IF nWork == 0
                    nResult := 0
                ELSE
                    nResult := nSumma
                ENDIF
            ENDIF
        ELSEIF !lTarif
            IF !WAGES->UVOLN
                WAGES->( PersMessage( '@!При переносе тарификационных выплат из тарификации'+;
                    ' в заработную плату обнаружено, что должность "' + ;
                    ALLTRIM( SayPost( cPostCode, IF(EMPTY(cSubj),"",cSubj), IF(EMPTY(cType),"",cType), 25 ) ) + '"' + ;
                    " не найдена в табеле рабочего времени текущего месяца",,,,,,,, 1 ) )
            ENDIF
        ENDIF
    ENDIF

    RestSet()

    RETURN( { nResult, lDay, nTotal, nWork } )

*------------------------------------------------------*
*   проверка на дубликат записи

    STATIC FUNCTION CheckJobtb( cIndexValue )
*------------------------------------------------------*
    LOCAL lRes := .T.
    LOCAL nRecNo

    nRecNo := RECNO()
    D_SKIP()
    IF LEFT( &( IndexKey( IndexOrd() ) ), LEN( cIndexValue ) ) == cIndexValue
        WAGES->( PersMessage( "@!Необходимо полное обновление табеля во избежание некорректного расчета заработной платы!" ) )
        lRes := .F.
    ENDIF
    DBGOTO( nRecNo )

    RETURN lRes

*------------------------------------------------------*
*   Обновление суммы для расчета для коэффициента

    FUNCTION RefWageCS( cKoefCode, cPost, cSeekValue, nType )
*------------------------------------------------------*
    LOCAL aSaveScope
    LOCAL nReturn := 0
    LOCAL nDebet
    LOCAL xTemp
    LOCAL oCalcsAcc := CalcsAccs():new()

    DEFAULT nType IS 0

    SaveSet()

    oCalcsAcc:lMinus  := .F.

    SELECT ENTTB
    DB_SETORDER( "KEY" )
    SET SCOPE TO

    SELECT CALCS
    aSaveScope := SaveScope()
    DB_SETORDER( "CODE" )
    SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE
    GO TOP

    DO WHILE ! EOF()
        // Исключить самого себя
        IF ! ( CALCS->PAYTYPE == cKoefCode )
                IF ! oCalcsAcc:LoadFromCalcs()
                    EXIT
                ENDIF
                SELECT PYMNT
                SaveSet()
                DB_SETORDER( "CODE" )
                IF DBSEEK( CALCS->PAYTYPE )
                ELSE
                    ALERT("Вид оплаты с кодом '"+CALCS->PAYTYPE+"' присутствует в начислениях, "+;
                          "но не найден в справочнике видов оплат и удержаний. "+;
                          "Восстановите информацию о виде оплаты и попробуйте вновь",{"Прервать"},"Расчет коэффициентов",,,,,"I")
                    RestSet()
                    EXIT
                ENDIF
                RestSet()
                SELECT CALCS

            // Если это та должность и тот счет (для удержаний всегда .T.)

            IF IF( nType == 0, oCalcsAcc:cPlusFullSeekValue, oCalcsAcc:cFullSeekValue ) == cSeekValue .AND. ( WAGES->TYPE <> 10 .OR. CALCS->POST == cPost )
                // Определяем входит ли конкретный вид оплаты в расчет
                IF ENTTB->( DBSEEK( cKoefCode + CALCS->PAYTYPE ) )
                    // Процент входимости не равен нулю
                    IF ENTTB->PERCENT <> 0
                        // Накопим сумму
                        nReturn += IF( ENTTB->PERCENT < 0, D( 1, ABS(ENTTB->PERCENT) ), ENTTB->PERCENT/100 ) * CALCS->SUMMA
                    ENDIF
                ELSE
                    nReturn += CALCS->SUMMA * GetEntryDefault( cKoefCode, CALCS->PAYTYPE ) / 100
                ENDIF
            ENDIF
        ENDIF
        SKIP
    ENDDO

    RestScope( aSaveScope )

    RestSet()

    RETURN( nReturn )

*------------------------------------------------------*
*   Расчет сумм по заработной плате

    PROCEDURE WagesRecalc()
*------------------------------------------------------*
    LOCAL nChoose, nCount
    LOCAL lMarked := ISMARKED()
    LOCAL aParam
    LOCAL aMenu   := { { "Полный расчёт зарплаты" },;
                       { "Расчёт начислений и удержаний" },;
                       { "Расчёт только удержаний" },;
                       { "Расчёт только доходов" },;
                       { "Расчёт только доходов страховых взносов" },;
                       { "Перенос долгов с предыдущих периодов" } }
    LOCAL aScopeWages, aScopeCalc, aScopeJobtb
    LOCAL aAlias := {}
    LOCAL nAlChoose := 0

    PRIVATE oLog := XLSLog():new("persveddolg", "temp", "Отчет о расчете сумм по зарплате",.T.)

    oLog:addcaption( "msg", "Сообщения:" )
    oLog:addcaption( "wng", "Предупреждения:" )

    BEGIN SEQUENCE

    IF IsOtrSys( MEMVAR->DATE ) //отраслевая система оплаты
        IF EMPTY(SELECT("NSGRP"))
            IF !MODINIT( { "NSGRP" },,, MEMVAR->ENT )
                BREAK
            ENDIF
            AADD(aAlias, "NSGRP")
        ENDIF

        IF EMPTY(SELECT("STAFF"))
            IF ! OpenStaffByDate( MEMVAR->DATE, MEMVAR->ENT )
                BREAK
            ENDIF
            AADD(aAlias, "STAFF")
        ENDIF

        IF EMPTY(SELECT("QUALCAT"))
            IF !OpenSettingsTable("QUALCAT")
                BREAK
            ENDIF
            AADD(aAlias, "QUALCAT")
        ENDIF

        IF EMPTY(SELECT("STAJKOEF"))
            IF !OpenSettingsTable("STAJKOEF")
                BREAK
            ENDIF
            AADD(aAlias, "STAJKOEF")
        ENDIF

        IF EMPTY(SELECT("PERCR"))
            IF !MODINIT( { "PERCR" }, MEMVAR->YEAR, , MEMVAR->ENT )
                BREAK
            ENDIF
            AADD(aAlias, "PERCR")
        ENDIF

        IF EMPTY(SELECT("SQUAL"))
            IF !MODINIT( { "SQUAL" },,, MEMVAR->ENT )
                BREAK
            ENDIF
            AADD(aAlias, "SQUAL")
        ENDIF
    ENDIF

    IF WagesClose()
        BREAK
    ENDIF

    nChoose := funcdialog( aMenu,,"Масштаб пересчёта зарплаты" )

    IF nChoose = 0
        BREAK
    ENDIF

    IF nChoose == 6
        aParam := CDDIALOG( "CDPOUTCM", "FIELD->FMONTH := BOM( ADDMONTH( MEMVAR->DATE, -1 ) )" )
        IF VALTYPE( aParam ) != "A"
            BREAK
        ENDIF
        IF EOM( aParam[ 1 ] ) > BOM( MEMVAR->DATE )
            ALERT( "!Для функции перерасчета долгов необходимо, чтобы месяц начала переасчета лежал в предыдущих периодах." )
            BREAK
        ENDIF

        // проверим, есть ли вид оплаты 'Долг за п/п' и долг за работником
        PYMNT->( DB_SETORDER( "GROUP" ) )
        IF ! PYMNT->( DBSEEK( "85" ) )
            ALERT( "!В справочнике ВО долг за работником не обнаружен. Добавьте вид оплаты с кодом группы 85 (долг за работником)" )
            BREAK
        ENDIF
        IF !CheckPymntGroup84()
            BREAK
        ENDIF
    ENDIF
    SaveSet()

    aScopeWages :=WAGES->(SaveScope())
    aScopeCalc  :=CALCS->(SaveScope())
    aScopeJobtb :=JOBTB->(Savescope())

    SELECT WAGES
    GO TOP

    BeginStatus()

    DO WHILE ! EOF()
        SayStatus( SayFio(.T.) + ";" )

        IF ! FIELD->LOCKED .AND. IF( lMarked, MARKED(), .T. )

            IF nChoose >= 1 .AND. nChoose <=3 .AND. CalcSheets():IsInFinalSheet( ,, .F. )
                IF nAlChoose = 3
                    SKIP
                    LOOP
                ENDIF
                nAlChoose := ALERT( '!Существуют окончательные ведомости по сотруднику "' + ALLTRIM( SayFIO( .F. ) ) + '"!', { "Продолжить", "Прервать", "Игнорировать всех" } )
                IF EMPTY( nAlChoose ) .OR. nAlChoose = 2
                    EndStatus()

                    WAGES->(RestScope(aScopeWages))
                    CALCS->(RestScope(aScopeCalc))
                    JOBTB->(RestScope(aScopeJobtb))

                    RestSet()
                    BREAK

                ELSEIF nAlChoose = 3
                    SKIP
                    LOOP
                ENDIF
            ENDIF

            IF ReferLock()

                IF nChoose = 1
                    FIELD->TARIF := SumByTarif( FIELD->TARIF, .F., { .T., .T., .T. }, .T., .T. )
                ELSEIF nChoose = 2
                    FIELD->TARIF := SumByTarif( FIELD->TARIF, .F., { .F., .T., .T. }, .T. )
                ELSEIF nChoose = 3
                    FIELD->TARIF := SumByTarif( FIELD->TARIF, .F., { .F., .F., .T. }, .T. )
                ELSEIF nChoose = 4
                    UpdateProfit()
                ELSEIF nChoose = 5
                    UpdatProfS()
                ELSEIF nChoose == 6

                    MacroRun( MEMVAR->ModMacPath + "transfer of debt.mac",,{ aParam[ 1 ], aParam[ 2 ], oLog } )
                    // если в настройке ЗП стоит расчет ПН по начисленным суммам
                    // то пересчитываем и ЕСН

                ENDIF
                SELECT WAGES
                ExecuteAutoBlock( MEMVAR->aField, .F. )
                UN_LOCK()
            ELSE
                ALERT( "SОтказ блокировки записи по сотруднику;" + SayFio(.T.) )
            ENDIF
        ENDIF
        SKIP
    ENDDO

    IF nChoose == 6 .OR. nChoose<4
        IF oLog:GetMessageCount() > 0
            IF ALERT( "Операция завершена. Рекомендуется просмотреть отчет", { "Просмотреть отчет", "Продолжить" } ) == 1
                oLog:Save()
                oLog:Show()
            ENDIF
        ENDIF
    ENDIF

    EndStatus()
    WAGES->(RestScope(aScopeWages))
    CALCS->(RestScope(aScopeCalc))
    JOBTB->(RestScope(aScopeJobtb))

    RestSet()

    END SEQUENCE

    FOR nCount := 1 TO LEN(aAlias)
        DBCLOSE(aAlias[nCount])
    NEXT

    RefreshAll()

    RETURN

*------------------------------------------------------*
*   Расчет сумм по заработной плате

    FUNCTION WagesClose()
*------------------------------------------------------*

    IF GetCloseDate() >= BOM( MEMVAR->DATE )
        MALERT( "Данные за " + SayDate(MEMVAR->DATE, "MMMMM YYYY г." ) + " закрыты от изменений" )
        RETURN( .T. )
    ENDIF

    RETURN( .F. )


*------------------------------------------------------*
*   Метод расчета сумм по заработной плате для начисления или удержания группе сотрудников

    FUNCTION GetWagesCountSumType( nType, lSay, nMode )
*    nType - метод расчет
*    lSay  - признак возврата наименования метода расчет
*    nMode - способ расчета (по главной должности, по всем должностям, по сотруднику)
*------------------------------------------------------*
    LOCAL aArrType := {{'От суммы "Итого начислено"',    .T.},; /* 0 */
                       {"От общей суммы к выплате",      .T.},; /* 1 */
                       {"От остатка к получению",        .T.},; /* 2 */
                       {"По таблице входимости",         .T.},; /* 3 */
                       {"От суммы по тарифу",            .T.},; /* 4 */
                       {"От тарификации с учетом табеля",.T.},; /* 5 */
                       {"От суммы по виду оплаты",       .T.},; /* 6 */
                       {"От базовой ставки",             .T.},; /* 7 */
                       {"От ставки",                     .T.},; /* 8 */
                       {"По методу расчета" ,            .T.},; /* 9 */
                       {"От одной ставки",               .T.}}  /* 10*/
    LOCAL nI

    DEFAULT nMode IS 0

    IF nMode == 0 .AND. !EMPTY(FIELDPOS("SUM")) .AND. "%" $ FIELD->SUM
        aArrType[2][2]  := .F.
        aArrType[3][2]  := .F.
    ENDIF

    IF !EMPTY(lSay) .AND. nType < LEN(aArrType)
        RETURN aArrType[nType+1][1]
    ENDIF

    IF EMPTY( nI := SprSelect( aArrType,,,,,"Процент от..." ) )
        RETURN {nType, nMode}
    ENDIF
    IF ( nI==2 .OR. nI==3 ) .AND. nMode == 1
        nMode := 1
    ENDIF

    RETURN {nI-1, nMode}


*------------------------------------------------------*
*   Начисление или удержание группе сотрудников

    PROCEDURE WagePayList()
*------------------------------------------------------*
    LOCAL cFileName := MEMVAR->LocalPath + "paylist.dbf"
    LOCAL cDescName := MEMVAR->ModSysPath + "paylist.dsc"
    LOCAL lMarked   := WAGES->( IsMarked() )
    LOCAL oErr
    LOCAL nPersonCount := 0
    LOCAL xVar
    LOCAL aPayI     := {}
    LOCAL aDay      := {}
    LOCAL nP
    LOCAL aPost
    LOCAL aPostStr  := {}
    LOCAL nPostSelect
    LOCAL cTemp, nNalog
    LOCAL cDacc
    LOCAL nWorkProcTime := 1
    LOCAL cMetods, bBlock, nResult, aParam, lOne
    LOCAL nRecnoBefore, cErrorMsg
    LOCAL oLog
    LOCAL lHasFinalSheet := .F., lIncorrectAcc:=.F.
    LOCAL cMsg
    LOCAL cPost, nI, nStart, nEnd
    LOCAL nBase := 0, nPercent := 100, nTax
    LOCAL aScopeCALCS, aScopeJOBTB, aScopeTARIF, aScopeTRREC
    LOCAL oAcc
    LOCAL dDate := MEMVAR->DATE
    LOCAL oWagesTable, oWages
    LOCAL oJobtbTable, oJobtb
    LOCAL cJobtbAlias
    LOCAL oXLSLog := XlsLog():new( NIL, NIL, "Начисление/удержание группе сотрудников" )
    LOCAL lNeedShowXLS := .F.
    LOCAL lUseDate
    LOCAL oPost
    LOCAL xTmp,xTarif
    LOCAL cWagesAlias := "WAGES"      //если разносим процентами от сумм за другой период, ;
    LOCAL cCalcsAlias := "CALCS"      //инитим базы под этими алиасами
    LOCAL cMode := WAGES->(SaveScope())[OrdNumber()][1] //штатники/нештатники/физлица
    LOCAL aTemp
    LOCAL cKey
    LOCAL nMode
    LOCAL nSum, cSumtype, cParam
    LOCAL nFullSum

    LOCAL lUseTabel := .T.

    LOCAL lUseProportion := .T.
    LOCAL aDacc
    LOCAL nAllSum

    LOCAL ohRecNo := Hash():new()

    LOCAL lUpDate

    LOCAL ohWageLine

    LOCAL ohParams := HashIVar():new()

    LOCAL nTMessage

    PARAMETERS npMode
    PRIVATE xDialogReturn

    IF WagesClose()
        RETURN
    ENDIF

    SaveSet()
    aScopeCALCS:=CALCS->(Savescope())
    aScopeJOBTB:=JOBTB->(Savescope())
    aScopeTARIF:=TARIF->(Savescope())
    aScopeTRREC:=TRREC->(Savescope())

    BEGIN SEQUENCE

        IF VALTYPE(cMode)=="C"
            cMode := SUBSTR(cMode,1,2)
        ELSE
            cMode := "10"
        ENDIF

        oXLSLog:AddCaption( "WARNING", "Предупреждения" )

        // Начисление или удержание группе сотрудников
        xDialogReturn := CdDialog( "PAYLD",,;
            IF( npMode = 0, "Удаление начисления или удержания группе сотрудников",;
                "Добавление начисления или удержания группе сотрудников" ),,,,,{"Помощь;Help('PAYLD')",,,,,,,,"Кальк.;Calculator()"} )

        IF VALTYPE( xDialogReturn ) <> "A"
            BREAK
        ENDIF

        //  xDialogReturn[ 1 ] - Начисление или удержание или выплата
        //  xDialogReturn[ 2 ] - Вид оплаты
        //  xDialogReturn[ 3 ] - КСГУ
        //  xDialogReturn[ 4 ] - Описание
        //  xDialogReturn[ 5 ] - Сумма          // Символьный вид
        //  xDialogReturn[ 6 ] - Тип суммы      // 0-от начислено, 1-от на руки, 2-от остатка на руки, 3-таблица входимости, 4-сумма по тарифу
        //  xDialogReturn[ 7 ] - тип сортировки .T. - по фамилии .F. - по рангу
        //  xDialogReturn[ 8 ] - уменьшить на сумму налога пропорционально
        //  xDialogReturn[ 9 ] - расчет суммы с учетом табеля
        //  xDialogReturn[ 10 ] - КБК        Если не указаны, берутся по умолчанию
        //  xDialogReturn[ 11 ] - Вид деят.
        //  xDialogReturn[ 12 ] - разноска по всем должностям / по главной долж./по сотруднику
        //  xDialogReturn[ 13 ] - По данным заработной платы на дату
        //  xDialogReturn[ 14 ] - распределять пропорционально счетам начисления

        IF !EMPTY(xDialogReturn[13]) .AND. "%" $ xDialogReturn[ 5 ] .AND. ;
                !(xDialogReturn[ 6 ] $ {5,7,8,10})  //От тарификации с учетом табеля,от базовой ставки,от ставки,От одной ставки
            dDate := xDialogReturn[13]  //иначе MEMVAR->DATE
        ENDIF

        cMetods := EXTRACT( "", "VAL", MEMVAR->SprPath + "pymnt.dbf",  "COUNTALL", { "CODE", xDialogReturn[ 2 ] } )
        lOne    := .F.

        lUseDate := "%"$ xDialogReturn[ 5 ]
        lUseProportion := xDialogReturn[ 14 ] .AND. lUseDate
        lUseTabel := xDialogReturn[ 9 ] .AND. lUseDate
        IF xDialogReturn[ 6 ] = 5
            lUseTabel := .T.
        ENDIF

        aParam := {}
        // берем все выплаты по группе разовые по табелю  (BOR)
        aPayI := EXTRACT( {}, "ARR", MEMVAR->SprPath+"pymnt.dbf", "CODE", {"GROUP", "21", "21" } )

        // Добавление начисления или удержания
        IF npMode = 1

            DBSELECTAREA("JOBTB")
            JOBTB->( SaveSet() )
            DB_SETORDER("ANYPOST")

            // Создание временного файла
            IF ! DTCreate( cFileName, "PAYLIST",,cDescName )
                BREAK
            ENDIF

            nTMessage := 0
            // Заполним суммы во временный файл
            BeginStatus()
            SELECT WAGES //здесь следует оставить оригинальный алиас (бежим по исходной таблице)
            GO TOP

            DO WHILE ! EOF()
                IF IF( lMarked, MARKED(), .T. ) .AND. !WAGES->LOCKED

                    SayStatus( "Подготовка списка сотрудников;" + SayFio( .T. ) )

                    nWorkProcTime := 1
                    // разовые по табелю
                    xTmp:=EXTRACT( {}, "ARR", MEMVAR->SprPath + "pymnt.dbf", "CODE", { "GROUP", "21", "21" } )

                    ohWageLine := ReadRecordToHash( "WAGES", HashIVar():new() )

                    IF WAGES->TYPE == 10 //штатные сотрудники
                        // список исполняемых должностей данным сотрудником
                        aPost := EXTRACT( {}, "ARR", FILE_NAME("JOBTB", MEMVAR->ENT,, MEMVAR->YEAR), "POST", {"CODE", DTOS(BOM(dDate)) + WAGES->CODE + WAGES->JOBSCODE } )

                        IF xDialogReturn[2] $ xTmp
                            xTarif := EXTRACT( {}, "ARR", FILE_NAME("JOBTB", MEMVAR->ENT,, MEMVAR->YEAR), "TARIFCODE", {"CODE", DTOS(BOM(dDate)) + WAGES->CODE + WAGES->JOBSCODE } )
                            IF !EMPTY(xTarif)
                                xTarif:= AllTrim(xTarif[1])
                                aPost := EXTRACT( {}, "ARR", FILE_NAME("TRREC", MEMVAR->ENT), "POSTCODE", {"TARIFCODE", WAGES->CODE+xTarif, WAGES->CODE+xTarif} )
                            ENDIF
                        ENDIF

                        //группировка по долностям
                        aTemp := {}
                        AEVAL(aPost, {|x| IF (ASCAN(aTemp, x) == 0, AADD(aTemp,x),NIL)})
                        aPost := aTemp
                    ENDIF
                      // учет должностей или разносим разовые по табелю         и       тип - штатные сотрудники
                    IF WAGES->TYPE == 10 .AND. xDialogReturn[ 12 ] > 0
                        //проходимся по всем должностям
                        nStart  := 1
                        nEnd    := LEN(aPost)
                    ELSE
                        //берем главную должность
                        nStart  := 1
                        nEnd    := 1
                        aPost := { WAGES->MAINPOST }
                    ENDIF

                    FOR nI := nStart TO nEnd
                        cPost := aPost[ nI ]

                        /********************************************************************/
                        //                          АНАЛИЗ ТАБЕЛЯ
                        /********************************************************************/
                        oJobtb := NIL
                        oWages := NIL
                        // используется процент, значит - это часть от чего-то и указанная дата - не текущий месяц
                        IF lUseDate .AND. BOM(dDate) != BOM(MEMVAR->DATE)
                            //достаем запись о начислениях/удержаниях с прошлого месяца
                            oWagesTable := DBTable():new()
                            SaveSet()
                            IF MEMVAR->opUT:select( { "WAGES", MEMVAR->ENT,, YEAR( dDate ) }, @cWagesAlias )
                                IF !oWagesTable:Load( cWagesAlias, {"DATE", ;
                                    LEFT(DTOS(dDate),6) + "01" + ohWageLine:Code + ohWageLine:JobsCode, ;
                                    LEFT(DTOS(dDate),6) + "01" + ohWageLine:Code + ohWageLine:JobsCode} ) .OR. EMPTY(oWagesTable:rows)
                                    //если в прошлом месяце нет записей, то используем текущую
                                    oXLSLog:AddMessage( "WARNING", "Не удалось загрузить данные по заработной плате для " + SayFio(,ohWageLine:Code) + ;
                                        " за " + SayDate(dDate,"MMMММ YYYY г." ) + ;
                                        ". Будут использованы данные за текущий месяц" )

                                    lNeedShowXLS := .T.
                                    oWages := HashIVar():new()
                                    ReadRecordToHash(cWagesAlias, oWages)
                                ELSE
                                    oWages := oWagesTable:rows[1]
                                ENDIF
                            ELSE
                                //если в прошлом месяце нет записей, то используем текущую
                                oXLSLog:AddMessage( "WARNING", "Не удалось загрузить данные по заработной плате для " + SayFio(,ohWageLine:Code) + ;
                                    " за " + SayDate( dDate, "MMMММ YYYY г." ) + ;
                                    ". Будут использованы данные за текущий месяц" )

                                lNeedShowXLS := .T.
                                oWages := HashIVar():new()
                                ReadRecordToHash( cWagesAlias, oWages )
                            ENDIF
                            //инит Вагеса и Калкса за другой период (для расчета сумм отдельно по долностям)
                            IF ! MEMVAR->opUT:select( { "WAGES", MEMVAR->ENT,, YEAR( dDate ) }, @cWagesAlias ) .OR. ;
                                ! MEMVAR->opUT:select( { "CALCS", MEMVAR->ENT,, YEAR( dDate ) }, @cCalcsAlias )
                                IF !lNeedShowXLS
                                    oXLSLog:AddMessage( "WARNING", "Не удалось загрузить данные по заработной плате для " + SayFio(NIL,ohWageLine:Code) + ;
                                        " за " + SayDate( dDate, "MMMММ YYYY г." ) + ;
                                        ". Будут использованы данные за текущий месяц" )
                                    lNeedShowXLS := .T.
                                ENDIF
                                cWagesAlias := "WAGES"
                                cCalcsAlias := "CALCS"

                                DBSELECTAREA( cWagesAlias )
                            ELSE
                                DBSELECTAREA( cWagesAlias )
                                DB_SETORDER("CODE")
                                ORDSCOPE(0,cMode+LEFT(DTOS(dDate),6))
                                ORDSCOPE(1,cMode+LEFT(DTOS(dDate),6))
                                DBGOTOP()
                                IF !DBSEEK(cMode+LEFT(DTOS(dDate),6)+"01" + ohWageLine:Code + ohWageLine:JobsCode)
                                    IF !lNeedShowXLS
                                        //сотрудник может отсутствовать в другом периоде зп
                                        oXLSLog:AddMessage( "WARNING", "Не удалось загрузить данные по заработной плате для " + SayFio(,ohWageLine:Code) + ;
                                            " за " + SayDate( dDate, "MMMММ YYYY г." ) + ;
                                            ". Будут использованы данные за текущий месяц" )
                                        lNeedShowXLS := .T.
                                    ENDIF
                                    cWagesAlias := "WAGES"
                                    cCalcsAlias := "CALCS"
                                ENDIF
                            ENDIF
                            IF ohWageLine:TYPE == 10
                                //получение табеля из прошлого месяца
                                oJobtbTable := DBTable():new()
                                IF MEMVAR->opUT:select( { "JOBTB", MEMVAR->ENT,, YEAR( dDate ) }, @cJobtbAlias )
                                    IF oJobtbTable:Load( cJobtbAlias, {"ANYPOST", ;
                                        LEFT(DTOS(BOM(dDate)),6) + "01" + ohWageLine:Code + ohWageLine:JobsCode + cPost, ;
                                        LEFT(DTOS(BOM(dDate)),6) + "01" + ohWageLine:Code + ohWageLine:JobsCode + cPost} ) .AND. ;
                                        !EMPTY(oJobtbTable:rows)
                                        oJobtb := oJobtbTable:rows[1]
                                    ELSE
                                        //при ошибки в табеле
                                        oXLSLog:AddMessage( "WARNING", "Не удалось загрузить данные по табелю для " + SayFio(NIL,ohWageLine:Code) + ;
                                            "за " + SayDate( dDate, "MMMММ YYYY г." ) + ;
                                            ". Будут использованы данные за текущий месяц" )
                                        lNeedShowXLS := .T.
                                        oJobtbTable := DBTable():new()
                                        IF oJobtbTable:Load( cJobtbAlias, {"ANYPOST", ;
                                            LEFT(DTOS(BOM(MEMVAR->DATE)),6) + "01" + ohWageLine:Code + ohWageLine:JobsCode + cPost, ;
                                            LEFT(DTOS(BOM(MEMVAR->DATE)),6) + "01" + ohWageLine:Code + ohWageLine:JobsCode + cPost} ) .AND. ;
                                            !EMPTY(oJobtbTable:rows)
                                            oJobtb := oJobtbTable:rows[1]
                                        ENDIF
                                    ENDIF
                                ENDIF
                            ENDIF
                            RestSet()
                        ELSE
                            // не процент или текущая дата
                            oWages := HashIVar():new()
                            ReadRecordToHash(cWagesAlias, oWages)
                            IF ohWageLine:TYPE == 10
                                IF JOBTB->( DBSEEK( DTOS( BOM( ohWageLine:Month ) ) + ohWageLine:Code + ohWageLine:JobsCode + cPost ) )
                                    oJobtb := HashIVar():new()
                                    ReadRecordToHash("JOBTB", oJobtb)
                                ENDIF
                            ENDIF
                        ENDIF
                        DBSELECTAREA(cWagesAlias)
                        oPost := WageMethods():New()
                        oPost:cCalcsAlias := cCalcsAlias
                        oPost:cWagesAlias := cWagesAlias
                        IF ohWageLine:TYPE == 10 .AND. oJobtb != NIL

                            // штатные сотрудники и табель загружен
                            IF lUseTabel //xDialogReturn[ 9 ]
                                // расчет с учетом табеля
                                IF oJobtb:get("LDAY")  //если работает по часам
                                    nWorkProcTime := D( oJobtb:get("WRKDHOURS"), oJobtb:get("NORMHOURS") )
                                ELSE
                                    nWorkProcTime := D( oJobtb:get("WRKDDAYS"), oJobtb:get("NORMDAYS") )
                                ENDIF
                            ENDIF
                        ENDIF

                        /*************************************************************/
                        //                      ПОДГОТОВКА СУММ
                        /*************************************************************/

                        IF lUseProportion
                            ohParams:WagesAlias := cWagesAlias
                            ohParams:CalcsAlias := cCalcsAlias
                            ohParams:oWages     := oWages
                            // использовать разбивку по счетам
                            aDacc := GetWageSumByAcc( .F., ; // 1 только не выплаченные
                                                      NIL, ; // 2 вид оплаты (если по одному)
                                                      NIL, ; // 3 какую группу исключить
                                                      NIL, ; // 4 учитывать ли аналитику
                                                      .T., ; // 5 учитывать ли должности
                                                      NIL, ; // 6 выделять перечисления в удержаниях
                                                      NIL, ; // 7 детализация начислений и удержаний
                                                      NIL, ; // 8 приводить к данной корреспонденции, а потом группировать
                                                      .T., ; // 9 учитывать аналитику
                                                      NIL, ; // 10 уменьшать на сумму долга за предприятием
                                                  ohParams ) // 11 алиасы калксов и вагесов
                        ELSE
                            // без разбивки
                            //              1  2         3          4    5    6
                            aDacc := { { { "", 1, WAGES->MAINPOST, NIL, NIL, NIL } } }
                        ENDIF

                        cSumtype    := ""
                        cParam      := ""
                        nBase       := 0
                        nPercent    := 0
                        nSum        := 0

                        // Процент от "итого начислено"
                        IF lUseDate
                            nPercent := VAL( xDialogReturn[ 5 ] )

                            // От Начислено
                            IF xDialogReturn[ 6 ] = 0
                                    // не распределять по счетам
                                    IF ohWageLine:TYPE == 10
                                        // если типы физлиц - штатные, респределяем по должностям
                                        oPost:Load( dDate,oWages:CODE,oWages:RecCode,10,10)  //по тарифу
                                        oPost:GroupBy( "post" )
                                        nBase := oPost:stats:Get(cPost,0)
                                        oPost:Load( dDate,oWages:CODE,oWages:RecCode,20,30)  //начисления
                                        oPost:GroupBy( "post" )
                                        nBase += oPost:stats:Get(cPost,0)
                                        nSum := nBase * nPercent * nWorkProcTime / 100
                                    ELSE
                                        // просто сумма
                                        nBase := oWages:get("SUM",0)
                                        nSum    := nBase * nPercent / 100
                                    ENDIF

                            //От общей суммы к выплате
                            ELSEIF xDialogReturn[ 6 ] = 1
                                oPost:Load( dDate,oWages:CODE,oWages:RecCode,10,10)  //по тарифу
                                oPost:GroupBy( "post" )

                                nBase := oPost:stats:Get(cPost,0)

                                oPost:Load( dDate,oWages:CODE,oWages:RecCode,20,30)  //начисления
                                oPost:GroupBy( "post" )

                                nBase += oPost:stats:Get(cPost,0)

                                oPost:Load( dDate,oWages:CODE,oWages:RecCode,40,50)  //удержания
                                oPost:GroupBy( "post" )

                                nBase -= oPost:stats:Get(cPost,0)
                                nBase += EXTRACT( 0, "SUM", "CALCS", "SUMMA", { "CODE",  DTOS( WAGES->MONTH ) + WAGES->CODE + WAGES->RECCODE + "50" + cPost + "80" } )

                                nSum  := nBase * nPercent / 100
                            //От остатка к получению
                            ELSEIF xDialogReturn[ 6 ] = 2
                                IF nI = 1
                                    nBase           := oWages:get("RESTBYHAND",0) * nWorkProcTime
                                    nSum    := nBase * nPercent / 100
                                ENDIF
                            // По таблице входимости
                            ELSEIF xDialogReturn[ 6 ] = 3
                                nBase           := SumByEntry( xDialogReturn[ 2 ], dDate,,,,,cPost ) * nWorkProcTime
                                nSum    := nBase * nPercent / 100

                            // От суммы по тарифу
                            ELSEIF xDialogReturn[ 6 ] = 4
                                oPost:Load(dDate,oWages:CODE,oWages:RecCode,10,10)  //по тарифу
                                oPost:GroupBy( "post" )
                                nBase := oPost:stats:Get(cPost,0)
                                nSum := nBase * nPercent * nWorkProcTime / 100

                            //От тарификации с учетом табеля
                            ELSEIF xDialogReturn[ 6 ] = 5 .AND. ohWageLine:TYPE == 10
                                xVar := {0,,0}

                                //если отработал больше половины дней
                                IF oJobtb != NIL .AND. ( (!oJobtb:get("LDAY") .AND. oJobtb:get("WRKDDAYS") > ( oJobtb:get("NORMDAYS") *0.8 ) ) .OR.;
                                         ( oJobtb:get("LDAY") .AND. oJobtb:get("WRKDHOURS") > ( oJobtb:get("NORMHOURS")*0.8 ) ) )
                                    SaveSet()

                                    SELECT TARIF
                                    SaveSet()
                                    DB_SETORDER("TARIFDATE")
                                    ORDSCOPE(0, ohWageLine:Code + ohWageLine:JobsCode )
                                    ORDSCOPE(1, ohWageLine:Code + ohWageLine:JobsCode )
                                    DBGOTOP()
                                    DO WHILE !EOF()
                                        IF EOM(dDate) > FIELD->TARIFDATE
                                            EXIT
                                        ENDIF
                                        SKIP
                                    ENDDO
                                    //Fix by dev-kamashev (30.01.09): добавлен цикл по TRREC для сбора инфы по дожностям
                                    SELECT TRREC
                                    SaveSet()
                                    DB_SETORDER("TARIFPOST")
                                    ORDSCOPE(0,TARIF->TARIFCODE+cPost)
                                    ORDSCOPE(1,TARIF->TARIFCODE+cPost)
                                    DBGOTOP()
                                    WHILE !EOF()
                                        xVar[ 3 ] += FIELD->TARIFSUM
                                        D_SKIP()
                                    ENDDO
                                    RestSet()
                                    TRREC->(RestScope(aScopeTRREC))
                                    TARIF->(RestScope(aScopeTARIF))

                                    RestSet()
                                    RestSet()
                                    nBase               := xVar[ 3 ] * nWorkProcTime

                                    nSum        := nBase * nPercent / 100
                                ENDIF

                            //  от суммы по виду оплаты
                            ELSEIF xDialogReturn[ 6 ] = 6
                                IF ohWageLine:TYPE == 10
                                    cKey := ohWageLine:Code + ohWageLine:JobsCode + DTOS(BOM(dDate))+cPost
                                ELSE
                                    cKey := ohWageLine:Code + ohWageLine:JobsCode + DTOS(BOM(dDate))
                                ENDIF

                                nBase  := Extract(0,"SUM",cCalcsAlias,"SUMMA", ;
                                    { "AVERAGE", cKey, cKey,;
                                    "FIELD->PAYTYPE=='"+xDialogReturn[2]+"'"})  * nWorkProcTime

                                nSum := nBase * nPercent / 100

                            //  расчет от базовой ставки или ставки
                            ELSEIF (xDialogReturn[ 6 ] = 7 .OR. xDialogReturn[ 6 ] = 8) .AND. ohWageLine:Type == 10
                                xVar := 0
                                SaveSet()
                                SELECT TARIF
                                SaveSet()
                                SKIP 0
                                DO WHILE !EOF() .AND. (FIELD->CODE==ohWageLine:Code .AND. FIELD->JOBSCODE==ohWageLine:JobsCode) .AND.;
                                            EOM(dDate) > FIELD->TARIFDATE
                                    IF xDialogReturn[ 12 ] > 0 //по всем должностям
                                        xVar := Extract(0, "VAL", "TRREC", IF(xDialogReturn[ 6 ] = 7,"BSTAV","STAV"), ;
                                            {"TARIFPOST", FIELD->TARIFCODE+cPost} )
                                    ELSE
                                        xVar := Extract(0, "VAL", "TRREC", IF(xDialogReturn[ 6 ] = 7,"BSTAV","STAV"), ;
                                            {"TARIFCODE", FIELD->CODE + FIELD->TARIFCODE + "0"} )
                                    ENDIF
                                    SKIP
                                ENDDO
                                RestSet()
                                RestSet()
                                nBase           := xVar * nWorkProcTime
                                nSum    := nBase * nPercent / 100

                            //  по методу расчета
                            ELSEIF xDialogReturn[ 6 ] = 9 .AND. ohWageLine:Type == 10
                                IF EMPTY( cMetods )
                                    nSum    := VAL( xDialogReturn[ 5 ] ) * nWorkProcTime
                                    nBase           := nWorkProcTime * 100
                                ELSE
                                    IF CompileCode( ALLTRIM( cMetods ), @bBlock )
                                        IF ExecuteCode( bBlock, @nResult, VAL( xDialogReturn[ 5 ] ), lOne, nResult, xDialogReturn[ 2 ], xDialogReturn, cPost )
                                            nSum        := nResult[ 3 ]
                                            cSumtype    := nResult[ 1 ]
                                            cParam      := nResult[ 2 ]
                                            nBase       := nResult[ 3 ]
                                            nPercent    := 100
                                        ELSE
                                            ALERT( "Ошибка выполнения выражения расчета;для вида оплаты " + '"' + xDialogReturn[ 2 ] + '"' )
                                        ENDIF
                                        lOne := .T.
                                    ELSE
                                        ALERT( "Ошибка компиляции выражения расчета;для вида оплаты " + '"' +  xDialogReturn[ 2 ] + '"' )
                                    ENDIF
                                ENDIF

                            //От одной ставки
                            ELSEIF xDialogReturn[ 6 ] = 10 .AND. ohWageLine:Type == 10
                                xVar := 0
                                SaveSet()
                                SELECT TARIF
                                SaveSet()
                                SKIP 0
                                DO WHILE !EOF() .AND. (FIELD->CODE==ohWageLine:CODE .AND. FIELD->JOBSCODE==ohWageLine:JOBSCODE) .AND.;
                                            EOM(dDate) > FIELD->TARIFDATE
                                    IF xDialogReturn[ 12 ] > 0 //по всем должностям
                                        xVar := Extract({0,0}, "VAL", "TRREC",  "{STAV, KSTAV}", {"TARIFPOST", ;
                                            FIELD->TARIFCODE+cPost} )
                                    ELSE //по главной должности
                                        xVar := Extract({0,0}, "VAL", "TRREC",  "{STAV, KSTAV}", {"TARIFCODE", ;
                                            FIELD->CODE+FIELD->TARIFCODE+"0"} )
                                    ENDIF
                                    SKIP
                                ENDDO
                                RestSet()
                                RestSet()
                                nBase           := D(xVar[1] * nWorkProcTime, IF(EMPTY(xVar[2]),1,xVar[2]))
                                nSum    := nBase * nPercent / 100
                            ENDIF

                        // Сумма
                        ELSE

                            nSum := VAL( xDialogReturn[ 5 ] ) * nWorkProcTime
                            nBase        := nSum
                            nPercent     := 100
                        ENDIF

                        IF xDialogReturn[ 8 ] .AND. xDialogReturn[ 1 ] = 1
                        // Уменьшить на сумму налога
                            DBSELECTAREA(cCalcsAlias)
                            DB_SETORDER( "CODE" )
                            SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + ohWageLine:CODE + ohWageLine:RECCODE
                            GO TOP
                            nNalog := 0
                            DO WHILE !EOF()
                                IF ALLTRIM(FIELD->PAYTYPE) == asType[1]
                                    nNalog += FIELD->SUMMA
                                ENDIF
                                SKIP
                            ENDDO
                            DBSELECTAREA(cWagesAlias)
                            nTax := nNalog * D( nSum, ohWageLine:SUM )
                            IF nTax > 0
                                nSum -= nTax
                                nBase -= nTax * 100 / nPercent
                            ENDIF
                        ENDIF


                        //добавление/редактирование строки в PAYLIST
                        IF nI == nStart .OR. xDialogReturn[ 12 ] == 1 //по всем должностям
                            //если суммы достаются по сотруднику, то запись добавляется 1 раз
                            PAYLIST->( DBAPPEND() )
                            PAYLIST->CODE     := ohWageLine:CODE
                            PAYLIST->JOBSCODE := ohWageLine:JOBSCODE
                            PAYLIST->SURNAME  := ohWageLine:SURNAME

                            IF xDialogReturn[ 12 ] == 2 //по сотруднику
                                PAYLIST->POSTCODE := ohWageLine:MAINPOST
                            ELSE
                                PAYLIST->POSTCODE := cPost
                            ENDIF

                            PAYLIST->SUMTYPE    := cSumType
                            PAYLIST->PARAM      := cParam

                            PAYLIST->DACC     := xDialogReturn[ 3 ]   // Счет
                            PAYLIST->NOTE     := xDialogReturn[ 4 ]   // Примечание
                            PAYLIST->SUM      := 0
                            PAYLIST->SUM0     := 0

                            ohRecNo:put( STRZERO( PAYLIST->( RECNO() ), 12 ), aDacc )

                        ELSEIF xDialogReturn[ 12 ] == 2 .AND. nI > nStart
                            IF !PAYLIST->( ReferLock() )
                                EXIT
                            ENDIF
                        ENDIF

                        IF EMPTY(nSum)
                            nSum := 0
                        ENDIF
                        PAYLIST->SUM      += nSum
                        PAYLIST->SUM0     += nBase
                        PAYLIST->PERCENT  := nPercent

                        IF xDialogReturn[ 12 ] == 2 .AND. nI > nStart    //по сотруднику
                            PAYLIST->( UN_LOCK() )
                        ENDIF

                        IF !EMPTY(SELECT("WAGESTEMP"))
                            DBCLOSE("WAGESTEMP")
                            cWagesAlias := "WAGES"
                        ENDIF
                        IF !EMPTY(SELECT("CALCSTEMP"))
                            DBCLOSE("CALCSTEMP")
                            cCalcsAlias := "CALCS"
                        ENDIF
                    NEXT nI

                ENDIF
                SELECT WAGES
                SKIP
            ENDDO

            TARIF->(RestScope( aScopeTARIF ))
            TRREC->(RestScope( aScopeTRREC ))
            JOBTB->( RestSet() )

            EndStatus()

            IF lNeedShowXLS .AND. ALERT( "!При формировании списка на добавление " + IF( xDialogReturn[ 1 ]=0, "начисления", IF( xDialogReturn[ 1 ]=1, "удержания", "выплаты" ) ) + " были обнаружены замечания. Просмотреть лог?", { "Да", "Нет" } ) = 1
                oXLSLog:Save()
                oXLSLog:Show()
            ENDIF

            IF xDialogReturn[7]
                DBSELECTAREA("PAYLIST")
                DB_SETORDER("SURNAME")
                SET SCOPE TO
            ENDIF

            // Просмотр списка сотрудников с суммами напротив
            WindOpen( "PayListWind",,"Добавление " + IF( xDialogReturn[ 1 ]=0, "начисления", IF( xDialogReturn[ 1 ]=1, "удержания", "выплаты" ) ) + " '" + xDialogReturn[ 2 ] + "'" )
            SetFKey({"Помощь;Help('PAYLD')",,,,;
                     "Округл./Округление; MacroRun( ModMacPath + 'WAGEROUND.MAC'),ExecuteAutoBlock(MEMVAR->aField,.F.),RefreshAll()",,,,;
                     "Кальк.;Calculator()"})

            BROWSE FILE  cFileName;
            DESCRIPTION  cDescName;
            ALIAS        "PAYLIST";
            FREEZE       1;
            WINDINFO     ( { {|| "Нажмите <ESC> для регистрации "+IF( xDialogReturn[ 1 ]=0, "начислений", IF( xDialogReturn[ 1 ]=1, "удержаний", "выплат" ) ) } } );
            MODE         TB_PART_MODE;
            OPENLY;
            SUM

            RestFKey()
            WindClose()

            IF MALERT( "Произвести регистрацию "+IF( xDialogReturn[ 1 ]=0, "начислений?", IF( xDialogReturn[ 1 ]=1, "удержаний?", "выплат?" ) ),;
                { "Провести", "Отказ" } ) <> 1
                BREAK
            ENDIF

            SELECT PAYLIST
            DB_SETORDER( "JOBSCODE" )

            SELECT PYMNT
            DB_SETORDER( "CODE" )
        ENDIF

        oLog := XLSLog():new("ProcessPayList", "temp", "Отчет о разноске начислений и удержаний",.T.)
        oLog:ADDCaption( "error", "ОШИБКИ ПРИ РАЗНОСКЕ НАЧИСЛЕНИЙ УДЕРЖАНИЙ" )

        BeginStatus()

        SELECT WAGES
        GO TOP
        DO WHILE ! EOF()

            // Добавление начисления или удержания
            IF npMode = 1

                DBSELECTAREA("PAYLIST")
                ORDSCOPE(0, WAGES->JOBSCODE)
                ORDSCOPE(1, WAGES->JOBSCODE)
                DBGOTOP()

                WHILE !EOF()
                    // Если по сотруднику есть сумма
                    IF !EMPTY( PAYLIST->SUM )

                        SayStatus( "Регистрация "+IF( xDialogReturn[ 1 ]=0, "начисления", IF( xDialogReturn[ 1 ]=1, "удержания", "выплаты" ) )+";" + SayFio( .T. ) )
                        IF PYMNT->( DBSEEK( xDialogReturn[ 2 ] ) )
                            aDacc := ohRecNo:get( STRZERO( PAYLIST->( RECNO() ), 12 ) )
                            ++nPersonCount

                            lUpDate := .F.

                            nAllSum  := PAYLIST->SUM
                            nFullSum := 0

                            FOR nI := 1 TO LEN( aDacc[1] )

                                nRecnoBefore := RECNO()

                                CALCS->( SOFT_APPEND() )
                                CALCS->JOBSCODE := WAGES->JOBSCODE
                                CALCS->CODE     := WAGES->CODE
                                CALCS->MONTH    := BOM( MEMVAR->DATE )
                                CALCS->WAGESCODE:= WAGES->RECCODE
                                CALCS->RECCODE  := CALCS->( UQ_CODE() )
                                CALCS->PAYTYPE  := xDialogReturn[ 2 ]  // Вид оплаты
                                CALCS->COMMENT  := PAYLIST->NOTE
                                CALCS->POST     := PAYLIST->POSTCODE

                                // если выплата разовая по табелю
                                nP := ASCAN( aPayI, xDialogReturn[2] )
                                IF nP > 0
                                    CALCS->PARAM   := "/////////"+REMALL(STR( PAYLIST->SUM )) + "/" + PAYLIST->POSTCODE
                                ELSE
                                    CALCS->PARAM    := PAYLIST->PARAM
                                ENDIF
                                IF LEN( aDacc[1] ) > 1
                                    IF nI < LEN( aDacc[1] )
                                        nSum := ROUND( PAYLIST->SUM * aDacc[1][nI][7], 2 )
                                    ELSE
                                        nSum := nAllSum - nFullSum
                                    ENDIF
                                ELSE
                                    nSum := PAYLIST->SUM
                                ENDIF

                                nFullSum        += nSum
                                CALCS->SUMMA    := nSum
                                CALCS->SUMTYPE  := PAYLIST->SUMTYPE

                                // Начисление
                                IF xDialogReturn[ 1 ] = 0
                                    CALCS->MODE := 20 // Разовое начисление
                                ELSEIF xDialogReturn[ 1 ] = 1
                                    CALCS->MODE := 40 // Разовое удержание
                                ELSE
                                    CALCS->MODE := 60 // Выплата
                                ENDIF

                                oAcc := CalcsAccs():new()
                                oAcc:lIsPlus := ! ( xDialogReturn[ 1 ] > 0 )
                                IF ! oAcc:LoadFromPymnt( xDialogReturn[ 2 ], MEMVAR->ENT, PAYLIST->POSTCODE, WAGES->TYPE, @cErrorMsg )
                                    Message( "S" + cErrorMsg )
                                    BREAK
                                ENDIF

                                IF ! EMPTY( xDialogReturn[ 3 ] ) // принудительная попытка указать КоСГУ
                                    IF ! oAcc:PrepareWithKGU( xDialogReturn[ 3 ], xDialogReturn[ 2 ], @cErrorMsg )
                                        Message( "S" + cErrorMsg )
                                        BREAK
                                    ENDIF
                                ENDIF
                                IF ! aDacc[1][nI][4] == NIL
                                    oAcc:join( aDacc[1][nI][5] )
                                ENDIF

                                CALCS->( CalcsObjectToTable( oAcc ) )
                                IF ! EMPTY( xDialogReturn[10] )
                                    CALCS->DFKR := xDialogReturn[10]
                                ENDIF
                                IF ! EMPTY( xDialogReturn[11] )
                                    IF ! EMPTY( CALCS->DBACC )
                                        CALCS->DBACC := xDialogReturn[11] + SUBSTR( CALCS->DBACC, 2 )
                                    ENDIF
                                    IF ! EMPTY( CALCS->KACC  )
                                        CALCS->KACC  := xDialogReturn[11] + SUBSTR( CALCS->KACC,  2 )
                                    ENDIF
                                ENDIF

                                CALCS->PRIORITY := PYMNT->PRIORITY
                                CALCS->GROUP    := PYMNT->GROUP

                                SELECT CALCS
                                // проверить, а можно ли добавлять метод с такими параметрами
                                cErrorMsg := ""
                                cMsg := ""
                                IF (lHasFinalSheet := !CalcSheets():AllowCalcChange(.F.,@cMsg))==.T.

                                    SOFT_DELETE()

                                    IF EMPTY( cErrorMsg )
                                        IF lHasFinalSheet
                                            cErrorMsg := cMsg
                                        ENDIF
                                    ENDIF
                                    oLog:ADDMessage("error", {SayFIO(, WAGES->CODE), cErrorMsg} )

                                    DBGOTO( nRecnoBefore )
                                ELSE
                                    lUpDate := .T.
                                ENDIF
                            NEXT
                            IF lUpDate
                                SELECT WAGES
                                // Обновление автоначислений и автоудержаний
                                // Начисление
                                IF xDialogReturn[ 1 ] = 0
                                    SumByTarif( FIELD->TARIF, .F., { .F., .T., .T. } )
                                // Удержание
                                ELSEIF xDialogReturn[ 1 ] = 1
                                    SumByTarif( FIELD->TARIF, .F., { .F., .F., .T. } )
                                // Выплата
                                ELSEIF xDialogReturn[ 1 ] = 2
                                    SumByTarif( FIELD->TARIF, .F., { .F., .F., .F. } )
                                ENDIF

                                WAGES->( ExecuteAutoBlock( MEMVAR->aField, .F. ) )
                            ENDIF

                        ELSE
                            ALERT( "Вид оплаты не найден в справочнике" )
                            BREAK
                        ENDIF
                    ENDIF

                    DBSELECTAREA("PAYLIST")
                    D_SKIP()
                ENDDO

            // Удаление начисления или удержания
            ELSEIF IF( lMarked, MARKED(), .T. )

                SayStatus( "Удаление "+IF( xDialogReturn[ 1 ] = 0, "начисления", IF( xDialogReturn[ 1 ]= 1,"удержания", "выплаты" ) )+";" + SayFio( .T. ) )

                SELECT CALCS
                DB_SETORDER( "CODE" )
                SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE

                GO TOP

                DO WHILE ! EOF()
                    // Если вид оплаты подходит по маску
                    IF Mask_String( REMALL( CALCS->PAYTYPE ), REMALL( xDialogReturn[ 2 ] ) )
                        IF ! CalcSheets():CalcWasPayed(, .F. )
                            ++nPersonCount
                            SOFT_DELETE()
                            GO TOP
                        ELSEIF nTMessage <> 2
                            nTMessage := ALERT( '!Удаляемые Вами записи по заработной плате по сотруднику "' + ALLTRIM( SayFIO( .F., WAGES->CODE ) ) + ;
                                                '" включены в окончательную ведомость. Записи по данному сотруднику не будут удалены', ;
                                                { "Продолжить", "Игнорировать", "Отмена" } )
                            IF nTMessage = 3
                                BREAK
                            ENDIF
                            SKIP
                        ELSE
                            SKIP
                        ENDIF
                    ELSE
                        SKIP
                    ENDIF
                ENDDO

                SELECT WAGES
                // Обновление автоначислений и автоудержаний
                // Начисление
                IF xDialogReturn[ 1 ] = 0
                    SumByTarif( FIELD->TARIF, .F., { .F., .T., .T. } )
                // Удержание
                ELSEIF xDialogReturn[ 1 ] = 1
                    SumByTarif( FIELD->TARIF, .F., { .F., .F., .T. } )
                ELSE
                    SumByTarif( FIELD->TARIF, .F., { .F., .F., .F. } )
                ENDIF
                WAGES->( ExecuteAutoBlock( MEMVAR->aField, .F. ) )
            ENDIF

            SELECT WAGES
            SKIP
        ENDDO

        EndStatus()

        IF oLog:GetMessageCount()>0
            IF MALERT( "При разноске начислений и удержаний обнаружены ошибки", {"Просмотреть отчет","Продолжить"} ) == 1
                oLog:save()
                oLog:show()
            ENDIF
        ELSE
            IF nPersonCount > 0
                MALERT( "Изменения произведены;Обработано записей : " + XTOC( nPersonCount ) )
            ENDIF
        ENDIF

        // Пометка объекта зарплаты для обновления

    RECOVER USING oErr
        IF ! EMPTY( oErr )
            SayError( oErr )
        ENDIF

    END SEQUENCE

    DBCLOSE( "PAYLIST" )

    CALCS->(RestScope( aScopeCALCS ))
    JOBTB->(RestScope( aScopeJOBTB ))
    TARIF->(RestScope( aScopeTARIF ))
    TRREC->(RestScope( aScopeTRREC ))

    RestSet()

    RETURN            //НАЧ/УДЕРЖ ГРУППЕ

*------------------------------------------------------*
*   Начисление или удержание группе сотрудников

    FUNCTION GetWageIncome( x, cName )
*------------------------------------------------------*
    LOCAL aOutcome := x
    LOCAL aScope   := SaveScope()
    LOCAL nSum
    LOCAL cWagesCode

    SaveSet()

    IF SELECT("POSTS") = 0
        IF ! ReferInit( { "POSTS" } )
            RestSet()
            RestScope( aScope )
            RETURN( {} )
        ENDIF
    ENDIF
    SELECT POSTS
    DB_SETORDER( "CODE" )
    SET SCOPE TO

    SELECT WAGES
    SaveSet()

    DB_SETORDER( "CODE" )
    SET SCOPE TO

    aOutCome := {}

    PRIVATE oCalcsAcc

    IF MEMVAR->Month > 1
        cWagesCode := WAGES->MAINPOST
        IF DBSEEK( STRZERO( WAGES->TYPE, 2 ) + DTOS( BOM( ADDMONTH( MEMVAR->DATE, -1 ) ) ) + WAGES->CODE + WAGES->JOBSCODE )
            IF cName == "OUTCOME"
                nSum     := WAGES->OUTCOME
                aOutCome := Extract({},"ARR","OUTCM", { "DACC", "SUMMA", "POST", "FKR", "TYPE", ;
                                    "ZERO(oCalcsAcc := CalcsAcc():new(), oCalcsAcc:LoadDebetAcc( Alias() ), oCalcsAcc )" }, {"WAGESCODE", WAGES->RECCODE, WAGES->RECCODE }, .F. )
                IF EMPTY( aOutCome ) .AND. !EMPTY( nSum )
                    IF MEMVAR->npFacesType = 10
                        IF POSTS->( DBSEEK( WAGES->MAINPOST ) )

                            aOutCome := { { PADR( "01211 ", LEN_DESC_ACC ), nSum, WAGES->MAINPOST, POSTS->FKR + POSTS->REFBU, 0 } }
                        ELSE
                            ALERT( "Должность с кодом <" + WAGES->MAINPOST + ">;"+;
                                   "не найдена в справочнике должностей.;"+;
                                   "Будет использоваться главная текущего месяца" )
                            IF POSTS->( DBSEEK( cWagesCode ) )
                                aOutCome := { { PADR( "01211 ", LEN_DESC_ACC ), nSum, cWagesCode, POSTS->FKR + POSTS->REFBU, 0 } }
                            ELSE
                                ALERT( "Главная должность с кодом <" + cWagesCode + ">;"+;
                                       "не найдена в справочнике должностей.;"+;
                                       "Исправьте ситуацию (возможно расхождение сумм)" )
                            ENDIF
                        ENDIF
                    ELSE
                        aOutCome := { { PADR( "01211 ", LEN_DESC_ACC ), nSum, "", "", 0 } }
                    ENDIF
                ENDIF
            ELSE
                aOutCome := WAGES->&cName
            ENDIF
        ENDIF
    ELSE
        IF cName == "OUTCOME"
            cWagesCode := Extract( NIL, "VAL", File_Name( "WAGES", MEMVAR->Ent,, MEMVAR->Year - 1 ), { "RECCODE", "OUTCOME", "MAINPOST" }, ;
                          { "CODE", STRZERO( WAGES->TYPE, 2 ) + DTOS( BOM( ADDMONTH( MEMVAR->DATE, -1 ) ) ) + WAGES->CODE + WAGES->JOBSCODE }, .F. )
            IF !EMPTY( cWagesCode )
                aOutCome := Extract({},"ARR", File_Name( "OUTCM", MEMVAR->Ent,, MEMVAR->Year - 1 ),;
                            { "DACC", "SUMMA", "POST", "FKR", "TYPE", ;
                            "ZERO(oCalcsAcc := CalcsAcc():new(), oCalcsAcc:LoadDebetAcc( Alias() ), oCalcsAcc )" }, {"WAGESCODE", cWagesCode[ 1 ], cWagesCode[ 1 ] }, .F. )
                IF EMPTY( aOutCome ) .AND. !EMPTY( cWagesCode[ 2 ] )
                    IF MEMVAR->npFacesType = 10
                        IF POSTS->( DBSEEK( cWagesCode[ 3 ] ) )

                            aOutCome := { { PADR( "01211 ", LEN_DESC_ACC ), cWagesCode[ 2 ], cWagesCode[ 3 ], POSTS->FKR + POSTS->REFBU, 0 } }
                        ENDIF
                    ELSE
                        aOutCome := { { PADR( "01211 ", LEN_DESC_ACC ), cWagesCode[ 2 ], "", "", 0 } }
                    ENDIF
                ENDIF
            ENDIF
        ELSE
            aOutCome := Extract( x, "VAL", File_Name( "WAGES", MEMVAR->Ent,, MEMVAR->Year - 1 ), cName, ;
                          { "CODE", STRZERO( WAGES->TYPE, 2 ) + DTOS( BOM( ADDMONTH( MEMVAR->DATE, -1 ) ) ) + WAGES->CODE + WAGES->JOBSCODE }, .F. )
        ENDIF
    ENDIF

    RestSet()

    RestSet()
    RestScope( aScope )

    RETURN( aOutCome )


*------------------------------------------------------*
*   Вычисление суммы или формирование массива выплат, входящих в данный вид оплаты по таблице входимости

    FUNCTION SumByEntry( cPayType,;       //1: вид оплаты
                         dMonth,;         //2:  месяц, за который формировать сумму или массив
                         cJobsCode,;      //3:  JOBS код сотрудника
                         nType,;          //4:  0 - сумма, 1 - массив без группировки, 2 - массив с группировкой по счетам, должностям, 12 - массив без группировки, но с группой видов оплат
                         cWagesRecCode,;  //5:  WAGES код сотрудника
                         cSymbol,;        //6:  Признак для особой отметки должности (эти должности не включаются в результат)
                         cPost,;          //7:  Должность (если нет, то по всем)
                         cMode,;          //8:  режим (30 - только начисления, 50 - и начисления и удержания)
                         lCheckSheet,;    //9:  .T. - учитывать только те записи, по кот. не сформированы оконч. ведомости
                         lAccountPeriod,; //10: .T. - учитывать период, который указан в начислении
                         lRecalcIgnore )  //11: .T. - не включать суммы перерасчета
*------------------------------------------------------*
    LOCAL nSum := 0
    LOCAL aSum := {}
    LOCAL aSaveScope, aScope
    LOCAL nCount
    LOCAL cDacc
    LOCAL cPostUse
    LOCAL xTemp
    LOCAL lIsNalog
    LOCAL lRes
    LOCAL oCalcAcc
    LOCAL nHandle, nIndex, lMinus

    DEFAULT dMonth         IS MEMVAR->DATE
    DEFAULT cJobsCode      IS WAGES->JOBSCODE
    DEFAULT cWagesRecCode  IS ""
    DEFAULT nType          IS 0
    DEFAULT cSymbol        IS ""
    DEFAULT cMode          IS 30
    DEFAULT lCheckSheet    IS .F.
    DEFAULT lAccountPeriod IS .F.
    DEFAULT lRecalcIgnore  IS .T.

    SaveSet()
    aScope := Savescope()
    BEGIN SEQUENCE

    PYMNT->(DB_SETORDER("CODE"))

    IF !PYMNT->( DBSEEK( cPayType ) )
        ALERT("Вид оплаты с кодом '"+cPayType+"' не найден;"+;
              "в справочнике видов оплат. Восстановите информацию;"+;
              "о виде оплаты и попробуйте снова",{"Прервать"},,,,,,"I")
        BREAK
    ENDIF

    lIsNalog := ( PYMNT->GROUP == 60 )
    lMinus   := ( PYMNT->GROUP == 70 .OR. PYMNT->GROUP == 44 )

    IF ! EMPTY( cSymbol )
        ReferInit( { "POSTS" } )
        POSTS->( DB_SETORDER( "CODE" ) )
    ENDIF

    // Текущий год
    IF YEAR( dMonth ) == MEMVAR->YEAR

        SELECT ENTTB
        DB_SETORDER( "KEY" )
        SET SCOPE TO
        GO TOP

        SELECT CALCS

        // Сохраним установки
        aSaveScope := SaveScope()

        DB_SETORDER( "CODE" )
        SET SCOPE TO DTOS( BOM( dMonth ) ) + WAGES->CODE + cWagesRecCode
        GO TOP

        DO WHILE ! EOF()

            // Только по конкретному месту работы
            IF CALCS->JOBSCODE == cJobsCode .AND. ;
                ; //если lCheckSheet == .T. собираем только те выплаты, по кот. не сформированы оконч. ведомости
                ( (lCheckSheet .AND. ! CalcSheets():CalcWasPayed()) .OR. !lCheckSheet ) .AND. ;
                ( ! lRecalcIgnore .OR. EMPTY( CALCS->DATEPRODUC ) .OR. EMPTY( CALCS->FDATEREC ) )

                // Начисления
                IF CALCS->MODE >= 10 .AND. CALCS->MODE <= cMode
                    // Исключим записи по должностям, которые не нужны
                    IF EMPTY( cSymbol ) .OR. WAGES->TYPE <> 10 .OR. ! POSTS->( DBSEEK( CALCS->POST ) ) .OR.;
                        ( ! cSymbol $ POSTS->REMARK )

                        lRes := .T.
                        IF lAccountPeriod
                            //исключим суммы перерасчета, не относящиеся к указанному месяцу
                            IF !EMPTY(CALCS->DATEPRODUC) .AND. !EMPTY(CALCS->FDATEREC) //перерасчет
                                IF !(CALCS->DATEPRODUC <= EOM(dMonth) .AND. CALCS->FDATEREC >= BOM(dMonth))
                                    //не входит в текущий месяц
                                    lRes := .F.
                                ENDIF
                            ENDIF
                        ENDIF

                        IF lRes .AND. (EMPTY( cPost ) .OR. ( ! EMPTY( cPost ) .AND. CALCS->POST = cPost ))
                            IF WAGES->TYPE = 10
                                cPostUse := CALCS->POST
                            ELSE
                                cPostUse := SPACE( UQ_CodeLen() )
                            ENDIF

                            oCalcAcc := CalcsAccs():new()
                            oCalcAcc:lIsPlus := .T.
                            oCalcAcc:lMinus  := .F.

                            IF ! oCalcAcc:LoadFromCalcs()
                                BREAK
                            ENDIF
                            cDacc := oCalcAcc:cFullSeekValue

                            IF ! lIsNalog
                                // Найдем вид оплаты в таблице входимости
                                IF ENTTB->( DBSEEK( cPayType + CALCS->PAYTYPE ) )
                                    // Процент входимости не равен нулю
                                    IF ENTTB->PERCENT <> 0
                                        // Накопим сумму
                                        IF nType = 0
                                            nSum += IF( ENTTB->PERCENT < 0, D( 1, ABS(ENTTB->PERCENT) ), ENTTB->PERCENT/100 ) * CALCS->SUMMA
                                        ELSEIF nType = 1
                                            AADD( aSum, { CALCS->PAYTYPE, CALCS->COMMENT, CALCS->SUMMA, cPostUse, cDacc, CALCS->GROUP, CALCS->PARAM, oCalcAcc } )
                                        ELSEIF  nType = 12
                                            AADD( aSum, { CALCS->PAYTYPE, CALCS->COMMENT, CALCS->SUMMA, cPostUse, cDacc, CALCS->GROUP, CALCS->PARAM, oCalcAcc, CALCS->GROUP} )
                                        ELSEIF nType = 2
                                            IF ( nCount := ASCAN( aSum, {|x| x[4] == cPostUse .AND. x[5] == cDacc } ) ) = 0
                                                AADD( aSum, { CALCS->PAYTYPE, CALCS->COMMENT, CALCS->SUMMA, cPostUse, cDacc, CALCS->GROUP, CALCS->PARAM, oCalcAcc } )
                                            ELSE
                                                aSum[ nCount ][ 3 ] += CALCS->SUMMA
                                            ENDIF
                                        ENDIF
                                    ENDIF
                                ELSE
                                    // Накопим сумму
                                    IF nType = 0
                                        nSum += CALCS->SUMMA * GetEntryDefault( cPayType, CALCS->PAYTYPE ) / 100
                                    ELSEIF nType = 1
                                        AADD( aSum, { CALCS->PAYTYPE, CALCS->COMMENT, CALCS->SUMMA*GetEntryDefault( cPayType, CALCS->PAYTYPE ) / 100, cPostUse, cDacc, CALCS->GROUP, CALCS->PARAM, oCalcAcc } )
                                    ELSEIF nType = 12
                                        AADD( aSum, { CALCS->PAYTYPE, CALCS->COMMENT, CALCS->SUMMA*GetEntryDefault( cPayType, CALCS->PAYTYPE ) / 100, cPostUse, cDacc, CALCS->GROUP, CALCS->PARAM, oCalcAcc, CALCS->GROUP} )
                                    ELSEIF nType = 2
                                        IF ( nCount := ASCAN( aSum, {|x| x[4] == cPostUse .AND. x[5] == cDacc/* .AND. x[8] == xTemp[1] .AND. x[9] == xTemp[2]*/ } ) ) = 0
                                            AADD( aSum, { CALCS->PAYTYPE, CALCS->COMMENT, CALCS->SUMMA*GetEntryDefault( cPayType, CALCS->PAYTYPE ) / 100, cPostUse, cDacc, CALCS->GROUP, CALCS->PARAM, oCalcAcc } )
                                        ELSE
                                            aSum[ nCount ][ 3 ] += CALCS->SUMMA*GetEntryDefault( cPayType, CALCS->PAYTYPE ) / 100
                                        ENDIF
                                    ENDIF
                                ENDIF
                            ELSE
                                IF PYMNT->( DBSEEK( CALCS->PAYTYPE ) )
                                    // Процент входимости не равен нулю
                                    IF !EMPTY( PYMNT->GNI01 )
                                        // Накопим сумму
                                        IF nType = 0
                                            nSum += CALCS->SUMMA
                                        ELSEIF nType = 1
                                            AADD( aSum, { CALCS->PAYTYPE, CALCS->COMMENT, CALCS->SUMMA, cPostUse, cDacc, CALCS->GROUP, CALCS->PARAM, oCalcAcc } )
                                        ELSEIF nType = 12
                                            AADD( aSum, { CALCS->PAYTYPE, CALCS->COMMENT, CALCS->SUMMA, cPostUse, cDacc, CALCS->GROUP, CALCS->PARAM, oCalcAcc, CALCS->GROUP} )
                                        ELSEIF nType = 2
                                            IF ( nCount := ASCAN( aSum, {|x| x[4] == cPostUse .AND. x[5] == cDacc } ) ) = 0
                                                AADD( aSum, { CALCS->PAYTYPE, CALCS->COMMENT, CALCS->SUMMA, cPostUse, cDacc, CALCS->GROUP, CALCS->PARAM, oCalcAcc } )
                                            ELSE
                                                aSum[ nCount ][ 3 ] += CALCS->SUMMA
                                            ENDIF
                                        ENDIF
                                    ENDIF
                                ENDIF
                            ENDIF
                        ENDIF
                    ENDIF
                ENDIF

            ENDIF
            SKIP

        ENDDO

        // Восстановим установки
        RestScope( aSaveScope )
    ELSE

        SELECT ENTTB
        DB_SETORDER( "KEY" )
        SET SCOPE TO
        DBGOTOP()

        IF !DTOpen( File_Name( "CALCS", Ent,, Year( dMonth ) ), "LSCALCS", READ_ONLY )
            BREAK
        ENDIF

        SELECT LSCALCS

        DB_SETORDER( "CODE" )
        SET SCOPE TO DTOS( BOM( dMonth ) ) + WAGES->CODE + cWagesRecCode
        GO TOP
        DO WHILE ! EOF()
            // Только по конкретному месту работы
            IF LSCALCS->JOBSCODE == cJobsCode
                // Начисления
                IF LSCALCS->MODE >= 10 .AND. LSCALCS->MODE <= 30
                    //исключим суммы перерасчета, не относящиеся к указанному месяцу
                    lRes := .T.
                    IF !EMPTY(LSCALCS->DATEPRODUC) .AND. !EMPTY(LSCALCS->FDATEREC) //перерасчет
                        IF !(LSCALCS->DATEPRODUC <= EOM(dMonth) .AND. LSCALCS->FDATEREC >= BOM(dMonth))
                            //не входит в текущий месяц
                            lRes := .F.
                        ENDIF
                    ENDIF

                    // Исключим записи по должностям, кторорые не нужны
                    IF lRes .AND. ( EMPTY( cSymbol ) .OR. WAGES->TYPE <> 10 .OR. ! POSTS->( DBSEEK( LSCALCS->POST ) ) .OR.;
                        ( POSTS->( DBSEEK( LSCALCS->POST ) ) .AND. ! cSymbol $ POSTS->REMARK ) )
                        IF WAGES->TYPE = 10
                            cPostUse := LSCALCS->POST
                        ELSE
                            cPostUse := SPACE( UQ_CodeLen() )
                        ENDIF

                        oCalcAcc := CalcsAccs():new()
                        oCalcAcc:lIsPlus := ( CALCS->MODE > 39 )
                        IF ! oCalcAcc:LoadFromCalcs( "LSCALCS" )
                            BREAK
                        ENDIF
                        cDacc := oCalcAcc:cPlusFullSeekValue//IF(EMPTY(LSCALCS->DACC),GetWageAcc( LSCALCS->PAYTYPE, cMode > 39 ), LSCALCS->DACC )

                        IF ! lIsNalog
                            IF ENTTB->( DBSEEK( cPayType + LSCALCS->PAYTYPE ) )
                                // Процент входимости не равен нулю
                                IF ENTTB->PERCENT <> 0
                                    // Накопим сумму
                                    IF nType = 0
                                        nSum += IF( ENTTB->PERCENT < 0, D( 1, ABS(ENTTB->PERCENT) ), ENTTB->PERCENT/100 ) * LSCALCS->SUMMA
                                    ELSEIF nType = 1
                                        AADD( aSum, { LSCALCS->PAYTYPE, LSCALCS->COMMENT, LSCALCS->SUMMA, cPostUse, cDacc, LSCALCS->GROUP, LSCALCS->PARAM, oCalcAcc } )
                                    ELSEIF nType = 12
                                        AADD( aSum, { LSCALCS->PAYTYPE, LSCALCS->COMMENT, LSCALCS->SUMMA, cPostUse, cDacc, LSCALCS->GROUP, LSCALCS->PARAM, oCalcAcc, LSCALCS->GROUP} )
                                    ELSEIF nType = 2
                                        IF ( nCount := ASCAN( aSum, {|x| x[4] == cPostUse .AND. x[5] == cDacc } ) ) = 0
                                            AADD( aSum, { LSCALCS->PAYTYPE, LSCALCS->COMMENT, LSCALCS->SUMMA, cPostUse, cDacc, LSCALCS->GROUP, LSCALCS->PARAM, oCalcAcc } )
                                        ELSE
                                            aSum[ nCount ][ 3 ] += LSCALCS->SUMMA
                                        ENDIF
                                    ENDIF
                                ENDIF
                            ELSE
                                IF nType = 0
                                    nSum += LSCALCS->SUMMA *GetEntryDefault( cPayType, LSCALCS->PAYTYPE ) / 100
                                ELSEIF nType = 1
                                    AADD( aSum, { LSCALCS->PAYTYPE, LSCALCS->COMMENT, LSCALCS->SUMMA*GetEntryDefault( cPayType, CALCS->PAYTYPE ) / 100, cPostUse, cDacc, LSCALCS->GROUP, LSCALCS->PARAM, oCalcAcc } )
                                ELSEIF nType = 12
                                    AADD( aSum, { LSCALCS->PAYTYPE, LSCALCS->COMMENT, LSCALCS->SUMMA*GetEntryDefault( cPayType, CALCS->PAYTYPE ) / 100, cPostUse, cDacc, LSCALCS->GROUP, LSCALCS->PARAM, oCalcAcc, LSCALCS->GROUP  } )
                                ELSEIF nType = 2
                                    IF ( nCount := ASCAN( aSum, {|x| x[4] == cPostUse .AND. x[5] == cDacc } ) ) = 0
                                        AADD( aSum, { LSCALCS->PAYTYPE, LSCALCS->COMMENT, LSCALCS->SUMMA*GetEntryDefault( cPayType, CALCS->PAYTYPE ) / 100, cPostUse, cDacc, LSCALCS->GROUP, LSCALCS->PARAM, oCalcAcc } )
                                    ELSE
                                        aSum[ nCount ][ 3 ] += LSCALCS->SUMMA*GetEntryDefault( cPayType, CALCS->PAYTYPE ) / 100
                                    ENDIF
                                ENDIF
                            ENDIF
                        ELSE
                            IF PYMNT->( DBSEEK( LSCALCS->PAYTYPE ) )
                                // Процент входимости не равен нулю
                                IF !EMPTY( PYMNT->GNI01 )
                                    // Накопим сумму
                                    IF nType = 0
                                        nSum += LSCALCS->SUMMA
                                    ELSEIF nType = 1
                                        AADD( aSum, { LSCALCS->PAYTYPE, LSCALCS->COMMENT, LSCALCS->SUMMA, cPostUse, cDacc, LSCALCS->GROUP, LSCALCS->PARAM, oCalcAcc } )
                                    ELSEIF nType = 12
                                        AADD( aSum, { LSCALCS->PAYTYPE, LSCALCS->COMMENT, LSCALCS->SUMMA, cPostUse, cDacc, LSCALCS->GROUP, LSCALCS->PARAM, oCalcAcc , LSCALCS->GROUP } )
                                    ELSEIF nType = 2
                                        IF ( nCount := ASCAN( aSum, {|x| x[4] == cPostUse .AND. x[5] == cDacc } ) ) = 0
                                            AADD( aSum, { LSCALCS->PAYTYPE, LSCALCS->COMMENT, LSCALCS->SUMMA, cPostUse, cDacc, LSCALCS->GROUP, LSCALCS->PARAM, oCalcAcc/*xTemp[1], xTemp[2]*/ } )
                                        ELSE
                                            aSum[ nCount ][ 3 ] += LSCALCS->SUMMA
                                        ENDIF
                                    ENDIF
                                ENDIF
                            ENDIF
                        ENDIF
                    ENDIF
                ENDIF
            ENDIF
            SKIP
        ENDDO

        DBCLOSE( "LSCALCS" )
    ENDIF

    END SEQUENCE

    RestSet()
    RestScope( aScope)

    RETURN( IF( nType >= 1, aSum, nSum ) )


*------------------------------------------------------*
*   Определяет код JOBS основного места работы сотрудника

    FUNCTION GetJobsCode( cCondition )
*------------------------------------------------------*
    LOCAL cCode := "?"
    LOCAL xSaveScope

    SaveSet()

    SELECT JOBS_
    SaveSet()
    xSaveScope := SaveScope()

    DB_SETORDER( "CODE" )
    // Неуволенные и видимые
    SET SCOPE TO PERSN->CODE + "1" + "0"
    GO TOP
    DO WHILE ! EOF()
        IF &cCondition
            cCode := JOBS_->RECCODE
            EXIT
        ENDIF
        SKIP
    ENDDO

    RestSet()
    RestScope( xSaveScope )

    RestSet()

    RETURN( cCode )


*------------------------------------------------------*
*   Определяет код JOBS основного места работы сотрудника
*  (в отличие от вышеуказанной, показывает и невидимых и уволеных
*   или возвращает массив полей JOBS_, где работает сотрудник

    FUNCTION GetJobsAll( cCondition, cField, cReturn )
*------------------------------------------------------*
    LOCAL cCode := "?"
    LOCAL xSaveScope, aRetArr := {}
    LOCAL aArr := {}

    SaveSet()

    SELECT JOBS_
    SaveSet()
    xSaveScope := SaveScope()

    DB_SETORDER( "CODE" )
    // Неуволенные и видимые
    SET SCOPE TO PERSN->CODE
    GO TOP
    DO WHILE ! EOF()
        IF &cCondition
            IF cField == NIL
                cCode := FIELD->RECCODE
                EXIT
            ELSEIF cReturn == NIL
                IF ASCAN( aRetArr, {|x| x == F_GET(cField) } ) == 0
                    AADD( aRetArr, F_GET(cField) )
                ENDIF
            ELSE
                IF ASCAN( aArr, {|x| x == F_GET(cField) } ) == 0
                    AADD( aArr, F_GET(cField) )
                    AADD( aRetArr, &cReturn )
                ENDIF
            ENDIF
        ENDIF
        SKIP
    ENDDO

    RestSet()
    RestScope( xSaveScope )

    RestSet()

    RETURN( IF(cField==NIL, cCode, aRetArr) )


*------------------------------------------------------*
*   Просмотр ЗП за указанный период и
*   по указанному учреждению

    FUNCTION ViewWages( dNewDate, cNewEnt, nType )
*------------------------------------------------------*

    // сохранение значений глобальных переменных
    LOCAL xLastDay   := MEMVAR->DAY
    LOCAL xLastMonth := MEMVAR->MONTH
    LOCAL xLastYear  := MEMVAR->YEAR
    LOCAL xLastDate  := MEMVAR->DATE
    LOCAL xLastEnt   := MEMVAR->ENT
    LOCAL xLastcEnt  := MEMVAR->CENT

    DEFAULT cNewEnt  IS MEMVAR->ENT
    DEFAULT dNewDate IS MEMVAR->DATE

     // изменение значений
    MEMVAR->DAY      := DAY( dNewDate )
    MEMVAR->MONTH    := MONTH( dNewDate )
    MEMVAR->YEAR     := YEAR( dNewDate )
    MEMVAR->DATE     := dNewDate

    MEMVAR->ENT      := cNewEnt
    MEMVAR->CENT     := EXTRACT( "Неизвестное", "VAL", SprPath + "such.dbf", "LNU", { "ENTCODE", cNewEnt } )

    CloseModuleFiles( { "SHEET", "SHLST", "PERSN", "JOBS_", "ADDRSSHT", "SPPRS", "MSHEET" } )

    IF EMPTY( nType ) .OR. ( nType == 10 )
        Wages()
    ELSE
        UnregularWages( nType )
    ENDIF

    // восстановление значений глобальных переменных
    MEMVAR->DAY   := xLastDay
    MEMVAR->MONTH := xLastMonth
    MEMVAR->YEAR  := xLastYear
    MEMVAR->DATE  := xLastDate
    MEMVAR->ENT   := xLastEnt
    MEMVAR->CENT  := xLastcEnt

    CloseModuleFiles( { "SHEET", "SHLST", "PERSN", "JOBS_", "ADDRSSHT", "SPPRS","MSHEET" } )

    RETURN NIL


*---------------------------------------------------------*
*   Очистка зарплаты по всем или по выделенным сотрудникам
*
    PROCEDURE ClearZapCur()
*---------------------------------------------------------*
    LOCAL   nCount, xDialogReturn
    LOCAL   nOldRecNo
    LOCAL   lMayBeDeleted

    // Запись по зарплате блокирована
    IF WagesClose()
        RETURN
    ENDIF

    BEGIN SEQUENCE

        xDialogReturn := CdDialog( "ClZar" )
        IF VALTYPE( xDialogReturn ) <> "A"
            BREAK
        ENDIF
        xDialogReturn := xDialogReturn[ 1 ]

        CALCS->( DB_SETORDER( "CODE" ) )
        OUTCM->( DB_SETORDER( "WAGESCODE" ) )
        SELECT WAGES
        nOldRecNo := RECNO()
        GO TOP

        IF ( xDialogReturn .AND. EOF() ) .OR. ( !xDialogReturn .AND. COUNTMARKED()=0 )
            MALERT( "Нет данных для удаления" )
            DBGOTO( nOldRecNo )
            BREAK
        ENDIF
        IF ALERT( "Вы уверены, что хотите удалить " + IF(xDialogReturn, "ВСЕ записи ?", ;
                        XTOC(COUNTMARKED()) + " отмеченных записей" ), ;
                        {"Продолжить","Отмена"} ) != 1
            DBGOTO( nOldRecNo )
            BREAK
        ENDIF

        IF .NOT. MODINIT( { "PROFT", "SPRFT" }, MEMVAR->YEAR )
            BREAK
        ENDIF

        nCount := 0
        BeginStatus()

        DBSELECTAREA( "WAGES" )
        DO WHILE ! EOF()

            IF ( xDialogReturn .OR. MARKED() ) .AND. ! WAGES->LOCKED
                lMayBeDeleted := .T.
// Необходимо проверить, нет ли выплаченных сумм. Если есть - удалять нельзя
                SELECT CALCS
                SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE
                GO TOP
                DO WHILE ! EOF()
                    IF !EMPTY( CALCS->SHLSTCODE )
                        lMayBeDeleted := .F.
                        EXIT
                    ENDIF
                    SKIP
                ENDDO
                IF lMayBeDeleted
                    SayStatus( "Удаление " + XTOC( nCount+1 ) + " записи" )

                    SELECT CALCS
                    SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE
                    GO TOP
                    DO WHILE ! EOF()
                        // Мягкое удаление
                        SOFT_DELETE()
                        DBGOTOP()
                    ENDDO

                    SELECT OUTCM
                    SET SCOPE TO WAGES->RECCODE
                    GO TOP
                    DO WHILE ! EOF()
                        SOFT_DELETE()
                        DBGOTOP()
                    ENDDO
                    // удаляем расшифровки доходов для налога с физических лиц
                    SELECT PROFT
                    DB_SETORDER( "JOBSCODE" )
                    SET SCOPE TO WAGES->JOBSCODE
                    GO TOP
                    DO WHILE .NOT. EOF()
                        // Del_Rec()
                        DO WHILE ! R_LOCK(); ENDDO
                        FIELD->&( "MONTH" + STRZERO( MONTH( WAGES->MONTH ), 2 ) ) := 0
                        FIELD->PRSUM := SumRecord( "MONTH01", "MONTH12" )
                        UN_LOCK()
                        SKIP
                    ENDDO

                    // удаляем расшифровки доходов для ЕСН
                    SELECT SPRFT
                    DB_SETORDER( "JOBSCODE" )
                    SET SCOPE TO WAGES->JOBSCODE
                    GO TOP
                    DO WHILE .NOT. EOF()
                        DO WHILE ! R_LOCK(); ENDDO
                        FIELD->&( "MONTH" + STRZERO( MONTH( WAGES->MONTH ), 2 ) ) := 0
                        FIELD->PRSUM    := SumRecord( "MONTH01", "MONTH12" )
                        UN_LOCK()
                        SKIP
                    ENDDO

                    SELECT WAGES
                    UNMARK()
                    Del_Rec()
                    ++nCount
                ENDIF
                SELECT WAGES
            ENDIF

            SKIP
        ENDDO

        EndStatus()
        MALERT( "Удалено " + XTOC( nCount ) + " записей" )

        DBGOTO( nOldRecNo )
        SKIP 0

    END SEQUENCE

    MEMVAR->oBrowse:RefreshAll()

    RETURN

*------------------------------------------------------------*
*   Возвращает число дней по разным типам рабочей недели
*   за определенный интервал времени по учреждению и дате

    FUNCTION BInfoMonth( dDateBegin,;// Дата начала
                         dDateEnd,; // Дата конца
                         nWType, ; // тип недели
                         lFull ) // Учитывать ли праздничные дни

*   Возвращаемое значение - массив образца:
*   { Дней,;   // Пятидневка рабочих дней
*     Дней,;   // Шестидневка рабочих дней
*     Дней }   // Календарных рабочих дней
*------------------------------------------------------------*
    LOCAL aDays   // Результат работы
    LOCAL aInfo     // Массив с раскладкой дней по текущему месяцу
    LOCAL dMonth
    LOCAL dCurDate

    DEFAULT lFull IS .F.

    dCurDate := dDateBegin
    dMonth   := BOM( dCurDate )
    IF nWType = NIL
        aDays  := { 0, 0, 0 }
        aInfo    := GetDays( MEMVAR->Ent, dMonth )
        DO WHILE dCurDate <= dDateEnd
            // Месяц изменился ==> перечитаем массив информации о месяце
            IF dMonth <> BOM( dCurDate )
                // Берем следующий месяц
                dMonth := BOM( dCurDate )
                aInfo  := GetDays( MEMVAR->Ent, dMonth )
            ENDIF
            // Берем тип дня по пятидневке
            IF aInfo[ DAY( dCurDate ) ][ 1 ] = 0 //Рабочий
                ++aDays[ 1 ]
            ENDIF
            // Берем тип дня по шестидневке
            IF aInfo[ DAY( dCurDate ) ][ 3 ] = 0 //Рабочий
                ++aDays[ 2 ]
            ENDIF
            // Берем тип дня по шестидневке и вычисляем календарный рабочий день
            IF aInfo[ DAY( dCurDate ) ][ 3 ] = 0 .OR.; //Рабочий
                aInfo[ DAY( dCurDate ) ][ 3 ] = 1 .OR. lFull     //Выходной обычный
                ++aDays[ 3 ]
            ENDIF
            dCurDate++
        ENDDO
    ELSE
        aDays  := 0
        aInfo    := GetDays( MEMVAR->Ent, dMonth, nWType )
        DO WHILE dCurDate <= dDateEnd
            // Месяц изменился ==> перечитаем массив информации о месяце
            IF dMonth <> BOM( dCurDate )
                // Берем следующий месяц
                dMonth := BOM( dCurDate )
                aInfo  := GetDays( MEMVAR->Ent, dMonth, nWTYpe )
            ENDIF
            // Берем тип дня
            IF aInfo[ DAY( dCurDate ) ][ 1 ] = 0 //Рабочий
                ++aDays
            ENDIF
            // Берем тип дня и вычисляем календарный рабочий день
            IF nWType = 3 .AND. ( aInfo[ DAY( dCurDate ) ][ 1 ] = 1 .OR. ( aInfo[ DAY( dCurDate ) ][ 1 ] = 2 .AND. lFull ) ) //Выходной обычный
                ++aDays
            ENDIF
            dCurDate++
        ENDDO
    ENDIF

    RETURN aDays


*------------------------------------------------------*
*   Занесение в з/п дополнительных часов

    STATIC PROCEDURE SBT_DopTabel( )
*------------------------------------------------------*
    LOCAL cPayType
    LOCAL aRels
    LOCAL nSum
    LOCAL aParam
    LOCAL xTemp
    LOCAL oCalcsAcc
    LOCAL cErrorMsg

    PRIVATE cpMethodParam

    SaveSet()
    aRels := SaveRels()

    BEGIN SEQUENCE

    PYMNT->( DB_SETORDER( "CODE" ) )

    SELECT JOBTB
    DB_SETORDER( "ANYPOST" )
    SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->JOBSCODE
    GO TOP

    DO WHILE ! EOF()

        SELECT JOBTD
        DB_SETORDER( "MAINCODE" )
        SET SCOPE TO JOBTB->RECCODE
        GO TOP

        DO WHILE ! EOF()
            nSum := 0
            cPayType := JOBTD->PAYTYPE
            IF ! PYMNT->( DBSEEK( cPayType ) )
                ALERT("Вид оплаты с кодом '"+cPayType+"' не найден;"+;
                      "в справочнике видов оплат. Восстановите информацию;"+;
                      "о виде оплаты и попробуйте снова",{"Прервать"},,,,,,"I")
                SKIP
                LOOP
            ENDIF
            MEMVAR->cpMethodParam := { JOBTB->POST, JOBTD->HOURS, JOBTB->NORMHOURS, PYMNT->PARAM }
            // Вычислим результат COUNTMETOD
            nSum := CountMethod( cPayType, 17, 17 )
            IF !EMPTY( nSum )
                // По специальному алгоритму
                aParam := { "09#####",;
                            nSum,;
                            IF( EMPTY( MEMVAR->cpMethodParam ),;
                            "///////"+XTOC(nSum)+"//",;
                            MEMVAR->cpMethodParam ),;
                            nSum }

                    // Добавим новую запись
                oCalcsAcc := CalcsAccs():new()
                oCalcsAcc:lIsPlus := .F.
                IF ! oCalcsAcc:LoadFromPymnt( PYMNT->CODE, MEMVAR->ENT, JOBTB->POST, WAGES->TYPE, @cErrorMsg )
                    Message( "S" + cErrorMsg )
                    BREAK
                ENDIF

                IF CalcMayBeModified (cPayType, 30, JOBTB->POST, WAGES->JOBSCODE,;
                    ,PYMNT->PRIORITY,,oCalcsAcc:wacc)
                    CALCS->( SOFT_APPEND() )
                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                    CALCS->CODE     := JOBS_->CODE     // Табельный
                    CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                    CALCS->GROUP    := PYMNT->GROUP    // группа
                    CALCS->MODE     := 30 // Режим
                    CALCS->COMMENT  := PYMNT->NAME     // Примечание
                    CALCS->PAYTYPE  := PYMNT->CODE  // Вид оплаты
                    // это начисление
                    CALCS->POST := JOBTB->POST      // Должность
                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                    // Суммы и их характеристики
                    CALCS->SUMTYPE   := aParam[ 1 ] // Тип суммы для расчета
                    CALCS->COUNTSUM  := aParam[ 2 ] // Сумма для расчета
                    CALCS->PARAM     := aParam[ 3 ] // Параметр для расчета
                    CALCS->SUMMA     := ROUND( aParam[ 4 ], 2 ) // Сумма-результат
                ENDIF
            ENDIF
            SKIP
        ENDDO
        SELECT JOBTB
        SKIP
    ENDDO

    END SEQUENCE

    RestSet()
    RestRels( aRels )

    RETURN

*------------------------------------------------------*
*   Занесение в з/п ночных и праздничных

    STATIC PROCEDURE SBT_Night( )
*------------------------------------------------------*
    LOCAL aNight    := {}
    LOCAL aHDays    := {}
    LOCAL nI, nJ
    LOCAL cPayType  := {,,,}
    LOCAL aPosts    := {}
    LOCAL nSum
    LOCAL aParam    := {}
    LOCAL nRec
    LOCAL aRels     := {}
    LOCAL aTemp     := {}
    LOCAL nCount
    LOCAL aWeekDays := {}
    LOCAL aPrDays   := {}
    LOCAL aDays
    LOCAL xTemp
    LOCAL oCalcsAcc
    LOCAL cErrorMsg

    SaveSet()

    cPayType[1] := Extract( {}, "ARR", "PYMNT", {"CODE","PRIORITY","NAME","PARAM"}, {"GROUP", "23" } )
    cPayType[2] := Extract( {}, "ARR", "PYMNT", {"CODE","PRIORITY","NAME","PARAM"}, {"GROUP", "24" } )
// для выходных по табелю
    cPayType[3] := Extract( {}, "ARR", "PYMNT", {"CODE","PRIORITY","NAME","PARAM"}, {"GROUP", "22" } )
// для прочих по табелю
    cPayType[4] := Extract( {}, "ARR", "PYMNT", {"CODE","PRIORITY","NAME","PARAM"}, {"GROUP", "28" } )


    IF !EMPTY( cPayType[1] ) .AND. !EMPTY( cPayType[2] ).OR.!EMPTY(cPayType[3]).OR.!EMPTY(cPayType[4])
      //исчем ночные, праздничные и выходные

        PRIVATE cpMethodParam
        SaveSet()
        aRels := SaveRels()

        IF SELECT( "JOBTB" ) > 0
//                                                    1       2         3         4            5         6
            aParam := Extract( {}, "ARR", "JOBTB", {"POST","NIGHT","HOLIDAYS","NORMHOURS","WEEKDAYS","PARAM1"}, {"CODE",DTOS(BOM(MEMVAR->Date))+WAGES->CODE+WAGES->JOBSCODE} )

            FOR nI := 1 TO LEN( aParam )
                IF ASCAN( aPosts, {|x| x[1] == aParam[nI][1] } ) < 1
                    //инфа по должности                                    1       2          3         4          5         6        7          8          9
                    xTemp := Extract( {}, "VAL", SprPath+"posts.dbf", { "CODE", "NIGHM", "NIGHPERC", "HOLIM", "HOLIPERC", "WEEK", "WEEKPERC", "PARAM1", "PAR1PERC" }, { "CODE", aParam[nI][1] } )
                    IF ! EMPTY( xTemp )
                        AADD( aPosts, xTemp )

                        IF LEN( cPayType[1] )>0.AND.LEN( cPayType[2] )>0
                            IF EMPTY( aPosts[ LEN(aPosts) ][ 2 ] ) //по умолчанию метод и прос.
                                aPosts[ LEN(aPosts) ][ 2 ] := cPayType[1][ 1 ][ 1 ]
                                aPosts[ LEN(aPosts) ][ 3 ] := cPayType[1][ 1 ][ 4 ]
                            ENDIF
                            IF EMPTY( aPosts[ LEN(aPosts) ][ 3 ] ) //прос.
                                aPosts[ LEN(aPosts) ][ 3 ] := cPayType[1][ 1 ][ 4 ]
                            ENDIF
                            IF EMPTY( aPosts[ LEN(aPosts) ][ 4 ] ) //по умолчанию метод и прос.
                                aPosts[ LEN(aPosts) ][ 4 ] := cPayType[2][ 1 ][ 1 ]
                                aPosts[ LEN(aPosts) ][ 5 ] := cPayType[2][ 1 ][ 4 ]
                            ENDIF
                            IF EMPTY( aPosts[ LEN(aPosts) ][ 5 ] ) //прос.
                                aPosts[ LEN(aPosts) ][ 5 ] := cPayType[2][ 1 ][ 4 ]
                            ENDIF
                        ENDIF

    // для выходных по табелю
                        IF LEN(cPayType[3])>0
                            IF EMPTY( aPosts[ LEN(aPosts) ][ 6 ] ) //по умолчанию метод и прос.
                                aPosts[ LEN(aPosts) ][ 6 ] := cPayType[3][ 1 ][ 1 ]
                                aPosts[ LEN(aPosts) ][ 7 ] := cPayType[3][ 1 ][ 4 ]
                            ENDIF
                            IF EMPTY( aPosts[ LEN(aPosts) ][ 7 ] ) //прос.
                                aPosts[ LEN(aPosts) ][ 7 ] := cPayType[3][ 1 ][ 4 ]
                            ENDIF
                        ENDIF
    // для прочих по табелю
                        IF LEN(cPayType[4])>0
                            IF EMPTY( aPosts[ LEN(aPosts) ][ 8 ] ) //по умолчанию метод и прос.
                                aPosts[ LEN(aPosts) ][ 8 ] := cPayType[4][ 1 ][ 1 ]
                                aPosts[ LEN(aPosts) ][ 9 ] := cPayType[4][ 1 ][ 4 ]
                            ENDIF
                            IF EMPTY( aPosts[ LEN(aPosts) ][ 9 ] ) //прос.
                                aPosts[ LEN(aPosts) ][ 9 ] := cPayType[4][ 1 ][ 4 ]
                            ENDIF
                        ENDIF
                    ENDIF
                ENDIF
                IF !EMPTY( aParam[ nI ][ 2 ] )
// учет перетарификации (bor)
                    IF (nCount := ASCAN(aNight, {|x| x[1]==aParam[nI][1]}) ) > 0
                       aNight[nCount][2] := aNight[nCount][2] + aParam[nI][2]
                    ELSE
                        AADD( aNight, { aParam[ nI ][ 1 ], aParam[ nI ][ 2 ], aParam[ nI ][ 4 ] } )
                    ENDIF

                ENDIF

                IF !EMPTY( aParam[ nI ][ 3 ] )
// учет перетарификации (bor)
                    IF (nCount := ASCAN( aHDays, {|x| x[1]==aParam[nI][1]}) ) > 0
                        aHDays[nCount][2] := aHDays[nCount][2] + aParam[nI][3]
                    ELSE
                        AADD( aHDays, { aParam[ nI ][ 1 ], aParam[ nI ][ 3 ], aParam[ nI ][ 4 ] } )
                    ENDIF

                ENDIF

// учет выходных
                IF !EMPTY( aParam[nI][5] )
                // учет перетарификации (bor)
                    IF (nCount := ASCAN( aWeekDays, {|x| x[1]==aParam[nI][1]}) ) > 0
                        aWeekDays[nCount][2] := aWeekDays[nCount][2] + aParam[nI][3]
                    ELSE
                        AADD( aWeekDays, { aParam[ nI ][ 1 ], aParam[ nI ][ 5 ], aParam[ nI ][ 4 ] } )
                    ENDIF
                ENDIF
// учет прочих
                IF !EMPTY( aParam[nI][6] )
                // учет перетарификации (bor)
                    IF (nCount := ASCAN( aPrDays, {|x| x[1]==aParam[nI][1]}) ) > 0
                        aPrDays[nCount][2] := aPrDays[nCount][2] + aParam[nI][3]
                    ELSE
                        AADD( aPrDays, { aParam[ nI ][ 1 ], aParam[ nI ][ 6 ], aParam[ nI ][ 4 ] } )
                    ENDIF
                ENDIF
            NEXT
            ASIZE( aParam, 0 )
        ENDIF
        RestRels( aRels )
        RestSet()
    ENDIF

    IF !EMPTY( cPayType[1] ).AND.!EMPTY( cPayType[2] )
        nJ := { 0, 0 }
        FOR nI := 1 TO LEN( aNight )
            //инфа по должности
            nJ[ 1 ] := ASCAN( aPosts, {|x| x[1] == aNight[ nI ][ 1 ] } )
            //метод расчета для должности
            nJ[ 2 ] := ASCAN( cPayType[1], {|x| x[1] == aPosts[ nJ[1] ][ 2 ] } )
            nSum := NIL
            MEMVAR->cpMethodParam := ACLONE( aNight[ nI ] )
            //если нет процента в спр.должн., то берем из спр.оплат
            AADD( MEMVAR->cpMethodParam, IF( EMPTY(aPosts[ nJ[1] ][ 3 ]), cPayType[1][ nJ[ 2 ] ][ 4 ], XTOC(aPosts[ nJ[1] ][ 3 ]) ) )

            // Вычислим результат COUNTMETOD
            nSum   := CountMethod( cPayType[1][ nJ[ 2 ] ][ 1 ], 13, 13 )

            IF !EMPTY( nSum )
                // По специальному алгоритму
                aParam := { "09#####",;
                            nSum,;
                            IF( EMPTY( MEMVAR->cpMethodParam ),;
                            "///////"+XTOC(nSum)+"//",;
                            MEMVAR->cpMethodParam ),;
                            nSum }

                    // Добавим новую запись
                oCalcsAcc := CalcsAccs():new()
                IF ! oCalcsAcc:LoadFromPymnt( cPayType[1][ nJ[2] ][1], MEMVAR->ENT, aNight[ nI ][1], WAGES->TYPE, @cErrorMsg )
                    Message( "S" + cErrorMsg )
                    BREAK
                ENDIF

                IF CalcMayBeModified ( cPayType[1][ nJ[2] ][1], 30, aNight[ nI ][1], WAGES->JOBSCODE,;
                                      ,cPayType[1][ nJ[2] ][2],,oCalcsAcc:wacc)
                    CALCS->( SOFT_APPEND() )
                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                    CALCS->CODE     := JOBS_->CODE     // Табельный
                    CALCS->PRIORITY := cPayType[1][ nJ[2] ][2] // приоритет вычисл
                    CALCS->GROUP    := 23    // группа
                    CALCS->MODE     := 30 // Режим
                    CALCS->COMMENT  := cPayType[1][ nJ[2] ][3]     // Примечание
                    CALCS->PAYTYPE  := cPayType[1][ nJ[2] ][1]  // Вид оплаты
                    // это начисление
                    CALCS->POST := aNight[ nI ][1]      // Должность
                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                    // Суммы и их характеристики
                    CALCS->SUMTYPE   := aParam[ 1 ] // Тип суммы для расчета
                    CALCS->COUNTSUM  := aParam[ 2 ] // Сумма для расчета
                    CALCS->PARAM     := aParam[ 3 ] // Параметр для расчета
                    CALCS->SUMMA     := ROUND( aParam[ 4 ], 2 ) // Сумма-результат
                ENDIF
            ENDIF

        NEXT

        FOR nI := 1 TO LEN( aHDays )
            //инфа по должности
            nJ[ 1 ] := ASCAN( aPosts, {|x| x[1] == aHDays[ nI ][ 1 ] } )
            //метод расчета для должности
            nJ[ 2 ] := ASCAN( cPayType[2], {|x| x[1] == aPosts[ nJ[1] ][ 4 ] } )
            nSum := NIL
            MEMVAR->cpMethodParam := ACLONE( aHDays[ nI ] )
            AADD( MEMVAR->cpMethodParam, IF( EMPTY(aPosts[ nJ[1] ][ 5 ]), cPayType[2][ nJ[ 2 ] ][ 4 ], XTOC(aPosts[ nJ[1] ][ 5 ]) ) )

            // Вычислим результат COUNTMETOD
            nSum   := CountMethod( cPayType[2][ nJ[2] ][ 1 ], 13, 13 )

            IF !EMPTY( nSum )
                // По специальному алгоритму
                aParam := { "09#####",;
                            nSum,;
                            IF( EMPTY( MEMVAR->cpMethodParam ),;
                            "///////"+XTOC(nSum)+"//",;
                            MEMVAR->cpMethodParam ),;
                            nSum }
                oCalcsAcc := CalcsAccs():new()
                IF ! oCalcsAcc:LoadFromPymnt( cPayType[2][ nJ[2] ][1], MEMVAR->ENT, aHDays[ nI ][1], WAGES->TYPE, @cErrorMsg )
                    Message( "S" + cErrorMsg )
                    BREAK
                ENDIF
                IF CalcMayBeModified(cPayType[2][ nJ[2] ][1], 30, aHDays[ nI ][1], WAGES->JOBSCODE,;
                                    ,cPayType[2][ nJ[2] ][2],,oCalcsAcc:wacc)
                    // Добавим новую запись
                    CALCS->( SOFT_APPEND() )
                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                    CALCS->CODE     := JOBS_->CODE     // Табельный
                    CALCS->PRIORITY := cPayType[2][ nJ[2] ][2] // приоритет вычисл
                    CALCS->GROUP    := 24    // группа
                    CALCS->MODE     := 30 // Режим
                    CALCS->COMMENT  := cPayType[2][ nJ[2] ][3]     // Примечание
                    CALCS->PAYTYPE  := cPayType[2][ nJ[2] ][1]  // Вид оплаты
                    // это начисление
                    CALCS->POST := aHDays[ nI ][1]      // Должность
                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                    // Суммы и их характеристики
                    CALCS->SUMTYPE   := aParam[ 1 ] // Тип суммы для расчета
                    CALCS->COUNTSUM  := aParam[ 2 ] // Сумма для расчета
                    CALCS->PARAM     := aParam[ 3 ] // Параметр для расчета
                    CALCS->SUMMA     := ROUND( aParam[ 4 ], 2 ) // Сумма-результат
                ENDIF
            ENDIF

        NEXT
    ENDIF

// учет выходных
    // если в справочнике видов оплат нет начислений по группе выходные по табелю,
    // то и начислять их не надо

    IF !EMPTY( cPaytype[3] )
        FOR nI := 1 TO LEN( aWeekDays )
            //инфа по должности
            nJ[ 1 ] := ASCAN( aPosts, {|x| x[1] == aWeekDays[nI][1] } )
            //метод расчета для должности
            nJ[ 2 ] := ASCAN( cPayType[3], {|x| x[1] == aPosts[ nJ[1] ][ 6 ] } )
            nSum := NIL
            MEMVAR->cpMethodParam := ACLONE( aWeekDays[ nI ] )

            AADD( MEMVAR->cpMethodParam, IF( EMPTY(aPosts[ nJ[1] ][7]), cPayType[3][ nJ[2] ][ 4 ], XTOC(aPosts[ nJ[1] ][7]) ) )

            // Вычислим результат COUNTMETOD
            nSum   := CountMethod( cPayType[3][ nJ[2] ][1], 13, 13 )

            IF !EMPTY( nSum )
                // По специальному алгоритму
                aParam := { "09#####",;
                            nSum,;
                            IF( EMPTY( MEMVAR->cpMethodParam ),;
                            "///////"+XTOC(nSum)+"//",;
                            MEMVAR->cpMethodParam ),;
                            nSum }
                oCalcsAcc := CalcsAccs():new()
                IF ! oCalcsAcc:LoadFromPymnt( cPayType[3][ nJ[2] ][1], MEMVAR->ENT, aWeekDays[ nI ][1], WAGES->TYPE, @cErrorMsg )
                    Message( "S" + cErrorMsg )
                    BREAK
                ENDIF

                IF CalcMayBeModified( cPayType[3][ nJ[2] ][1], 30, aWeekDays[ nI ][1], WAGES->JOBSCODE,;
                                     ,cPayType[3][ nJ[2] ][2],,oCalcsAcc:wacc)
                    // Добавим новую запись
                    CALCS->( SOFT_APPEND() )
                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                    CALCS->CODE     := JOBS_->CODE     // Табельный
                    CALCS->PRIORITY := cPayType[3][ nJ[2] ][2] // приоритет вычисл
                    CALCS->GROUP    := 22    // группа
                    CALCS->MODE     := 30 // Режим
                    CALCS->COMMENT  := cPayType[3][ nJ[2] ][3]     // Примечание
                    CALCS->PAYTYPE  := cPayType[3][ nJ[2] ][1]  // Вид оплаты
                    // это начисление
                    CALCS->POST := aWeekDays[ nI ][1]      // Должность
                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                    // Суммы и их характеристики
                    CALCS->SUMTYPE   := aParam[ 1 ] // Тип суммы для расчета
                    CALCS->COUNTSUM  := aParam[ 2 ] // Сумма для расчета
                    CALCS->PARAM     := aParam[ 3 ] // Параметр для расчета
                    CALCS->SUMMA     := ROUND( aParam[ 4 ], 2 ) // Сумма-результат
                ENDIF
            ENDIF

        NEXT
    ENDIF

// учет прочих по табелю
    // если в справочнике видов оплат нет начислений по группе прочие по табелю,
    // то и начислять их не надо

    IF !EMPTY( cPaytype[4] )
        FOR nI := 1 TO LEN( aPrDays )
            //инфа по должности
            nJ[ 1 ] := ASCAN( aPosts, {|x| x[1] == aPrDays[nI][1] } )
            //метод расчета для должности
            nJ[ 2 ] := ASCAN( cPayType[4], {|x| x[1] == aPosts[ nJ[1] ][ 8 ] } )
            nSum := NIL
            MEMVAR->cpMethodParam := ACLONE( aPrDays[ nI ] )

            AADD( MEMVAR->cpMethodParam, IF( EMPTY(aPosts[ nJ[1] ][9]), cPayType[4][ nJ[2] ][ 4 ], XTOC(aPosts[ nJ[1] ][9]) ) )

            // Вычислим результат COUNTMETOD
            nSum   := CountMethod( cPayType[4][ nJ[2] ][1], 13, 13 )

            IF !EMPTY( nSum )
                // По специальному алгоритму
                aParam := { "09#####",;
                            nSum,;
                            IF( EMPTY( MEMVAR->cpMethodParam ),;
                            "///////"+XTOC(nSum)+"//",;
                            MEMVAR->cpMethodParam ),;
                            nSum }

                oCalcsAcc := CalcsAccs():new()
                IF ! oCalcsAcc:LoadFromPymnt( cPayType[4][ nJ[2] ][1], MEMVAR->ENT, aPrDays[ nI ][1], WAGES->TYPE, @cErrorMsg )
                    Message( "S" + cErrorMsg )
                    BREAK
                ENDIF
                IF CalcMayBeModified(cPayType[4][ nJ[2] ][1], 30, aPrDays[ nI ][1], WAGES->JOBSCODE,;
                                    ,cPayType[4][ nJ[2] ][2],,oCalcsAcc:wacc)
                    // Добавим новую запись
                    CALCS->( SOFT_APPEND() )
                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                    CALCS->CODE     := JOBS_->CODE     // Табельный
                    CALCS->PRIORITY := cPayType[4][ nJ[2] ][2] // приоритет вычисл
                    CALCS->GROUP    := 28    // группа
                    CALCS->MODE     := 30 // Режим
                    CALCS->COMMENT  := cPayType[4][ nJ[2] ][3]     // Примечание
                    CALCS->PAYTYPE  := cPayType[4][ nJ[2] ][1]  // Вид оплаты
                    // это начисление
                    CALCS->POST := aPrDays[ nI ][1]      // Должность
                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                    // Суммы и их характеристики
                    CALCS->SUMTYPE   := aParam[ 1 ] // Тип суммы для расчета
                    CALCS->COUNTSUM  := aParam[ 2 ] // Сумма для расчета
                    CALCS->PARAM     := aParam[ 3 ] // Параметр для расчета
                    CALCS->SUMMA     := ROUND( aParam[ 4 ], 2 ) // Сумма-результат
                ENDIF
            ENDIF

        NEXT
    ENDIF

    RestSet()

    RETURN

*------------------------------------------------------*
*   Занесение в з/п замещения

    STATIC PROCEDURE SBT_Replace()
*------------------------------------------------------*
    LOCAL nSum
    LOCAL aPays := {}
    LOCAL oCalcsAcc

    SaveSet()

    BEGIN SEQUENCE

    IF ! MODINIT( { "RPLTB", "RPLTC" } )
        BREAK
    ENDIF

    SELECT RPLTB
    DB_SETORDER( "CODE" )
    SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->JOBSCODE
    GO TOP

    WHILE ! EOF()
        IF PYMNT->( DBSEEK( RPLTB->PAYTYPE ) )

            oCalcsAcc := GetPymntAccObject( RPLTB->PAYTYPE, WAGES->MAINPOST )

            nSum := CountMethod( RPLTB->PAYTYPE, "1", NIL )

            IF CalcMayBeModified( RPLTB->PAYTYPE,;         // 1 Вид оплаты
                          30,;                  // 2 Режим
                          WAGES->MAINPOST,;                  // 3 Должность сотрудника
                          WAGES->JOBSCODE,;              // 4
                          RPLTB->RECCODE,;             // 5
                          NIL,;              // 6 (не используется)
                          NIL,;                 // 7 (не используется)
                          NIL,;                  // 8 Счет
                          NIL,;            // 9 Проверять ли включенность в ведомость (не используется)
                          NIL,;                   // 10 ФКР
                          NIL, ;                // 11 Вид деятельности
                          NIL, ;                // 12
                          NIL, ;                // 13
                          NIL ;         // 14 проверять существующие начисления
                         )

                IF ! EMPTY( nSum )

                    // Добавим новую запись
                    CALCS->( SOFT_APPEND() )
                    CALCS->RECCODE  := CALCS->( UQ_CODE() )   // Код записи
                    CALCS->MONTH    := MEMVAR->DATE    // Месяц
                    CALCS->JOBSCODE := WAGES->JOBSCODE // Код JOBS
                    CALCS->WAGESCODE:= WAGES->RECCODE  // Код записи з/п
                    CALCS->CODE     := JOBS_->CODE     // Табельный
                    CALCS->CALCRCODE:= RPLTB->RECCODE  // код записи основания
                    CALCS->PRIORITY := PYMNT->PRIORITY // приоритет вычисл
                    CALCS->GROUP    := PYMNT->GROUP    // группа
                    CALCS->MODE     := 30 // Режим
                    CALCS->COMMENT  := PYMNT->NAME     // Примечание
                    CALCS->PAYTYPE  := PYMNT->CODE  // Вид оплаты
                    // это начисление
                    CALCS->POST := WAGES->MAINPOST      // Должность
                    CALCS->( CalcsObjectToTable( oCalcsAcc ) )
                    // Суммы и их характеристики
                    CALCS->COUNTSUM  := ROUND( nSum, 2 ) // Сумма для расчета
                    CALCS->PARAM     := "/" + RPLTB->POST + "/////////" // Параметр для расчета
                    CALCS->SUMMA     := ROUND( nSum, 2 ) // Сумма-результат
                ENDIF

            ENDIF

        ELSE
            ALERT( '!В табеле замещения присутствует вид оплаты с кодом "' + RPLTB->PAYTYPE + ;
                   '", однако в справочнике видов оплат и удержаний он не найден. Необходимо восстановить запись в справочнике видов оплат и удержаний' )
            BREAK
        ENDIF
        SKIP
    END

    END SEQUENCE

    RestSet()

    RETURN
*------------------------------------------------------*
*   хитрый расчет денажек из рук в долг с учетом копеек иподрасмчета

    FUNCTION CunnByHand( lCheckCloseDate )
*------------------------------------------------------*
    LOCAL nGoHand
    LOCAL nOutCome
    LOCAL aScope
    LOCAL nCountMinus := 0
    LOCAL aPayAcc, nCount, aTmp, nSum

    MEMVAR aCfgFIO

    DEFAULT lCheckCloseDate IS .T.

////    InitCFGFIO()

    IF !lCheckCloseDate .OR. BOM( GetCloseDate() ) < BOM(MEMVAR->DATE) //закрыто
        aPayAcc  := GetWageSumByAcc( , , 80, .T.,,,,,.F. )
        nGoHand  := 0
        nOutCome := 0

        SELECT OUTCM

        DB_SETORDER( "WAGESCODE" )
        SET SCOPE TO WAGES->RECCODE
        GO TOP
        DO WHILE !EOF()
            IF FIELD->TYPE < 10 // долги, формируемые данной функцией попадают под данную категорию
                SOFT_DELETE()
            ELSE
                SKIP
            ENDIF
        ENDDO

        FOR nCount := 1 TO LEN( aPayAcc[ 3 ] )
            IF aPayAcc[3][nCount][2] > 0.001
                nGoHand += aPayAcc[3][nCount][2]
            ELSEIF aPayAcc[3][nCount][2] < -0.001
                nOutCome += aPayAcc[3][nCount][2]

                SOFT_APPEND()

                FIELD->RECCODE   := UQ_Code()
                FIELD->WAGESCODE := WAGES->RECCODE
                FIELD->SUMMA     := - aPayAcc[3][nCount][2]
                FIELD->POST      := aPayAcc[3][nCount][3]
                FIELD->DBFKR     := aPayAcc[3][nCount][4]:CalcsAcc:wacc:fkr
                FIELD->DBACC     := aPayAcc[3][nCount][4]:CalcsAcc:wacc:acc
                FIELD->DBKGU     := aPayAcc[3][nCount][4]:CalcsAcc:wacc:kgu

            ENDIF
        NEXT

        SELECT WAGES

        IF aCfgFIO[ 3 ] .AND. !WAGES->TOFINAL
            aPayAcc  := GetWageSumByAcc( , , , .T.,,,,,.F. )

            SELECT OUTCM

            aTmp := {0,0}
            IF aCfgFIO[ 7 ]
                // Перенос копеек по общей сумме (без учета счетов)
                FOR nCount := 1 TO LEN( aPayAcc[ 3 ] )
                    nSum := ROUND( aPayAcc[3][nCount][2] - INT( aPayAcc[3][nCount][2] ), 2 )
                    IF aPayAcc[3][nCount][2] > 0.001 .AND. ABS(nSum) > 0.001
                        aTmp[1] -= nSum
                    ENDIF
                NEXT
                aTmp[2] := D( (aTmp[1] - INT(aTmp[1])), aTmp[1] )
                aTmp[1] -= INT(aTmp[1])
            ELSE
                aTmp[2] := 1
            ENDIF
            FOR nCount := 1 TO LEN( aPayAcc[ 3 ] )
                nSum := ROUND( aPayAcc[3][nCount][2] - INT( aPayAcc[3][nCount][2] ), 2 )
                IF aPayAcc[3][nCount][2] > 0.001 .AND. ABS(nSum) > 0.001

                    SOFT_APPEND()

                    FIELD->RECCODE   := UQ_Code()
                    FIELD->WAGESCODE := WAGES->RECCODE
                    FIELD->DACC      := aPayAcc[3][nCount][1]
                    IF aCfgFIO[ 7 ] .AND. nCount == LEN( aPayAcc[ 3 ] )
                        FIELD->SUMMA := aTmp[1]
                    ELSE
                        FIELD->SUMMA := - ROUND( nSum*aTmp[2], 2 )
                        aTmp[1] -= FIELD->SUMMA
                    ENDIF
                    nOutCome         -= FIELD->SUMMA
                    nGoHand          += FIELD->SUMMA
                    FIELD->POST      := aPayAcc[3][nCount][3]
                    FIELD->DBFKR     := aPayAcc[3][nCount][4]:CalcsAcc:wacc:fkr
                    FIELD->DBACC     := aPayAcc[3][nCount][4]:CalcsAcc:wacc:acc
                    FIELD->DBKGU     := aPayAcc[3][nCount][4]:CalcsAcc:wacc:kgu

                ENDIF
            NEXT

            SELECT WAGES
        ENDIF

        WAGES->BYHAND  := ROUND( nGoHand, 2 )
        WAGES->OUTCOME := ROUND( -nOutCome, 2 )
        WAGES->RESTBYHAND := WAGES->BYHAND - WAGES->SUMPRODUCE

        nSum := 0
        SELECT OUTCM
        GO TOP
        WHILE !EOF()
            IF FIELD->TYPE >= 10 .AND. FIELD->TYPE <= 40
                WAGES->OUTCOME += FIELD->SUMMA
                nSum += FIELD->SUMMA
            ELSEIF FIELD->TYPE >= 50
                nSum -= FIELD->SUMMA
            ENDIF
            SKIP
        ENDDO

        WAGES->RESTBYHAND += nSum

        SELECT WAGES
    ENDIF

RETURN NIL

*------------------------------------------------------*
*   Расчет кол-ва дней между 2-мя датами в одном месяце для отпускных
*   bor, июнь 2003 г.

    FUNCTION GetVacDays( dStart, dEnd )
*------------------------------------------------------*

LOCAL nHoliDays
LOCAL aTemp    := {}
LOCAL aDays
LOCAL nI

   FOR nI := DAY(dStart) TO DAY(dEnd)
      AADD(aTemp, "CHA"+STRZERO(nI,2) )
   NEXT
   aDays := EXTRACT( {}, "VAL", MemVar->SprPath + "wrkgr.dbf", aTemp, {"NUM",STRZERO(VACTN->WEEKTYPE,3)+DTOS(BOM(dStart) ) } )

   nHoliDays := 0
   FOR nI := 1 TO LEN(aDays)
       IF aDays[nI]=-2
           nHoliDays += 1
       ENDIF
   NEXT

RETURN nHoliDays

*------------------------------------------------------*
*   Возвращает счет (или его часть) для данного вида оплаты

    FUNCTION GetWageAcc( cPayType,;// Вид оплаты
                         xVal )// Дебет ли...
*------------------------------------------------------*

    #define DEBET_AT    3 // Номер позиции КСГУ для описания счета
    #define DEBET_LEN   6 // Длина КСГУ в описании счета
    #define CRED_AT     1 // Номер позиции аналитики счета для описания счета
    #define CRED_LEN    2 // Длина аналитики счета в описании счета

    LOCAL cAcc := SPACE( LEN_DESC_ACC )
    LOCAL nRecNo
    LOCAL cDebet
    LOCAL cKredit
    LOCAL lFound
    LOCAL lFullAcc, cFkr, cRefBu
    LOCAL nOffSet := 3
    LOCAL cDkgu
    LOCAL lStaffer  //штатный сотрудник

    DEFAULT cPayType  IS SPACE(6)
    DEFAULT xVal      IS .T.

    IF !( PYMNT->CODE == cPayType )
// Если указатель не стоит на искомой позиции пимента - ищем DBSEEKом
        nRecNo := PYMNT->(RECNO())
        PYMNT->(DB_SETORDER("CODE"))
        lFound := PYMNT->( DBSEEK( cPayType ) )
    ELSE
        lFound := .T.
    ENDIF

// Подразумеваем, что скопка уже стоит на пимент, поэтому ищем
    IF lFound
        IF VALTYPE(xVal) == "L"

            IF SELECT( "ACCNT" ) = 0 .AND. !ReferInit( { "ACCNT", "ACKGU" } )
                RETURN cAcc
            ENDIF

            ACCNT->( DB_SETORDER( "ACCNT" ) )
            IF ! EMPTY( SUBSTR( PYMNT->DACC, 2 ) ) .OR. ! EMPTY( SUBSTR( PYMNT->KACC, 2 ) )
                IF ACCNT->( DBSEEK( replaceaccag(SUBSTR( PYMNT->DACC, 2, 5 )) ) ) .OR. ACCNT->( DBSEEK( replaceaccag(SUBSTR( PYMNT->KACC, 2, 5 )) ) )
                    cKredit := SUBSTR( IF( xVal, PYMNT->DACC, PYMNT->KACC ), 5, CRED_LEN )
    // Достаем КСГУ, да не просто так, а с выдумкой...

                    IF ( ACCNT->GROUP = 11 .OR. LEFT( ACCNT->ACC, 3 ) == "109" ) .AND. ! xVal
                    // Если это финансовый результат... и дебет счета
                        cDkgu := LEFT( PYMNT->DKGU, DEBET_LEN ) // Вставляем КСГУ из счета, независимо, установлен или нет КСГУ фин.рез-а
                    ELSE
                        // Это не финансовый результат
                        IF EMPTY( PYMNT->FKGU )
                        // Пуст КСГУ для фин.рез-а
                            cDkgu := IF( cKredit == "03" .OR. cKredit == "13", "213", "211" )
                        ELSE
                        // Если - не пуст, не занимаемся ничем, просто его берем
                            cDkgu := PYMNT->FKGU
                        ENDIF
                    ENDIF

                    cDkgu   := PADR( cDkgu, DEBET_LEN )
    // Описание счета приводим в соответствие
                    cAcc    := PADR( cKredit + cDkgu , LEN_DESC_ACC )
                ELSE
                    IF( SELECT( "WAGES" ) > 0 .AND. !WAGES->( EOF() ) )
                        WAGES->( PersMessage( "@!Для вида оплаты '" + PYMNT->CODE + "' задан несуществующий счет. Проверьте настройку справочника оплат и удержаний." ) )
                    ELSE
                        ALERT( "!Для вида оплаты '" + PYMNT->CODE + "' задан несуществующий счет. Проверьте настройку справочника оплат и удержаний." )
                    ENDIF
                ENDIF
            ENDIF
        ELSE
            cAcc := {}


            IF LEN( xVal ) = 6
            // Прибыло описание счета (хотят увидеть полный счет)
                lFullAcc := .T.
                nOffSet  := 3
            ELSEIF LEN( xVal ) = 4
                lFullAcc := .T.
                nOffSet  := 0
            ELSE
                lFullAcc := .F.
                nOffSet  := 3
            ENDIF
            IF lFullAcc
            // Просьба вернуть полный счет - начинаем поиск и подмену ФКР, источника и всего остального
                ////InitCfgFIO()
                cFkr   := SPACE( 4 )
                cRefBu := ""

                PRSCT->( DB_SETORDER( "CODE" ) )
                SUCH->( DB_SETORDER( "ENTCODE" ) )
                POSTS->( DB_SETORDER( "CODE" ) )

                IF SELECT( "CALCS" ) > 0 .AND. CALCS->PAYTYPE == cPayType
                    IF ! EMPTY( CALCS->DFKR )
                        cFkr   := CALCS->DFKR
                    ENDIF
                    IF ! EMPTY( CALCS->REFBU )
                        cRefBu := CALCS->REFBU
                    ENDIF
                ENDIF

                IF SELECT( "FKRTABLE" ) > 0 .OR. ( Path:FExist( MEMVAR->SprPath + 'fkrtable.dbf' ) .AND. ReferInit( { "FKRTABLE" } ) )
                    FKRTABLE->( DB_SETORDER( "SUCH" ) )
                    // Ищем в таблице соответствия Учреждение + тип физ.лица + должность
                    // Если не найдено, то хотя бы Учреждение + тип физ.лица + пустая должность
                    IF FKRTABLE->( DBSEEK( xVal[ nOffSet + 2 ] + STRZERO( xVal[ nOffSet + 1 ], 2 ) + xVal[ nOffSet + 3 ] ) )
                        IF !EMPTY( FKRTABLE->FKR ) .AND. EMPTY( cFkr )
                            cFkr := FKRTABLE->FKR
                        ENDIF
                        IF !EMPTY( FKRTABLE->REFBU ) .AND. EMPTY( cRefBu )
                            cRefBu := FKRTABLE->REFBU
                        ENDIF
                    ENDIF

                    IF FKRTABLE->( DBSEEK( xVal[ nOffSet + 2 ] + STRZERO( xVal[ nOffSet + 1 ], 2 ) + SPACE( UQ_CodeLen() ) ) )
                        IF !EMPTY( FKRTABLE->FKR ) .AND. EMPTY( cFkr )
                            cFkr := FKRTABLE->FKR
                        ENDIF
                        IF !EMPTY( FKRTABLE->REFBU ) .AND. EMPTY(cRefBu)
                            cRefBu := FKRTABLE->REFBU
                        ENDIF
                    ENDIF

                ENDIF

                lStaffer := .T.
                IF ( nOffSet == 0 .AND. xVal[ nOffSet + 1 ] != 10 ) .OR. ( SELECT( "WAGES" ) > 0 .AND. !WAGES->( EOF() ) .AND. WAGES->TYPE != 10 )
                    lStaffer := .F.
                ENDIF

                IF lStaffer
                    IF POSTS->( DBSEEK( xVal[ nOffSet + 3 ] ) )
                        IF !EMPTY( POSTS->FKR ) .AND. EMPTY( cFkr )
                            cFkr   := POSTS->FKR
                        ENDIF
                        IF !EMPTY( POSTS->REFBU ) .AND. EMPTY( cRefBu )
                            cRefBu := POSTS->REFBU
                        ENDIF
                    ENDIF
                ENDIF

                IF MEMVAR->aCfgFIO[ 6 ] = 0
                // Поиск: учреждение - Тип физ.лица

                    IF SUCH->( DBSEEK( xVal[ nOffSet + 2 ] ) ) .AND. (EMPTY(cFkr) .OR. EMPTY(cRefBu))
                        IF !EMPTY( SUCH->FKR ) .AND. EMPTY(cFkr)
                            cFkr   := SUCH->FKR
                        ENDIF
                        IF !EMPTY( SUCH->REFBU ) .AND. EMPTY(cRefBu)
                            cRefBu := SUCH->REFBU
                        ENDIF
                    ENDIF

                    IF PRSCT->( DBSEEK( STRZERO( xVal[ nOffSet + 1 ], 2 ) ) ) .AND. (EMPTY(cFkr) .OR. EMPTY(cRefBu))
                        IF !EMPTY( PRSCT->FKR ) .AND. EMPTY(cFkr)
                            cFkr   := PRSCT->FKR
                        ENDIF
                        IF !EMPTY( PRSCT->REFBU ) .AND. EMPTY(cRefBu)
                            cRefBu := PRSCT->REFBU
                        ENDIF
                    ENDIF
                ELSE
                // Поиск: Тип физ.лица - учреждение

                    IF PRSCT->( DBSEEK( STRZERO( xVal[ nOffSet + 1 ], 2 ) ) ) .AND. (EMPTY(cFkr) .OR. EMPTY(cRefBu))
                        IF !EMPTY( PRSCT->FKR ) .AND. EMPTY(cFkr)
                            cFkr   := PRSCT->FKR
                        ENDIF
                        IF !EMPTY( PRSCT->REFBU ) .AND. EMPTY(cRefBu)
                            cRefBu := PRSCT->REFBU
                        ENDIF
                    ENDIF

                    IF SUCH->( DBSEEK( xVal[ nOffSet + 2 ] ) ) .AND. (EMPTY(cFkr) .OR. EMPTY(cRefBu))
                        IF !EMPTY( SUCH->FKR ) .AND. EMPTY(cFkr)
                            cFkr   := SUCH->FKR
                        ENDIF
                        IF !EMPTY( SUCH->REFBU ) .AND. EMPTY(cRefBu)
                            cRefBu := SUCH->REFBU
                        ENDIF
                    ENDIF
                ENDIF

                AADD( cAcc, cFkr )

                IF EMPTY( cRefBu )
                    cRefBu := " "
                ENDIF

            ENDIF

            IF nOffSet = 3
                IF xVal[ 2 ] .AND. xVal[ 3 ] > 30
                    cDebet := SUBSTR( xVal[1], DEBET_AT, DEBET_LEN )
                    cKredit := SUBSTR( xVal[1], CRED_AT, CRED_LEN )
                    AADD( cAcc, IF( EMPTY(cKredit), PYMNT->DACC, LEFT( PYMNT->DACC, 4 ) + cKredit + SUBSTR( PYMNT->DACC, 4 + CRED_LEN + 1 ) ) )
                    AADD( cAcc, PYMNT->DKGU )
                ELSEIF !xVal[ 2 ] .AND. xVal[ 3 ] > 30
                    cDebet := SUBSTR( xVal[1], DEBET_AT, DEBET_LEN )
                    cKredit := SUBSTR( xVal[1], CRED_AT, CRED_LEN )
                    /* если в справонике оплат у оплаты стоят одинаковые счета, то делаем подмену и дебетового счета*/
                    IF !EMPTY( SUBSTR( PYMNT->DACC, 2, 5 ) ) .AND. !EMPTY( SUBSTR(PYMNT->KACC, 2, 5 ) ) .AND.;
                               SUBSTR( PYMNT->DACC, 2, 5 )     ==          SUBSTR(PYMNT->KACC, 2, 5 )
                        AADD( cAcc, IF( EMPTY(cKredit), PYMNT->DACC, LEFT( PYMNT->DACC, 4 ) + cKredit + SUBSTR( PYMNT->DACC, 4 + CRED_LEN + 1 ) ) )
                    ELSE
                        AADD( cAcc, PYMNT->KACC )
                    ENDIF
                    AADD( cAcc, PYMNT->KKGU )
                ELSEIF xVal[ 2 ] .AND. xVal[ 3 ] <= 30
                    cDebet := SUBSTR( xVal[1], DEBET_AT, DEBET_LEN )
                    cKredit := SUBSTR( xVal[1], CRED_AT, CRED_LEN )
                    AADD( cAcc, PYMNT->DACC )
                    IF SELECT( "ACCNT" ) = 0 .AND. !ReferInit( { "ACCNT", "ACKGU" } )
                        AADD( cAcc, PYMNT->DKGU )
                        RETURN cAcc
                    ENDIF
                    ACCNT->( DB_SETORDER( "ACCNT" ) )
                    IF ACCNT->( DBSEEK( replaceaccag(SUBSTR( PYMNT->DACC, 2, 5 )) ) )
                        AADD( cAcc, IF( EMPTY( cDebet ) .OR. ACCNT->GROUP <> 11, PYMNT->DKGU, cDebet + SUBSTR( PYMNT->DKGU, DEBET_LEN + 1 ) ) )
                    ELSE
                        IF( SELECT( "WAGES" ) > 0 .AND. !WAGES->( EOF() ) )
                            WAGES->( PersMessage( "@!Для вида оплаты '" + PYMNT->CODE + "' задан несуществующий счет. Проверьте настройку справочника оплат и удержаний." ) )
                        ELSE
                            ALERT( "!Для вида оплаты '" + PYMNT->CODE + "' задан несуществующий счет. Проверьте настройку справочника оплат и удержаний." )
                        ENDIF
                        AADD( cAcc, SPACE( LEN_DESC_ACC ) )
                    ENDIF
                ELSEIF !xVal[ 2 ] .AND. xVal[ 3 ] <= 30
                    cDebet := SUBSTR( xVal[1], DEBET_AT, DEBET_LEN )
                    cKredit := SUBSTR( xVal[1], CRED_AT, CRED_LEN )
                    AADD( cAcc, IF( EMPTY( cKredit ), PYMNT->KACC, LEFT( PYMNT->KACC, 4 ) + cKredit + SUBSTR( PYMNT->DACC, 4 + CRED_LEN + 1 ) ) )
                    AADD( cAcc, PYMNT->KKGU )
                ENDIF
            ELSE
                AADD( cAcc, xVal[ nOffSet + 4] )
            ENDIF

            IF lFullAcc .AND. !EMPTY( cAcc[2] )
                cAcc[2] := cRefBu + SUBSTR( cAcc[2], 2 )
            ENDIF
        ENDIF
    ENDIF

    IF !EMPTY(nRecNo)
        PYMNT->(DBGOTO( nRecNo ))
    ENDIF

    RETURN cAcc

*------------------------------------------------------*
*   Возвращает ФКР + Вид деят. для существующего вида оплаты

    FUNCTION GetWageFkr( cPayType, cEnt, cPost, nType )// Вид оплаты, первоначальное заполнение ФКР
*------------------------------------------------------*
    LOCAL xTemp

    DEFAULT cPayType  IS FIELD->PAYTYPE
    DEFAULT cEnt      IS MEMVAR->ENT
    DEFAULT cPost     IS FIELD->POST
    DEFAULT nType     IS MEMVAR->npFacesType

    IF EMPTY( FIELD->DFKR ) .OR. EMPTY( FIELD->REFBU )
        xTemp := GetPrimaryFkr( cPayType, cEnt, cPost, nType )
        IF ! EMPTY( FIELD->DFKR )
            xTemp[1] := FIELD->DFKR
        ENDIF
        IF ! EMPTY( FIELD->REFBU )
            xTemp[2] := FIELD->REFBU
        ENDIF
    ELSE
        xTemp := { FIELD->DFKR, FIELD->REFBU }
    ENDIF

    RETURN xTemp
*------------------------------------------------------*
*   Возвращает ФКР + Вид деят. для нового вида оплаты

    FUNCTION GetPrimaryFkr( cPayType, cEnt, cPost, nType )// Вид оплаты, первоначальное заполнение ФКР
*------------------------------------------------------*

    LOCAL cAcc := { "", "" }
    LOCAL nRecNo
    LOCAL lFound
    LOCAL cFkr, cRefBu
    LOCAL cDkgu

    DEFAULT cPayType  IS CALCS->PAYTYPE
    DEFAULT cEnt      IS MEMVAR->ENT
    DEFAULT cPost     IS CALCS->POST
    DEFAULT nType     IS MEMVAR->npFacesType

    IF !( PYMNT->CODE == cPayType )
// Если указатель не стоит на искомой позиции пимента - ищем DBSEEKом
        nRecNo := PYMNT->(RECNO())
        PYMNT->(DB_SETORDER("CODE"))
        lFound := PYMNT->( DBSEEK( cPayType ) )
    ELSE
        lFound := .T.
    ENDIF
// Подразумеваем, что скопка уже стоит на пимент, поэтому ищем
    IF lFound
        cAcc := {}

        // Просьба вернуть полный счет - начинаем поиск и подмену ФКР, источника и всего остального
 ////InitCfgFIO()
        cFkr   := SPACE( 4 )
        cRefBu := SPACE( 1 )

        IF SELECT( "PRSCT" ) = 0 .AND. ! ReferInit( { "PRSCT" } )
            RETURN { cFkr, cRefBu }
        ENDIF

        IF SELECT( "SUCH" ) = 0 .AND. ! ReferInit( { "SUCH" } )
            RETURN { cFkr, cRefBu }
        ENDIF

        IF SELECT( "POSTS" ) = 0 .AND. ! ReferInit( { "POSTS" } )
            RETURN { cFkr, cRefBu }
        ENDIF

        PRSCT->( DB_SETORDER( "CODE" ) )
        SUCH->( DB_SETORDER( "ENTCODE" ) )
        POSTS->( DB_SETORDER( "CODE" ) )

        IF ! EMPTY( PYMNT->FKR )
            cFkr   := PYMNT->FKR
        ENDIF
        IF ! EMPTY( PYMNT->REFBU )
            cRefBu := PYMNT->REFBU
        ENDIF
        IF SELECT( "FKRTABLE" ) > 0 .OR. ( Path:FExist( MEMVAR->SprPath + 'fkrtable.dbf' ) .AND. ReferInit( { "FKRTABLE" } ) )
            FKRTABLE->( DB_SETORDER( "SUCH" ) )
            // Ищем в таблице соответствия Учреждение + тип физ.лица + должность
            // Если не найдено, то хотя бы Учреждение + тип физ.лица + пустая должность
            IF FKRTABLE->( DBSEEK( cEnt + STRZERO( nType, 2 ) + cPost ) )
                IF !EMPTY( FKRTABLE->FKR ) .AND. EMPTY( cFkr )
                    cFkr := FKRTABLE->FKR
                ENDIF
                IF !EMPTY( FKRTABLE->REFBU ) .AND. EMPTY( cRefBu )
                    cRefBu := FKRTABLE->REFBU
                ENDIF
            ENDIF

            IF FKRTABLE->( DBSEEK( cEnt + STRZERO( nType, 2 ) + SPACE( UQ_CodeLen() ) ) )
                IF !EMPTY( FKRTABLE->FKR ) .AND. EMPTY( cFkr )
                    cFkr := FKRTABLE->FKR
                ENDIF
                IF !EMPTY( FKRTABLE->REFBU ) .AND. EMPTY(cRefBu)
                    cRefBu := FKRTABLE->REFBU
                ENDIF
            ENDIF

        ENDIF

        IF POSTS->( DBSEEK( cPost ) )
            IF !EMPTY( POSTS->FKR ) .AND. EMPTY( cFkr )
                cFkr   := POSTS->FKR
            ENDIF
            IF !EMPTY( POSTS->REFBU ) .AND. EMPTY( cRefBu )
                cRefBu := POSTS->REFBU
            ENDIF
        ENDIF

        IF MEMVAR->aCfgFIO[ 6 ] = 0
        // Поиск: учреждение - Тип физ.лица

            IF SUCH->( DBSEEK( cEnt ) ) .AND. (EMPTY(cFkr) .OR. EMPTY(cRefBu))
                IF !EMPTY( SUCH->FKR ) .AND. EMPTY(cFkr)
                    cFkr   := SUCH->FKR
                ENDIF
                IF !EMPTY( SUCH->REFBU ) .AND. EMPTY(cRefBu)
                    cRefBu := SUCH->REFBU
                ENDIF
            ENDIF

            IF PRSCT->( DBSEEK( STRZERO( nType, 2 ) ) ) .AND. (EMPTY(cFkr) .OR. EMPTY(cRefBu))
                IF !EMPTY( PRSCT->FKR ) .AND. EMPTY(cFkr)
                    cFkr   := PRSCT->FKR
                ENDIF
                IF !EMPTY( PRSCT->REFBU ) .AND. EMPTY(cRefBu)
                    cRefBu := PRSCT->REFBU
                ENDIF
            ENDIF
        ELSE
        // Поиск: Тип физ.лица - учреждение

            IF PRSCT->( DBSEEK( STRZERO( nType, 2 ) ) ) .AND. (EMPTY(cFkr) .OR. EMPTY(cRefBu))
                IF !EMPTY( PRSCT->FKR ) .AND. EMPTY(cFkr)
                    cFkr   := PRSCT->FKR
                ENDIF
                IF !EMPTY( PRSCT->REFBU ) .AND. EMPTY(cRefBu)
                    cRefBu := PRSCT->REFBU
                ENDIF
            ENDIF

            IF SUCH->( DBSEEK( cEnt ) ) .AND. (EMPTY(cFkr) .OR. EMPTY(cRefBu))
                IF !EMPTY( SUCH->FKR ) .AND. EMPTY(cFkr)
                    cFkr   := SUCH->FKR
                ENDIF
                IF !EMPTY( SUCH->REFBU ) .AND. EMPTY(cRefBu)
                    cRefBu := SUCH->REFBU
                ENDIF
            ENDIF
        ENDIF

        AADD( cAcc, cFkr )

        IF EMPTY( cRefBu )
            cRefBu := " "
        ENDIF
        AADD( cAcc, cRefBu )
    ENDIF

    IF !EMPTY(nRecNo)
        PYMNT->(DBGOTO( nRecNo ))
    ENDIF

    RETURN cAcc


*------------------------------------------------------*
*   Возвращает .T., если можно добавить или изменить начисление с заданными параметрами
    FUNCTION CalcIsPresent( cPayType,;            // 1 Вид оплаты
                         nMode,;                  // 2 Режим
                         cPost,;                  // 3 Должность сотрудника
                         cJobsCode,;              // 4
                         cCalcrCode,;             // 5
                         nPriority,;              // 6 (не используется)
                         cParam,;                 // 7 (не используется)
                         oCalcsAcc,;              // 8 Счет
                         lCheckShlst,;            // 9 Проверять ли включенность в ведомость (не используется)
                         cFKR,;                   // 10 ФКР (не используется)
                         cRefBU, ;                // 11 Вид деятельности (не используется)
                         dSDate, ;                // 12
                         dFDate,  ;               // 13
                         lRecalcExclude ;         // 14 исключить перерасчеты
                        )
*------------------------------------------------------*
    LOCAL nRecNo := 0
    LOCAL aScope
    LOCAL aFkr
    LOCAL oAcc

    DEFAULT lRecalcExclude IS .F.

    SaveSet()
    aScope := CALCS->( SaveScope() )
    SELECT CALCS
    DB_SETORDER( "GROUP" )
    SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( nMode, 2 ) + cPayType

    DBGOTOP()

    DO WHILE !EOF()
        IF oCalcsAcc != NIL
            oAcc := CalcsAccs():new()
            IF ! oAcc:LoadFromCalcs()
                EXIT
            ENDIF
        ENDIF

        IF ( EMPTY( cPost ) .OR. CALCS->POST == cPost ) .AND. ;
            CALCS->JOBSCODE == cJobsCode .AND. ;
            ( EMPTY( oCalcsAcc ) .OR. oCalcsAcc:isEqual( oAcc:wacc ) ) .AND.;
            IF (EMPTY(CALCS->DATEPRODUC) .AND. EMPTY(CALCS->FDATEREC) .OR. (EMPTY(dSdate) .OR. EMPTY(dFdate)), .T., DTOS(CALCS->DATEPRODUC) == DTOS(dSDate) .AND. ;
                DTOS(CALCS->FDATEREC) == DTOS(dFDate)) .AND. ;
            IF (EMPTY(CALCS->CALCRCODE), .T., CALCS->CALCRCODE == cCalcrCode) .AND. ;
            ( ! lRecalcExclude .OR. ( EMPTY(CALCS->DATEPRODUC) .AND. EMPTY(CALCS->FDATEREC) ) )
                nRecNo := RECNO()

                EXIT
        ENDIF

        D_SKIP()
    ENDDO

    CALCS->(RestScope( aScope ))
    RestSet()

    RETURN nRecNo

*------------------------------------------------------*
*   Возвращает .T., если можно добавить или изменить начисление с заданными параметрами
    FUNCTION CalcMayBeModified(cPayType,;         // 1 Вид оплаты
                         nMode,;                  // 2 Режим
                         cPost,;                  // 3 Должность сотрудника
                         cJobsCode,;              // 4
                         cCalcrCode,;             // 5
                         nPriority,;              // 6 (не используется)
                         cParam,;                 // 7 (не используется)
                         cDacc,;                  // 8 Счет
                         lCheckShlst,;            // 9 Проверять ли включенность в ведомость (не используется)
                         cFKR,;                   // 10 ФКР
                         cRefBU, ;                // 11 Вид деятельности
                         dSDate, ;                // 12
                         dFDate, ;                // 13
                         lCheckExisting ;         // 14 проверять существующие начисления
                        )
*------------------------------------------------------*
    LOCAL lRes := .T.
    LOCAL nRecNo
    LOCAL aScope
    LOCAL oCalcParam
    LOCAL xTemp
    LOCAL oCalcsAcc

    DEFAULT lCheckExisting IS .T.

    SaveSet()
    aScope := CALCS->( SaveScope() )
    BEGIN SEQUENCE
        IF lCheckExisting .AND. (nRecNo := CalcIsPresent( cPayType, nMode, cPost, cJobsCode, cCalcrCode, nPriority, ;
            cParam, cDacc, lCheckShlst, cFKR, cRefBU, dSDate, dFDate)) > 0
            //начисление с такими параметрами присутствует
            //проверяем, есть ли по нему окончательная ведость
            DBSELECTAREA("CALCS")
            DB_SETORDER( "GROUP" )
            SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( nMode, 2 ) + cPayType
            DBGOTOP()
            IF !EOF()
                DBGOTO(nRecNo)
                IF !EOF() .AND. CalcSheets():IsInFinalSheet() == .T. //проверяем, в какую ведомость оно входит
                    lRes:= .F.
                ENDIF
            ENDIF
        ELSE
            //формируем параметры для ведомости
            oCalcParam := Hash():new()
            oCalcParam:put("DACC",  ""/*IF (EMPTY(cDacc), GetWageAcc( cPayType, nMode > 39 ), cDacc )*/)

            IF EMPTY( cDacc )
                oCalcsAcc := GetPymntAccObject( cPayType, IF( EMPTY(cPost), WAGES->MAINPOST, cPost) ):wacc
            ELSEIF VALTYPE( cDacc ) == "O"
                oCalcsAcc := cDacc
                cFkr := oCalcsAcc:fkr
                cRefBu := LEFT( oCalcsAcc:acc, 1 )
            ENDIF

            xTemp := GetPrimaryFkr( cPaytype, MEMVAR->ENT, IF( EMPTY(cPost), WAGES->MAINPOST, cPost), WAGES->TYPE )
            IF !EMPTY( xTemp )
                IF EMPTY(cFkr)
                    cFkr := LEFT( xTemp[ 1 ], 4 )
                ENDIF
                IF EMPTY(cRefBU)
                    cRefBU := LEFT( xTemp[ 2 ], 1 )
                ENDIF
            ENDIF
            oCalcParam:put( "FKR",   cFkr )
            oCalcParam:put( "REFBU", cRefBU )
            oCalcParam:put( "OACC", oCalcsAcc )

            IF CalcSheets():IsInFinalSheet(,oCalcParam, .F.) == .T.
                lRes := .F.
            ENDIF
        ENDIF
    END SEQUENCE
    RestSet()
    CALCS->( RestScope(aScope) )

    RETURN lRes

*------------------------------------------------------*
*

    FUNCTION GetTaxPayTypes()
*------------------------------------------------------*

    RETURN { asType, asProftType }

*------------------------------------------------------*
*   Возвращает массив информации, содержащий сведения о
*   дебетовых и кредитовых суммах в разрезе счетов
*   требует WAGES (текущее поле) и открытый CALCS

    FUNCTION GetWageSumByAcc( lOnlyNotPaid,;  // 1 считать только не выплаченные
                                  cPayType,;  // 2 вид оплаты (если только по одному)
                             nGroupExclude,;  // 3 какую группу исключить
                                lUseAnalit,;  // 4 Учитывать ли аналитику при расшифровке //Учитывать ли при расшифровке ФКР // Судя по коду - ВСЕГДА И ВЕЗДЕ ИСТИНА
                                  lUsePost,;  // 5 Учитывать ли при расшифровке должности
                                   lMark80,;  // 6 Выделить перечисления в удержаниях
                                   lDetail,;  // 7 Детализация начислений и удержаний
                                  oCalcAcc,;  // 8 Приводить к данной корреспонденции и затем уже группировать
                                           ;  // (Чтоб не возникало ситуаций с дублированием одинаковых записей)
                               lFullAnalit,;  // 9 Учитывать аналитику
                                    lMDolg,;  // 10 Уменьшать на сумму долга за предприятием
                                  ohParams )  // 11 алиасы { "WAGES", "CALCS" }
*------------------------------------------------------*
// Используется в WAGES SumByTarif, SBT_Bank
//     -- // --   SHEET CreatePaySheet
    LOCAL aScope
    LOCAL aReturn := { {},; // Все кредитовые счета (начисления)
                       {},; // все дебетовые счета  (удержания)
                       {},; // итого остаток в разрезе счетов
                       {},; // Перечисления
                       {} } // Долги (отдельная песня, т.к. без аналитики и проч.)
    LOCAL cFullSeekValue, cPost
    LOCAL nIndex, nMode
    LOCAL bBlock
    LOCAL xVar
    LOCAL nSum
    LOCAL nSumDolg
    LOCAL nSumD
    LOCAL nSumS
    LOCAL nI, nJ, nOst
    LOCAL nKoef
    LOCAL cCalcsAlias, cWagesAlias

    LOCAL oGroupSum := GrouppedValues():new()
    LOCAL oGroupOst := GrouppedValues():new()
    LOCAL oGroupDolg := GrouppedValues():new()

    LOCAL oAcc, oWAcc, ohAnalit
    LOCAL oCalcsLine
    LOCAL oWages

    DEFAULT lFullAnalit  IS .F.

    DEFAULT lOnlyNotPaid IS .F.
    DEFAULT lUseAnalit   IS .T.
    DEFAULT lUsePost     IS .F.
    DEFAULT lMark80      IS .F.
    DEFAULT lDetail      IS .F.
    DEFAULT lMDolg       IS .F.

    cWagesAlias := GetHash( ohParams, "WAGESALIAS", "WAGES" )
    cCalcsAlias := GetHash( ohParams, "CALCSALIAS", "CALCS" )
    oWages := GetHash( ohParams, "OWAGES", NIL )

    SaveSet()
    aScope := (cCalcsAlias)->( SaveScope() )

    IF SELECT( "POSTS" ) = 0
        IF !ReferInit( { "POSTS" } )
            RETURN( aReturn )
        ENDIF
    ENDIF

    IF SELECT( "PRSCT" ) = 0
        IF !ReferInit( { "PRSCT" } )
            RETURN( aReturn )
        ENDIF
    ENDIF

    IF SELECT( "SUCH" ) = 0
        IF !ReferInit( { "SUCH" } )
            RETURN( aReturn )
        ENDIF
    ENDIF

    IF lMark80
        aReturn := { {},; // Все кредитовые счета (начисления)
                     {},; // все дебетовые счета  (удержания)
                     {},; // итого остаток в разрезе счетов
                     {},; // Перечисления
                     {} } // Долги (отдельная песня, т.к. без аналитики и проч.)
    ENDIF

    SELECT POSTS
    DB_SETORDER( "CODE" )
    SET SCOPE TO
    SELECT &cCalcsAlias

    DB_SETORDER( "WAGESCODE" )
    SET SCOPE TO IF( oWages = NIL, (cWagesAlias)->RECCODE, oWages:reccode )
    GO TOP

    DO WHILE !EOF()
        oCalcsLine := CalcsByPersonLine():new()
        oCalcsLine:cWagesAlias := cWagesAlias
        oCalcsLine:cCalcsAlias := cCalcsAlias
        IF oCalcsLine:LoadCurrent( ohParams ) .AND. ;
            ( ! lOnlyNotPaid .OR. EMPTY( oCalcsLine:paysheet ) .OR. ( EMPTY( cPayType ) .AND. oCalcsLine:group = 50 ) ) ;
            .AND. ( EMPTY( cPayType ) .OR. oCalcsLine:PayType == cPayType ) ;
            .AND. ( EMPTY( nGroupExclude ) .OR. oCalcsLine:group <> nGroupExclude )

            IF lFullAnalit
                // полная аналитика
                RestrictAnalitHash( oCalcsLine:CalcsAcc:ohAnalit, oCalcsLine:CalcsAcc:wacc )
                oCalcsLine:CalcsAcc:FillAnalit( oCalcsLine:CalcsAcc:dacc, oCalcsLine:CalcsAcc:ohAnalit )
                oCalcsLine:CalcsAcc:FillAnalit( oCalcsLine:CalcsAcc:kacc, oCalcsLine:CalcsAcc:ohAnalit )
                oCalcsLine:CalcsAcc:wacc:CheckKGU( oCalcsLine:CalcsAcc:ohAnalit, .T. )
                oCalcsLine:CalcsAcc:FillSeekAnalitValue()
                oCalcsLine:CalcsAcc:cFullSeekValue := oCalcsLine:CalcsAcc:wacc:GetSeekValue() + oCalcsLine:CalcsAcc:cSeekAnalitValue
            ELSE
                // голый счет
                oCalcsLine:CalcsAcc:dacc:acckf1 := SPACE( 6 )
                oCalcsLine:CalcsAcc:dacc:acckf2 := SPACE( 6 )
                oCalcsLine:CalcsAcc:dacc:acckf3 := SPACE( 6 )

                oCalcsLine:CalcsAcc:kacc:acckf1 := SPACE( 6 )
                oCalcsLine:CalcsAcc:kacc:acckf2 := SPACE( 6 )
                oCalcsLine:CalcsAcc:kacc:acckf3 := SPACE( 6 )

                oCalcsLine:CalcsAcc:ohAnalit:Clear()
                oCalcsLine:CalcsAcc:wacc:CheckKGU( oCalcsLine:CalcsAcc:ohAnalit, .T. )
                oCalcsLine:CalcsAcc:FillSeekAnalitValue()
                oCalcsLine:CalcsAcc:cFullSeekValue := oCalcsLine:CalcsAcc:wacc:GetSeekValue() + oCalcsLine:CalcsAcc:cSeekAnalitValue
            ENDIF

            cFullSeekValue := oCalcsLine:CalcsAcc:cFullSeekValue
            cPost := IF( oWages = NIL, (cWagesAlias)->MAINPOST, oWages:reccode )

            IF lMark80 .AND. oCalcsLine:group = 80
//                                          1                              2                           3           4                     5                     6                        7                          8
                AADD( aReturn[ 4 ], { cFullSeekValue, (cCalcsAlias)->SUMMA - (cCalcsAlias)->SUMMADP, cPost, oCalcsLine, (cCalcsAlias)->CALCRCODE, oCalcsLine:PayType, oCalcsLine:CalcsAcc:wacc, oCalcsLine:CalcsAcc:ohAnalit } )
            ENDIF
            nMode := IF( (cCalcsAlias)->MODE < 40, 1, 2 )
            // Долг за работником
            IF oCalcsLine:group == 85
                IF ! lOnlyNotPaid .OR. EMPTY( oCalcsLine:paysheet )
                    IF lDetail
//                                                  1                                      2                                   3          4                   5                6                        7                          8
                        AADD( aReturn[ 5 ], { cFullSeekValue, (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ), cPost, oCalcsLine, oCalcsLine:PayType, oCalcsLine:group, oCalcsLine:CalcsAcc:wacc, oCalcsLine:CalcsAcc:ohAnalit } )
                    ELSE
                        IF ( nIndex := ASCAN( aReturn[ 5 ], {|x| x[ 1 ] == cFullSeekValue } ) ) = 0
//                                                      1                                      2                                    3          4                       5                           6
                            AADD( aReturn[ 5 ], { cFullSeekValue, (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ), cPost, oCalcsLine, oCalcsLine:CalcsAcc:wacc, oCalcsLine:CalcsAcc:ohAnalit } )
                        ELSE
                            aReturn[ 5 ][ nIndex ][ 2 ] += ( (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ) )
                        ENDIF
                    ENDIF
                ENDIF
            ENDIF

            IF ! lOnlyNotPaid .OR. EMPTY( oCalcsLine:paysheet )
                IF lDetail
//                                                  1                                      2                                    3          4                    5                6                        7                          8
                    AADD( aReturn[ nMode ], { cFullSeekValue, (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ), cPost, oCalcsLine, oCalcsLine:PayType, oCalcsLine:group, oCalcsLine:CalcsAcc:wacc, oCalcsLine:CalcsAcc:ohAnalit } )
                ELSE
                    IF ( nIndex := ASCAN( aReturn[ nMode ], {|x| x[ 1 ] == cFullSeekValue } ) ) = 0
//                                                      1                              2                                           3          4                      5                           6
                        AADD( aReturn[ nMode ], { cFullSeekValue, (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ), cPost, oCalcsLine, oCalcsLine:CalcsAcc:wacc, oCalcsLine:CalcsAcc:ohAnalit } )
                    ELSE
                        aReturn[ nMode ][ nIndex ][ 2 ] += ( (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ) )
                    ENDIF
                ENDIF
            ENDIF

            IF lUsePost
                bBlock := {|x| x[ 1 ] == cFullSeekValue .AND. x[ 3 ] == cPost }
            ELSE
                bBlock := {|x| x[ 1 ] == cFullSeekValue }
            ENDIF

            IF ( nIndex := ASCAN( aReturn[ 3 ], bBlock ) ) = 0
//                                          1                                                                                      2                                                                                                           3         4                    5                                 6
                AADD( aReturn[ 3 ], { cFullSeekValue, IF( oCalcsLine:group == 85, 0, IF( nMode = 1, (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ), -( (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ) ) ) ), cPost, oCalcsLine/* */, oCalcsLine:CalcsAcc:wacc, oCalcsLine:CalcsAcc:ohAnalit } )
            ELSE
                aReturn[ 3 ][ nIndex ][ 2 ] += IF( oCalcsLine:group == 85, 0, IF( nMode = 1, (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ), -( (cCalcsAlias)->SUMMA - IF( lMDolg, (cCalcsAlias)->SUMMADP, 0 ) ) ) )
            ENDIF
        ENDIF
        SKIP
    ENDDO

    IF ! EMPTY( aReturn[ 5 ] )
        // Есть долги!!!
        nSum := 0 // Сумма к выдаче
        // Группируем по счетам (без аналитики)
        AEVAL( aReturn[ 3 ], {|x| oGroupSum:put( x[ 4 ]:CalcsAcc:wacc:GetSeekValue(), x[2] ), nSum += x[2] } )
        nSumDolg := 0 // Сумма долгов
        // Группируем по счетам (без аналитики) хотя, конечно, долги и так без аналитики, но все же...
        AEVAL( aReturn[ 5 ], {|x| oGroupDolg:put( x[ 4 ]:CalcsAcc:wacc:GetSeekValue(), x[2] ), nSumDolg += x[ 2 ] } )
        // Группируем по счетам (без аналитики) хотя, конечно, долги и так без аналитики, но все же...
        AEVAL( aReturn[ 5 ], {|x| oGroupOst:put( x[ 4 ]:CalcsAcc:wacc:GetSeekValue(), x[2] ), nSumDolg += x[ 2 ] } )
        // берем общую сумму
        // Имеем теперь сгруппированные по счетам суммы к выдаче и сгруппированые по счетам долги
        FOR nIndex := 1 TO LEN( aReturn[ 3 ] )
            nI :=   ASCAN( oGroupSum:lines,  {|x| x:key == aReturn[ 3 ][ nIndex ][ 4 ]:CalcsAcc:wacc:GetSeekValue() } )
            nOst := ASCAN( oGroupOst:lines,  {|x| x:key == aReturn[ 3 ][ nIndex ][ 4 ]:CalcsAcc:wacc:GetSeekValue() } )
            nJ :=   ASCAN( oGroupDolg:lines, {|x| x:key == aReturn[ 3 ][ nIndex ][ 4 ]:CalcsAcc:wacc:GetSeekValue() } )
            IF EMPTY( nI )
                // НОНСЕНС!!!
                // не должно такого быть
                LOOP
            ENDIF
            IF ! EMPTY( nJ )
                // нашли сумму по счету
                nSumD := oGroupDolg:lines[ nJ ]:value
                nSumS := oGroupSum:lines[ nI ]:value
                nKoef := ROUND( nSumD * D( aReturn[ 3 ][ nIndex ][ 2 ], nSumS ), 2 )
                aReturn[ 3 ][ nIndex ][ 2 ] -= nKoef
                oGroupOst:lines[ nOst ]:value -= nKoef
            ENDIF
        NEXT
        // Все раскидали. В идеале - все хорошо, но вот с копейками - может быть не очень хорошо
        FOR nIndex := 1 TO LEN( oGroupOst:lines )
            IF oGroupOst:lines[nIndex]:value != 0
                IF ! EMPTY( nI := ASCAN( aReturn[ 3 ], {|x| x[4]:CalcsAcc:wacc:GetSeekValue() == oGroupOst:lines[nIndex]:key .AND. x[2] != 0 } ) )
                    // Ищем счет с аналитикой, чтоб запихнуть туда копейки (желательно, чтоб сумма была не нуль)
                    aReturn[ 3 ][ nI ][ 2 ] -= oGroupOst:lines[nIndex]:value
                ELSEIF ! EMPTY( nI := ASCAN( aReturn[ 3 ], {|x| x[4]:CalcsAcc:wacc:GetSeekValue() == oGroupOst:lines[nIndex]:key } ) )
                    // Если нет не нулевой суммы - пихаем в нулевую, что делать...
                    aReturn[ 3 ][ nI ][ 2 ] -= oGroupOst:lines[nIndex]:value
                ENDIF
            ENDIF
        NEXT
    ENDIF

    RestSet()
    (cCalcsAlias)->( RestScope( aScope ) )

    RETURN aReturn


*------------------------------------------------------*
*   Размазывает переданную сумму по входимости данного вида оплаты
*   ВНИМАНИЕ !!! МОЖЕТ ВЕРНУТЬ ПУСТОЙ МАССИВ (НАДО ПРОВЕРЯТЬ!!!)

    FUNCTION ProportionAmounts( cPayType,;    // Вид оплаты, по которому получить суммы таблицы входимости
                                dDate,;       // Дата, на какое число
                                cJobsCode,;   // JOBS реккод сотрудника
                                cWagesCode,;  // WAGES реккод записи
                                nSum,;        // Сумма для размазывания
                                lRound,;      // Округление
                                lCheckSheet ) ///.T. - размазывать только те суммы, по кот. не сформир. оконч. ведомости
*------------------------------------------------------*
    LOCAL aSumEntry, nSumEntry, nSumAll, nSumTax, aArr, nI
    LOCAL aReturn := {} // Массив возврата {{{Должность, счет, сумма (размазанная)},{Должность, счет, сумма (размазанная)},{..}},
//                         { Массив информации }}
    //собираем выплаты, по которым не сформированы оконч. ведомости
    aSumEntry := SumByEntry( cPayType, dDate, cJobsCode, 2, cWagesCode,,,,lCheckSheet )
    aArr := EXTRACT( { 0, "", 0 }, "VAL", IF( SELECT( "PYMNT" ) > 0, "PYMNT", MEMVAR->SprPath + "pymnt.dbf" ), {"PRIORITY","NAME","GROUP"}, { "CODE", cPayType } )
    IF !EMPTY( aArr[ 3 ] )
        IF !EMPTY( aSumEntry )
// Подготавливаем сумму для размазывания
            nSumEntry := 0
            nSumAll   := 0
            AEVAL( aSumEntry, {|x| nSumEntry += x[3] } )
            FOR nI := 1 TO LEN( aSumEntry )
                IF nI < LEN( aSumEntry )
                    IF lRound
                        nSumTax    := ROUND( D( aSumEntry[nI][3], nSumEntry ) * nSum, 0 )           // Сумма-результат
                    ELSE
                        nSumTax    := ROUND( D( aSumEntry[nI][3], nSumEntry ) * nSum, 2 )           // Сумма-результат
                    ENDIF
                    nSumAll    += nSumTax
                ELSE
                    nSumTax    := nSum - nSumAll
                ENDIF
                IF !EMPTY(nSumTax)
                                    // Должность               счет        сумма (размазанная)
                    AADD( aReturn, { aSumEntry[ nI ][ 4 ],  aSumEntry[ nI ][ 5 ], nSumTax, aSumEntry[ nI ][ 8 ]/*, aSumEntry[ nI ][ 9 ]*/ } )
                ENDIF
            NEXT
        ELSE
// Сумма по тблице входимости не удалась (не сложилось...) Ставим умолчательно Гл.должность, Счет по умолчанию для данного Пайтайпа, Всю сумму
            aReturn := {}
        ENDIF
    ENDIF

    RETURN { aReturn, aArr }
*------------------------------------------------------------------------
*
    FUNCTION PersMessage( cMessage,;      // 1 Сообщение
             aItems,;                // 2 Массив пунктов
             cHead,;                 // 3 Заголовок
             nColorCombin,;          // 4 Номер цветокомбинации
             lVertHoriz,;            // 5 Верикальное/горизонтальное
             lCenter,;               // 6 Тип центровки сообщения
             aUserInfo,;             // 7 Массив с доп. информацией
             cTypeIcons,;            // 8 тип иконки
             nSayFio)                // 9
*------------------------------------------------------------------------

    LOCAL nReturn := 0

    DEFAULT nSayFio IS 0

    IF !EMPTY( cMessage )
        IF LEFT( cMessage, 1 ) = "@"
            cMessage := SUBSTR( cMessage, 2 )
            IF LEFT( cMessage, 1 )$"!S?I"
                cTypeIcons := LEFT( cMessage, 1 )
                cMessage := SUBSTR( cMessage, 2 )
            ENDIF

            IF EMPTY( nSayFio )
                SaveSet()
                cMessage := IF( FIELDPOS( "CODE" )>0,'Сотрудник: ' + ALLTRIM( SayFIO(, FIELD->CODE ) ) + ', таб.номер: '+ALLTRIM( FIELD->CODE )+', ', '') + ;
                            IF( FIELDPOS( "ENT" )>0 .AND. !EMPTY(FIELD->ENT),'учреждение: "' + ALLTRIM( SayREFER("ENT",FIELD->ENT) ) + '", ', '' ) + cMessage
                RestSet()
            ELSE
                cMessage := IF( FIELDPOS( "CODE" )>0,'Сотрудник: ' + ALLTRIM(PERSN->SURNAME ) + " " + LEFT( ALLTRIM( PERSN->NAME ), 1)  + "." +  LEFT( ALLTRIM( PERSN->SECNAME ), 1) + "." + ', таб.номер: '+ALLTRIM( FIELD->CODE )+', ', '') + ;
                            IF( FIELDPOS( "ENT" )>0 .AND. !EMPTY(FIELD->ENT),'учреждение: "' + ALLTRIM( SayREFER("ENT",FIELD->ENT) ) + '", ', '' ) + cMessage

            ENDIF
        ENDIF
        nReturn := Message( cMessage, aItems, cHead, nColorCombin, lVertHoriz, lCenter, aUserInfo, cTypeIcons )
    ENDIF

    RETURN nReturn

*------------------------------------------------------------------------
*   Функция для доставания сумм по сотруднику
    FUNCTION GetCalcsSum( ohParams )
*------------------------------------------------------------------------

    LOCAL ohRet       := Hash():new()
    LOCAL oTables     := UTables():new()
    LOCAL aJobsCodes  := {}
    LOCAL xTemp
    LOCAL aScope      := { SaveScope(), NIL, NIL }
    LOCAL cCardCode
    LOCAL nI, nIndex, nCount
    LOCAL dSDate, dFDate, dDate
    LOCAL aGroup      := ohParams:get( "GROUPBY", { "IF(MODE<40,0,1)" } )
    LOCAL xVal
    LOCAL xTmp
    LOCAL aEnts       := ohParams:get( "ENT", NIL )
    LOCAL cFaceTypes  := ohParams:get( "FACETYPE", NIL )
    LOCAL aMode       := ohParams:get( "MODE", NIL )
    LOCAL aGroups     := ohParams:get( "GROUP", NIL )
    LOCAL cUserFilter := ohParams:get( "USERFILTER", NIL )
    LOCAL aValues     := ohParams:get( "VALUE", { "SUMMA" } )
    LOCAL cFilter     := ""
    LOCAL aPYMNT      := EXTRACT( {}, "ARR", MEMVAR->SprPath + "pymnt.dbf", { "CODE", "GNI01" }, ".T." )
    LOCAL nPyMNT      := 0
    LOCAL oError
    LOCAL lGNICode    := ohParams:get( "ПроверятьКодГНИ", .F. )

    SaveSet()

    BEGIN SEQUENCE

    IF VALTYPE( aGroup ) != "A" .OR. VALTYPE( aValues ) != "A"
        BREAK
    ENDIF

    IF ! EMPTY( cFaceTypes )
        // Разбираем как переданы типы физ.лиц
        IF VALTYPE( cFaceTypes ) = "A"
            xVal := ""
            FOR nI := 1 TO LEN( cFaceTypes )
                xVal += STRZERO( cFaceTypes[nI], 2 ) + ";"
            NEXT
            cFaceTypes := xVal
        ELSEIF VALTYPE( cFaceTypes ) = "N"
            cFaceTypes := STRZERO( cFaceTypes, 2 )
        ELSEIF VALTYPE( cFaceTypes ) = "C"
        ELSE
            BREAK
        ENDIF
    ENDIF

    IF !EMPTY( aMode )
        // Разбираем, как переданы режимы светимости CALCS
        IF VALTYPE( aMode ) = "A"
            xVal := ""
            FOR nI := 1 TO LEN( aMode )
                xVal += STRZERO( aMode[nI], 2 ) + ";"
            NEXT
            aMode := xVal
        ELSEIF VALTYPE( aMode ) = "N"
            aMode := STRZERO( aMode, 2 )
        ELSEIF VALTYPE( aMode ) = "C"
        ELSE
            BREAK
        ENDIF
    ENDIF

    IF !EMPTY( aGroups )
        // Разбираем, как переданы группы видов оплат CALCS
        IF VALTYPE( aGroups ) = "A"
            xVal := ""
            FOR nI := 1 TO LEN( aGroups )
                xVal += STRZERO( aGroups[nI], 2 ) + ";"
            NEXT
            aGroups := xVal
        ELSEIF VALTYPE( aGroups ) = "N"
            aGroups := STRZERO( aGroups, 2 )
        ELSEIF VALTYPE( aGroups ) = "C"
        ELSE
            BREAK
        ENDIF
    ENDIF

    IF !EMPTY( aEnts )
        // Разбираем, как переданы учреждения
        IF VALTYPE( aEnts ) = "A"
            xVal := ""
            FOR nI := 1 TO LEN( aEnts )
                xVal += aEnts[nI] + ";"
            NEXT
            aEnts := xVal
        ELSEIF VALTYPE( aEnts ) = "C"
        ELSE
            BREAK
        ENDIF
    ENDIF

    IF ! EMPTY( aMode )
        cFilter += "STRZERO(MODE,2)$'" + aMode + "'"
    ENDIF

    IF ! EMPTY( aGroups )
        cFilter += IF( EMPTY( cFilter ), "", ".AND." ) + "STRZERO(GROUP,2)$'" + aGroups + "'"
    ENDIF

    IF !EMPTY( cUserFilter )
        cFilter += IF( EMPTY( cFilter ), "", ".AND." ) + cUserFilter
    ENDIF

    dSDate := ohParams:get( "SDATE", BOM( MEMVAR->DATE ) )
    dFDate := ohParams:get( "FDATE", BOM( MEMVAR->DATE ) )

    IF SELECT( "JOBS_" ) = 0 .AND. ! MODINIT( { "JOBS_" } )
        BREAK
    ENDIF
    JOBS_->( SaveSet() )
    aScope[2] := JOBS_->( SaveScope() )
    aScope[3] := JOBS_->( DBFILTER() )
************************************************************************************
* Цель данного блока - из той ереси, что нам передали, выбрать что-то удобоваримое *
************************************************************************************
    JOBS_->( DB_SETORDER( "RECCODE" ) )
    IF ! EMPTY( aEnts )
        JOBS_->( SETFILTER( "FIELD->ENT$'" + aEnts + "'" ) )
    ENDIF
    IF ohParams:Get( "привязать_к_налоговой_карточке", .F. )
    // Просят осуществить выборку, исходя из кода налоговой карточки, указанной в JOBS_ для данного JOBSCODE
        IF EMPTY( xTemp := ohParams:Get( "JOBSCODE" ) ) .OR. VALTYPE( xTemp ) != "C"
            BREAK
        ENDIF
        IF JOBS_->( DBSEEK( xTemp ) )
            cCardCode := JOBS_->CARDNAME
        ELSE
            BREAK
        ENDIF
        aJobsCodes := Extract( {}, "ARR", "JOBS_", "RECCODE", { "CODE", JOBS_->CODE, JOBS_->CODE, "FIELD->CARDNAME=='" + cCardCode + "'" + IF(!EMPTY( cFaceTypes ),".AND.STRZERO(TYPE,2)$'"+cFaceTypes+"'","") } )
    ELSE
        xTemp := ohParams:Get( "JOBSCODE" )
        // Переданы ли JOBSCODE?
        IF !EMPTY( xTemp )
            IF VALTYPE( xTemp ) = "A"
                aJobsCodes := xTemp
            ELSEIF VALTYPE( xTemp ) = "C"
                aJobsCodes := { xTemp }
            ELSE
                BREAK
            ENDIF
            xTemp := NIL
        ENDIF
        xTemp := ohParams:Get( "CODE" )
        IF xTemp = NIL
            aJobsCodes := Extract( {}, "ARR", "JOBS_", "RECCODE", { "CODE", "", "", IF(!EMPTY( cFaceTypes ), "STRZERO(TYPE,2)$'" + cFaceTypes + "'", "" ) } )
        ELSEIF VALTYPE( xTemp ) != "C"
            BREAK
        ENDIF
        IF ! EMPTY( xTemp ) .AND. EMPTY( aJobsCodes )
        // Передан ли CODE? если передан, то должен быть пуст JOBSCODE (сами будем формировать)
            aJobsCodes := Extract( {}, "ARR", "JOBS_", "RECCODE", { "CODE", xTemp, xTemp, IF(!EMPTY( cFaceTypes ), "STRZERO(TYPE,2)$'" + cFaceTypes + "'", "" ) } )
        ELSEIF EMPTY( xTemp ) .AND. !EMPTY( aJobsCodes )
        // Не передан CODE но передан JOBSCODE?
        ENDIF
    ENDIF

    dDate := dSDate
    // Вся информация известна, начинаем обработку CALCS
    DO WHILE YEAR( dDate ) <= YEAR( dFDate )
        FOR nI := 1 TO LEN( aJobsCodes )
            IF JOBS_->( DBSEEK( aJobsCodes[nI] ) )
                IF oTables:select( "CALCS", JOBS_->ENT,, YEAR( dDate ) )
                    DB_SETORDER( "AVERAGE" )
                    SET SCOPE TO JOBS_->CODE + JOBS_->RECCODE + DTOS( BOM( dSDate ) ), ;
                                 JOBS_->CODE + JOBS_->RECCODE + DTOS( BOM( dFDate ) )
                    SETFILTER( cFilter )
                    GO TOP
                    DO WHILE !EOF()
                        IF !lGNICode .OR. FIELD->MODE >= 40 .OR. ( !EMPTY( nPyMNT := ASCAN( aPyMNT, {|x| x[ 1 ] == FIELD->PAYTYPE } ) ) .AND. !EMPTY( aPYMNT[ nPyMNT ][ 2 ] ) )
                            xTemp := ""
                            xTmp := ARRAY( LEN( aGroup ) )
                            // Обрабатываем группировку GROUPBY и подготавливаем массив для хеша
                            FOR nIndex := 1 TO LEN( aGroup )
                                IF aGroup[ nIndex ] == "Дата_выплаты"
                                    SaveSet()
                                    xTmp[ nIndex ] := XTOX( "", "D" )
                                    xVal := FIELD->SHLSTCODE
                                    IF oTables:select( "SHLST",,, YEAR( dDate ) )
                                        DB_SETORDER( "RECCODE" )
                                        IF DBSEEK( xVal )
                                            xVal := FIELD->SHCODE
                                            IF oTables:select( "SHEET",,, YEAR( dDate ) )
                                                DB_SETORDER( "RECCODE" )
                                                IF DBSEEK( xVal )
                                                    xTmp[ nIndex ] := FIELD->OUTDATE
                                                ENDIF
                                            ENDIF
                                        ENDIF
                                    ENDIF
                                    RestSet()
                                ELSE
                                    xTmp[ nIndex ] := &( aGroup[ nIndex ] )
                                    xTemp += XTOC( xTmp[ nIndex ] )
                                ENDIF
                            NEXT
                            // Производим поиск в хеше
                            IF ( xVal := ohRet:get( xTemp ) ) = NIL
                                // Если не нашли - создаем запись
                                xVal := {{}, AFILL( ARRAY( LEN( aValues ) ), 0 ) }
                                FOR nIndex := 1 TO LEN( aGroup )
                                    AADD( xVal[1], xTmp[ nIndex ] )
                                NEXT
                                ohRet:put( xTemp, xVal )
                            ENDIF
                            FOR nCount := 1 TO LEN( aValues )
                                // Выполняем строковые блоки кода, переданные в VALUE и плюсуем их в хеш
                                xVal[2][nCount] += &( aValues[ nCount ] )
                            NEXT
                        ENDIF
                        SKIP
                    ENDDO
                    SETFILTER()
                ENDIF
            ENDIF
        NEXT
        dDate := ADDMONTH( dDate, 12 )
    ENDDO

    oTables:destroy()

    RECOVER USING oError

        IF VALTYPE( oError ) = "O"
            SayError( oError )
        ENDIF

    END SEQUENCE

    IF aScope[2] != NIL
        JOBS_->( RestSet() )
        JOBS_->( RestScope( aScope[2] ) )
        JOBS_->( SETFILTER( aScope[3] ) )
    ENDIF

    RestSet()
    RestScope( aScope[1] )

    RETURN ohRet


*------------------------------------------------------*
*   просмотр строки в CALCS

    FUNCTION CalcsCard( nMode1, nMode2 )
*------------------------------------------------------*
    STATIC lCalcsCardRun := .F.

    LOCAL cFileName := FILE_NAME( "CALCS",Ent,,Year )
    LOCAL cDescName := FILEDESC( "CALCS" )
    LOCAL cCardName := CARD_NAME( "CALCS.CRD", "PERSONAL" )

    MEMVAR aPlusArr
    MEMVAR aMinusArr
    MEMVAR npFacesType

    // Если карточка уже запущена
    IF lCalcsCardRun .OR. Alias() != "CALCS" .OR. EOF()
        RETURN NIL
    ENDIF

    lCalcsCardRun := .T.

    SaveSet()

    BEGIN SEQUENCE

        WindOpen( "CalcsCardWind",, MEMVAR->cpCalcsHeader,,,,,,,.F. )
        SetFKey( { "Помощь;Help('CALCS')",,,,,,,,"Кальк.;Calculator()" } )

        DbSelectArea("CALCS")

        CRDBROWSE FILE ( cFileName );
           DESCRIPTION ( cDescName );
                  CARD ( cCardName );
                OPENLY ;
                   NEW ( .F. )

        MEMVAR->lpStrongUpdate := .T.

        RestFKey()
        WindClose()

    END SEQUENCE

    IF npFacesType == 10
        InitWageRelations()
    ELSE
        InitUnWageRelations()
    ENDIF
    RestSet()

    lCalcsCardRun := .F.

    RETURN NIL


*------------------------------------------------------*
*   обработка справочника групп оплат и справочника видов оплат на наличие
*   записи с кодом 'Долг за учреждением'
    FUNCTION CheckPymntGroup84()
*------------------------------------------------------*
    LOCAL lResult := .F.

    BEGIN SEQUENCE

        IF !ReferInit( { "PMTGR", "PYMNT" } )
            BREAK
        ENDIF

        PMTGR->( DB_SETORDER( "CODE" ) )
        IF !PMTGR->( DBSEEK( "84" ) )
            PMTGR->( DBAPPEND() )
            PMTGR->CODE := 84
            PMTGR->NAME := "Долг за предприятием"
            PMTGR->( DBCOMMIT() )
        ENDIF

        PYMNT->( DB_SETORDER( "GROUP" ) )
        IF !PYMNT->( DBSEEK( "84" ) )
            ALERT( "В справочнике видов оплат долг за предприятием не обнаружен;Добавьте вид оплаты с кодом группы 84 (долг за предприятием)" )
            BREAK
        ENDIF

        lResult := .T.

    END SEQUENCE

    RETURN lResult

*------------------------------------------------------*
*   Обновление OUTCM для получения долгов п/п
    FUNCTION UpdateOutcmEntDolg( lShowStatus)
*------------------------------------------------------*
    LOCAL aOutcm := {}
    LOCAL oObj
    LOCAL oLocks
    LOCAL xTemp
    LOCAL lResult
    LOCAL nI, nJ
    LOCAL aObjects
    LOCAL aLocked := {}
    LOCAL nSum
    LOCAL nChangeSum := 0
    LOCAL oCalcAcc

    DEFAULT lShowStatus IS .F.

    IF EMPTY( SELECT( "WAGES" ) ) .OR. EMPTY( SELECT( "CALCS" ) ) .OR. EMPTY( SELECT( "OUTCM" ) )
        RETURN .F.
    ENDIF

    IF !ReferInit( { "PRSCT", "SUCH", "POSTS" } )
        RETURN .F.
    ENDIF

    IF BOM( GetCloseDate() ) >= BOM(MEMVAR->DATE) .OR. WAGES->LOCKED
        RETURN .F.
    ENDIF

    oLocks   := RecLocks():new()
    aLocked  := {}
    aObjects := {}

    IF lShowStatus
        BeginStatus()
        SayStatus( "Долг за предприятием" )
    ENDIF

    SaveSet()
    BEGIN SEQUENCE
        SELECT CALCS
        DB_SETORDER( "CODE" )

        SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( 10, 2 ),;
                     DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( 50, 2 )
        GO TOP
        oCalcAcc := CalcsAccs():new()
        WHILE !EOF()
            IF ( FIELD->MODE >= 10 .AND. FIELD->MODE <= 30 ) .OR. FIELD->GROUP == 84

                IF FIELD->SUMMADP > 0

                    oObj := HashIvar():new()
                    oObj:wagescode := WAGES->RECCODE
                    oObj:summa     := CALCS->SUMMADP
                    oObj:post      := CALCS->POST
                    oObj:type      := 50

                    oCalcAcc:lIsPlus := .T.
                    IF ! oCalcAcc:LoadFromCalcs()
                        BREAK
                    ENDIF

                    oObj:oAcc        := oCalcAcc:wacc
                    oObj:oAcc:acckf1 := SPACE( 6 )
                    oObj:oAcc:acckf2 := SPACE( 6 )
                    oObj:oAcc:acckf3 := SPACE( 6 )
                    oObj:oAcc:checkKGU( NIL, .T. )

                    oObj:reccode := OUTCM->( UQ_CODE() )
                    oObj:canjoin := ( ABS( CALCS->SUMMA - CALCS->SUMMADP ) >= 0.001 )

                    WHILE !oLocks:Lock( oObj:reccode )
                    ENDDO // очень надо!

                    AADD( aLocked, RECNO() )

                    AADD( aObjects, oObj )

                ENDIF

            ENDIF
            SKIP
        ENDDO

        // удаление замещаемых записей в OUTCM
        SELECT OUTCM
        DB_SETORDER( "WAGESCODE" )
        SET SCOPE TO WAGES->RECCODE
        GO TOP
        WHILE !EOF()
            IF FIELD->TYPE >= 50
                nChangeSum -= FIELD->SUMMA
                SOFT_DELETE()
            ELSE
                SKIP
            ENDIF
        ENDDO

        nSum := 0
        // добавление записей в OUTCM c одновременным замещением
        FOR nI := 1 TO LEN( aObjects )
            oObj := aObjects[ nI ]

            SOFT_APPEND()
            FIELD->WAGESCODE := oObj:wagescode
            FIELD->SUMMA     := oObj:summa
            FIELD->POST      := oObj:post
            FIELD->DBFKR     := oObj:oAcc:fkr
            FIELD->DBACC     := oObj:oAcc:acc
            FIELD->DBKGU     := oObj:oAcc:kgu

            FIELD->RECCODE   := oObj:reccode
            FIELD->TYPE      := oObj:type
            nSum += oObj:summa
            nChangeSum += oObj:summa
        NEXT
        SELECT WAGES
        IF oLocks:Lock()
            WAGES->OUTCOMEP   := nSum
        ENDIF

        lResult := .T.
    END SEQUENCE

    IF lShowStatus
        EndStatus()
    ENDIF

    oLocks:UnLockAll()

    RestSet()

    RETURN nChangeSum

*------------------------------------------------------*
*   Обновление долгов, получаемых в результате перевыдачи по ведомостям
    FUNCTION UpdateOutcmVedDolg( lShowStatus, lCheckOnly )
*------------------------------------------------------*
    LOCAL aCalcs
    LOCAL oCalc
    LOCAL aPays  // все выплаты по ведомостям
    LOCAL oPay
    LOCAL xTemp
    LOCAL aTable
    LOCAL nI
    LOCAL oObj
    LOCAL cFkr, cDAcc
    LOCAL nIndex
    LOCAL nSum := 0
    LOCAL lLocked
    LOCAL oSheet
    LOCAL aCalcsScope, cCalcsFilter
    LOCAL nSums

    LOCAL oOutcome

    oOutcome := GrouppedValues():new()

    DEFAULT lShowStatus IS .F.
    DEFAULT lCheckOnly  IS .F.

    IF lShowStatus
        BeginStatus()
        SayStatus( "Долг за работником по ведомостям" )
    ENDIF

    IF EMPTY( SELECT( "WAGES" ) ) .OR. EMPTY( SELECT( "CALCS" ) ) .OR. EMPTY( SELECT( "OUTCM" ) )
        RETURN .F.
    ENDIF

    IF !MODINIT( { "SHEET", "SHLST" }, YEAR( WAGES->MONTH ) )
        RETURN .F.
    ENDIF

    IF !ReferInit( { "PRSCT", "SUCH", "POSTS" } )
        RETURN .F.
    ENDIF

    aCalcs := DBTable():new()
    aPays  := DBTable():new()
    oSheet := PaySheet():new()
    // загружаем начислений - удержания сотрудника
    IF !aCalcs:load( "CALCS", { "CODE", DTOS( BOM( WAGES->MONTH ) ) + WAGES->CODE + WAGES->RECCODE + "10",;
                                        DTOS( BOM( WAGES->MONTH ) ) + WAGES->CODE + WAGES->RECCODE + "50"} )
        RETURN .F.
    ENDIF

    // загружаем оплаты сотрудника
    IF !aPays:load( "SHLST", { "BROWS", WAGES->CODE + WAGES->JOBSCODE + DTOS( BOM( WAGES->MONTH ) ),;
                                        WAGES->CODE + WAGES->JOBSCODE + DTOS( BOM( WAGES->MONTH ) ), "!EMPTY(FIELD->ENT)" } )
        RETURN .F.
    ENDIF

    SaveSet()
    CALCS->( SaveSet() )
    aCalcsScope  := CALCS->( SaveScope() )
    cCalcsFilter := CALCS->( DBFILTER() )

    DBSELECTAREA("CALCS")
    DB_SETORDER("RECCODE")
    SET FILTER TO
    SET SCOPE TO

    DBGOTOP()

    BEGIN SEQUENCE
        aTable := {}
* ---------------------- очищаем список  ------------------------ *
        SELECT OUTCM
        DB_SETORDER( "WAGESCODE" )
        SET SCOPE TO WAGES->RECCODE
        GO TOP
        WHILE !EOF()
            IF FIELD->TYPE == 10
                oOutcome:put( FIELD->DACC + FIELD->FKR, -FIELD->SUMMA, { FIELD->POST } )
                nSum -= FIELD->SUMMA
                IF !lCheckOnly
                    SOFT_DELETE()
                ELSE
                    SKIP
                ENDIF
            ELSE
                SKIP
            ENDIF
        ENDDO
* ---------------------- удаляем из удержаний перечисления в банк ------------------------ *
        WHILE .T.
            xTemp := ASCAN( aCalcs:rows, {|x| x:group == 80 } )
            IF EMPTY( xTemp )
                EXIT
            ENDIF
            AREMOVE( aCalcs:rows, xTemp )
        ENDDO

* ---------------------- опеределяем список ------------------------ *
        FOR nI := 1 TO LEN( aCalcs:rows )
            oCalc := aCalcs:rows[ nI ]

            IF CALCS->( DBSEEK(oCalc:RECCODE) )
                DBSELECTAREA("CALCS")
                // определяем кбк

                oCalc:oCalcsAcc := CalcsAccs():new()
                oCalc:oCalcsAcc:lIsPlus := ( oCalc:mode <= 30 )
                oCalc:oCalcsAcc:LoadFromObject( oCalc )
                RestrictAnalitHash( oCalc:oCalcsAcc:ohAnalit, oCalc:oCalcsAcc:wacc )
                oCalc:oCalcsAcc:RefreshSeekValues()

                nIndex := ASCAN( aTable, {|x| x:oAcc:GetSeekValue() == oCalc:oCalcsAcc:wacc:GetSeekValue() } )

                IF EMPTY( nIndex )
                    oObj := HashIvar():new()
                    oObj:oAcc := oCalc:oCalcsAcc:wacc
                    oObj:post  := IF( EMPTY( oCalc:post ), WAGES->MAINPOST, oCalc:post )
                    IF oCalc:mode <= 30
                        oObj:summa := oCalc:summa - oCalc:summadp
                    ELSE
                        oObj:summa := -( oCalc:summa - oCalc:summadp )
                    ENDIF
                    oObj:hasFinalSheet := .F.
                    AADD( aTable, oObj )
                ELSE
                    xTemp := aTable[ nIndex ]:summa
                    IF oCalc:mode <= 30
                        xTemp += ( oCalc:summa - oCalc:summadp )
                    ELSE
                        xTemp -= ( oCalc:summa - oCalc:summadp )
                    ENDIF
                    aTable[ nIndex ]:summa := xTemp
                ENDIF
            ENDIF
        NEXT
* ---------------------- пробегаем и обнуляем положительные суммы ------------------------ *
        FOR nI := 1 TO LEN( aTable )
            IF aTable[ nI ]:summa > 0.001
                aTable[ nI ]:summa := 0
            ELSE
                xTemp := -aTable[ nI ]:summa
                aTable[ nI ]:summa := xTemp
            ENDIF
        NEXT
* ---------------------- опять  ------------------------ *
        FOR nI := 1 TO LEN( aCalcs:rows )
            oCalc := aCalcs:rows[ nI ]

            IF oCalc:group == 50
                LOOP
            ENDIF

            IF CALCS->( DBSEEK(oCalc:RECCODE) )
                DBSELECTAREA("CALCS")
                // определяем кбк

                oCalc:oCalcsAcc := CalcsAccs():new()
                oCalc:oCalcsAcc:lIsPlus := ( oCalc:mode <= 30 )
                oCalc:oCalcsAcc:LoadFromObject( oCalc )
                RestrictAnalitHash( oCalc:oCalcsAcc:ohAnalit, oCalc:oCalcsAcc:wacc )
                oCalc:oCalcsAcc:RefreshSeekValues()

                nIndex := ASCAN( aTable, {|x| x:oAcc:GetSeekValue() == oCalc:oCalcsAcc:wacc:GetSeekValue() } )
                IF !EMPTY( nIndex )
                    xTemp := aTable[ nIndex ]:summa
                    IF oCalc:mode <= 30
                        xTemp += ( oCalc:summa - oCalc:summadp )
                    ELSE
                        xTemp -= ( oCalc:summa - oCalc:summadp )
                    ENDIF
                    aTable[ nIndex ]:summa := xTemp
                ENDIF
            ENDIF
        NEXT
* ---------------------- бежим по ведомостям ------------------------ *
        FOR nI := 1 TO LEN( aPays:rows )
            oPay := aPays:rows[ nI ]

            IF oSheet:LoadByReccode( oPay:shcode )
                cFkr  := oSheet:wacc:GetSeekValue()
            ELSE
                cFkr  := ""
            ENDIF

            nIndex := ASCAN( aTable, {|x| x:oAcc:GetSeekValue() == cFkr } )

            IF !EMPTY( nIndex)
                xTemp := aTable[ nIndex ]:summa
                xTemp -= oPay:g_byhand
                aTable[ nIndex ]:summa := xTemp
                IF oSheet:lIsFinal
                    aTable[ nIndex ]:hasFinalSheet := .T.
                ENDIF
            ENDIF
        NEXT
* ---------------------- все строки таблицы aTable, у которых сумма отрицательная - наши ------------------------ *
        SELECT OUTCM
        FOR nI := 1 TO LEN( aTable )
            IF aTable[ nI ]:summa < -0.001 .AND. aTable[ nI ]:hasFinalSheet
                aTable[ nI ]:oAcc:acckf1 := SPACE( 6 )
                aTable[ nI ]:oAcc:acckf2 := SPACE( 6 )
                aTable[ nI ]:oAcc:acckf3 := SPACE( 6 )
                aTable[ nI ]:oAcc:CheckKGU( NIL, .T. )
                // формируем долг на сию сумму
                IF !lCheckOnly
                    SOFT_APPEND()
                    FIELD->WAGESCODE := WAGES->RECCODE
                    FIELD->SUMMA     := -aTable[ nI ]:summa
                    FIELD->POST      := aTable[ nI ]:post
                    FIELD->DBFKR     := aTable[ nI ]:oAcc:fkr
                    FIELD->DBACC     := aTable[ nI ]:oAcc:acc
                    FIELD->DBKGU     := aTable[ nI ]:oAcc:kgu
                    FIELD->DBACCKF1  := aTable[ nI ]:oAcc:acckf1
                    FIELD->DBACCKF2  := aTable[ nI ]:oAcc:acckf2
                    FIELD->DBACCKF3  := aTable[ nI ]:oAcc:acckf3
                    FIELD->RECCODE   := UQ_CODE()
                    FIELD->TYPE      := 10
                    nSum += FIELD->SUMMA
                ENDIF
                oOutcome:put( aTable[ nI ]:oAcc:GetFullSeekValue(), -aTable[ nI ]:summa, { aTable[ nI ]:post, aTable[ nI ]:oAcc } )
            ENDIF
        NEXT

        SELECT WAGES

        IF !lCheckOnly
            lLocked := IsLocked()
            IF !lLocked
                WHILE !ReferLock( , RECNO() )
                ENDDO
            ENDIF
            WAGES->OUTCOME    += nSum
            WAGES->RESTBYHAND += nSum
            IF !lLocked
                Un_Lock( RECNO() )
            ENDIF
        ENDIF

    END SEQUENCE

    CALCS->( RestScope(aCalcsScope) )
    CALCS->( SetFilter(cCalcsFilter) )
    CALCS->( RestSet() )

    RestSet()

    IF lShowStatus
        EndStatus()
    ENDIF

    RETURN oOutcome

* ------------------------------------------------------------------ *
*   Свечение долга за работником ( предприятием )
    FUNCTION SayPersonOutcome( lPerson )
* ------------------------------------------------------------------ *
    LOCAL nValue := 0
    LOCAL aGrouped := {}
    LOCAL nI

    IF EMPTY( WAGES->RECCODE )
        RETURN 0
    ENDIF

    SELECT OUTCM
    DB_SETORDER( "WAGESTYPE" )
    SET SCOPE TO
    IF DBSEEK( WAGES->RECCODE )
        WHILE FIELD->WAGESCODE == WAGES->RECCODE .AND. !EOF()
            nI := ASCAN( aGrouped, {|x| x[ 1 ] == FIELD->DACC .AND. x[ 2 ] == FIELD->FKR } )
            IF EMPTY( nI )
                AADD( aGrouped, { FIELD->DACC, FIELD->FKR, IF( FIELD->TYPE <= 40, FIELD->SUMMA, -FIELD->SUMMA ) } )
            ELSE
                aGrouped[ nI ][ 3 ] += IF( FIELD->TYPE <= 40, FIELD->SUMMA, -FIELD->SUMMA )
            ENDIF
            SKIP
        ENDDO
    ENDIF

    FOR nI := 1 TO LEN( aGrouped )
        IF lPerson
            nValue += MAX( aGrouped[ nI ][ 3 ], 0 )
        ELSE
            nValue -= MIN( aGrouped[ nI ][ 3 ], 0 )
        ENDIF
    NEXT

    SELECT WAGES
    RETURN nValue


* ------------------------------------------------------------------ *
*   Удаление автоматически расчитанных видов оплат, в случае, если у
*   работника есть такие же, но добавленные вручную

    FUNCTION RemovePayTypesAsManual( aRules )
* ------------------------------------------------------------------ *
    LOCAL lResult := .F.
*    10 - По тарификации        - Подлежит удалению
*    20 - Разовые начисления
*    30 - Автоначисления        - Подлежит удалению
*    40 - Разовые удержания
*    50 - Автоудержания         - Подлежит удалению
    LOCAL nRule
    LOCAL oCalcs, oCalc
    LOCAL cAlias, aCalcsScope, nCalcsRecno
    LOCAL nPos
    LOCAL oCalcAcc

    DEFAULT aRules IS { /* тип оплаты (mode), сформированный автоматически , тип оплаты (mode), в котором искать вручную добавленный */;
                      /*{ 10, 20 },*/;
                      { 30, 20 },;
                      { 50, 40 } }

    cAlias := ALIAS()
    SELECT CALCS
    aCalcsScope := SaveScope()
    nCalcsRecno := RECNO()

    DB_SETORDER( "CODE" )
    BEGIN SEQUENCE

        oCalcs := DBTable():new()
        FOR nRule := 1 To LEN( aRules )
            IF oCalcs:Load( "CALCS", { "CODE", DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( aRules[ nRule ][ 2 ], 2 ),;
                                               DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( aRules[ nRule ][ 2 ], 2 ) } )

                SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( aRules[ nRule ][ 1 ], 2 ),;
                             DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + STRZERO( aRules[ nRule ][ 1 ], 2 )
                GO TOP
                WHILE !EOF()
                    nPos := ASCAN( oCalcs:rows, {|x| x:paytype == FIELD->PAYTYPE .AND. ;
                        x:dfkr == FIELD->DFKR .AND. x:dbacc == FIELD->DBACC .AND. x:dbkgu == FIELD->DBKGU .AND. ;
                        x:dbacckf1 == FIELD->DBACCKF1 .AND. x:dbacckf2 == FIELD->DBACCKF2 .AND. x:dbacckf3 == FIELD->DBACCKF3 .AND. ;
                        x:kacc == FIELD->KACC .AND. x:kkgu == FIELD->KKGU .AND. ;
                        x:kacckf1 == FIELD->KACCKF1 .AND. x:kacckf2 == FIELD->KACCKF2 .AND. x:kacckf3 == FIELD->KACCKF3 ;
                         .AND. x:post == FIELD->POST .AND.;
                        FIELD->DATEPRODUC == x:dateproduc .AND. EMPTY( x:fdaterec ) } )

                    IF !EMPTY( nPos ) .AND. !EMPTY( FIELD->CALCRCODE ) .AND. !CalcSheets():CalcWasPayed()
                        // найден вручную добавленный вид оплаты
                        SOFT_DELETE( .T. )
                    ELSE
                        SKIP
                    ENDIF
                ENDDO
            ENDIF
        NEXT

        lResult := .T.
    END SEQUENCE

    SELECT CALCS
    RestScope( aCalcsScope )
    DBGOTO( nCalcsRecno )
    DbSelectArea( cAlias )

    RETURN lResult


* ------------------------------------------------------------------ *
*   Проверка начислений, удержаний и долгов сотрудника на непустоту счетов, КБК и видов деятельности
*   работника есть такие же, но добавленные вручную

    FUNCTION CheckAccPersonCalcs( nMaxMessages )
* ------------------------------------------------------------------ *
    LOCAL cMessage := "" // здесь будет список ошибок по сотрунику
    LOCAL aMessages := {}

    LOCAL cAlias, aCalcsScope, nCalcsRecno
    LOCAL aOutcmScope, nOutcmRecno
    LOCAL nI
    LOCAL oParams
    LOCAL oOutcome
    LOCAL nLenDacc, nLenFkr, cDacc, cFkr
    LOCAL oAcc

    DEFAULT nMaxMessages IS 999

    cAlias := ALIAS()

    SELECT CALCS
    aCalcsScope := SaveScope()
    nCalcsRecno := RECNO()

    DB_SETORDER( "CODE" )
    SET SCOPE TO DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + "00",;
                 DTOS( BOM( MEMVAR->DATE ) ) + WAGES->CODE + WAGES->RECCODE + "99"

    SELECT OUTCM
    aOutcmScope := SaveScope()
    nOutcmRecno := RECNO()

    DB_SETORDER( "WAGESTYPE" )
    SET SCOPE TO WAGES->RECCODE

    BEGIN SEQUENCE

        SELECT OUTCM
        GO TOP

            WHILE ! EOF()
                oAcc := CalcsAcc():new()
                oAcc:LoadDebetAcc( "OUTCM" )
                IF LEN( ALLTRIM( oAcc:fkr ) ) < 4
                    AADD( aMessages, "КБК для записи в долгах " + IF( OUTCM->SUMMA > 0, "за работником", "за предприятием" ) )
                ENDIF
                IF EMPTY( ALLTRIM( oAcc:acc ) )
                    AADD( aMessages, "счет для записи в долгах " + IF( OUTCM->SUMMA > 0, "за работником", "за предприятием" ) )
                ENDIF
                SKIP
            ENDDO

    END SEQUENCE

    SELECT CALCS
    RestScope( aCalcsScope )
    DBGOTO( nCalcsRecno )

    SELECT OUTCM
    RestScope( aOutcmScope )
    DBGOTO( nOutcmRecno )

    DbSelectArea( cAlias )

    FOR nI := 1 TO MIN( LEN( aMessages ), nMaxMessages )
        cMessage := cMessage + aMessages[ nI ] + ";"
    NEXT
    IF !EMPTY( nI ) .AND. nI <= LEN( aMessages )
        cMessage += "...... еще ......;"
    ENDIF

    RETURN cMessage

* -------------------------------------------------------- *
*   Функция возвращает хэш пимента по коду вида оплат

    FUNCTION GetPymntHashByPayType( cPayType )
* -------------------------------------------------------- *
    LOCAL oHash := HashIVar():new()
    LOCAL lFound
    LOCAL nRecNo

    IF !( PYMNT->CODE == cPayType )
// Если указатель не стоит на искомой позиции пимента - ищем DBSEEKом
        nRecNo := PYMNT->(RECNO())
        PYMNT->(DB_SETORDER("CODE"))
        lFound := PYMNT->( DBSEEK( cPayType ) )
    ELSE
        lFound := .T.
    ENDIF
// Подразумеваем, что скопка уже стоит на пимент, поэтому ищем
    IF lFound
        ReadRecordToHash( "PYMNT", oHash )
    ENDIF

    RETURN oHash
* -------------------------------------------------------- *
*   Функция возвращает хэш пимента по коду вида оплат

    FUNCTION GetPymntAccObject( cPayType, cPost )
* -------------------------------------------------------- *
    LOCAL lFound
    LOCAL nRecNo
    LOCAL oCalcsAcc := CalcsAccs():new()
    LOCAL cErrorMsg

    IF !( PYMNT->CODE == cPayType )
// Если указатель не стоит на искомой позиции пимента - ищем DBSEEKом
        nRecNo := PYMNT->(RECNO())
        PYMNT->(DB_SETORDER("CODE"))
        lFound := PYMNT->( DBSEEK( cPayType ) )
    ELSE
        lFound := .T.
    ENDIF
// Подразумеваем, что скопка уже стоит на пимент, поэтому ищем
    IF lFound
        IF ! oCalcsAcc:LoadFromPymnt( cPayType,,cPost,, @cErrorMsg )
            Message( "S" + cErrorMsg )
        ENDIF
    ENDIF

    RETURN oCalcsAcc

* -------------------------------------------------------- *
*   Функция возвращает хэш пимента по коду вида оплат

    FUNCTION CalcsObjectToTable( oCalcsAcc )
* -------------------------------------------------------- *
    oCalcsAcc:FillAnalit( oCalcsAcc:dacc, oCalcsAcc:ohAnalit )
    oCalcsAcc:FillAnalit( oCalcsAcc:kacc, oCalcsAcc:ohAnalit )

    FIELD->DFKR     := oCalcsAcc:dacc:fkr
    FIELD->DBACC    := oCalcsAcc:dacc:acc
    FIELD->DBKGU    := oCalcsAcc:dacc:kgu
    FIELD->DBACCKF1 := oCalcsAcc:dacc:acckf1
    FIELD->DBACCKF2 := oCalcsAcc:dacc:acckf2
    FIELD->DBACCKF3 := oCalcsAcc:dacc:acckf3

    FIELD->KACC    := oCalcsAcc:kacc:acc
    FIELD->KKGU    := oCalcsAcc:kacc:kgu
    FIELD->KACCKF1 := oCalcsAcc:kacc:acckf1
    FIELD->KACCKF2 := oCalcsAcc:kacc:acckf2
    FIELD->KACCKF3 := oCalcsAcc:kacc:acckf3

    RETURN NIL
* ------------------------------------------------------------------ *
    // Корреспонденция счетов в з/плате
    // + некоторые методы работы с оными
    CLASS CalcsAccs
* ------------------------------------------------------------------ *
    EXPORTED:
        VAR dacc // дебетовый объект счета
        VAR kacc // кредитовый объект счета
        VAR wacc // сцылка на зарплатный объект счета
        VAR ohAnalit INIT Hash():new()// Хэш-набор аналитики
        VAR lIsPlus // проводка начисления з/платы
        VAR cSeekAnalitValue // строка-набор значений и ключей аналитики
                             // используется исключительно для проверки
                             // уникальности аналитики и разбору не подлежит
        VAR cFullSeekValue // Строка для анализа уникальности, состоит из
                           // з/платного счета + cSeekAnalitValue

        VAR cPlusFullSeekValue // Строка для анализа уникальности, состоит из
                               // всей корреспонденции счетов + cSeekAnalitValue

        VAR lMinus

        METHOD Init
        METHOD LoadFromCalcs
        METHOD LoadFromObject
        METHOD LoadFromPymnt
        METHOD PrepareWithKGU
        METHOD LoadFromPymntAnalit
        METHOD Join
        METHOD FillSeekAnalitValue
        METHOD FillAnalit
        METHOD CheckKGU
        METHOD RefreshSeekValues
        METHOD FillAnalitHash

    PROTECTED:
        METHOD LocatePymnt

    ENDCLASS

* ------------------------------------------------------------------ *
    METHOD CalcsAccs:Init()
* ------------------------------------------------------------------ *
    ::dacc := CalcsAcc():new()
    ::kacc := CalcsAcc():new()
    ::lIsPlus := .T.
    ::lMinus  := .T.

    SaveSet()

    ReferInit( { "ACCNT", "ACKGU" } )

    RestSet()

    ::cSeekAnalitValue := ""

    RETURN self

* ------------------------------------------------------------------ *
    METHOD CalcsAccs:LoadFromCalcs( cAlias, ;
                                  cPayType ) // Кто-то прикололся с названием PAYTYPE в HDYST...
* ------------------------------------------------------------------ *
    LOCAL nRecNo
    LOCAL cFkr
    LOCAL lResult := .F.

    DEFAULT cAlias   IS "CALCS"
    DEFAULT cPayType IS (cAlias)->PAYTYPE

    cFkr := (cAlias)->DFKR
    IF ::LocatePymnt( cPayType, @nRecNo )
        IF ::lMinus .AND. PYMNT->PRIMARYKBK = 1
            IF EMPTY( cFkr := EXTRACT( "", "VAL", MEMVAR->SprPath + "such.dbf", "FKR", { "ENTCODE", MEMVAR->ENT } ) )
                cFKR := (cAlias)->DFKR
            ENDIF
        ENDIF
    ENDIF

    ::dacc := CalcsAcc():new()
    ::dacc:fkr     := cFKR
    ::dacc:acc     := (cAlias)->DBACC
    ::dacc:kgu     := (cAlias)->DBKGU
    ::dacc:acckf1  := (cAlias)->DBACCKF1
    ::dacc:acckf2  := (cAlias)->DBACCKF2
    ::dacc:acckf3  := (cAlias)->DBACCKF3

    ::kacc := CalcsAcc():new()
    ::kacc:fkr     := cFKR
    ::kacc:acc     := (cAlias)->KACC
    ::kacc:kgu     := (cAlias)->KKGU
    ::kacc:acckf1  := (cAlias)->KACCKF1
    ::kacc:acckf2  := (cAlias)->KACCKF2
    ::kacc:acckf3  := (cAlias)->KACCKF3

    IF ::lIsPlus // устанавливаем
        ::wacc := ::kacc
    ELSE
        ::wacc := ::dacc
    ENDIF


    IF ::LocatePymnt( cPayType, @nRecNo )
        ::FillAnalitHash()      // Заполняем хэш-набор аналитики
        ::RefreshSeekValues()
        ::CheckKGU()

        lResult := .T.
    ELSE
        Message( 'SВид оплаты с кодом "' + cPayType + '" не найден в справочнике видов оплат! Исправьте ситуацию и попробуйте вновь' )
    ENDIF

    IF nRecNo != NIL
        PYMNT->( DBGOTO( nRecNo ) )
    ENDIF

    RETURN lResult

* ------------------------------------------------------------------ *
    METHOD CalcsAccs:LoadFromObject( oObj )
* ------------------------------------------------------------------ *
    LOCAL cPayType := oObj:paytype
    LOCAL nRecNo

    ::dacc := CalcsAcc():new()
    ::dacc:fkr     := oObj:DFKR
    ::dacc:acc     := oObj:DBACC
    ::dacc:kgu     := oObj:DBKGU
    ::dacc:acckf1  := oObj:DBACCKF1
    ::dacc:acckf2  := oObj:DBACCKF2
    ::dacc:acckf3  := oObj:DBACCKF3

    ::kacc := CalcsAcc():new()
    ::kacc:fkr     := oObj:DFKR
    ::kacc:acc     := oObj:KACC
    ::kacc:kgu     := oObj:KKGU
    ::kacc:acckf1  := oObj:KACCKF1
    ::kacc:acckf2  := oObj:KACCKF2
    ::kacc:acckf3  := oObj:KACCKF3

    IF ::lIsPlus // устанавливаем
        ::wacc := ::kacc
    ELSE
        ::wacc := ::dacc
    ENDIF

    IF ::LocatePymnt( cPayType, @nRecNo )
        ::FillAnalitHash()      // Заполняем хэш-набор аналитики
        ::RefreshSeekValues()

    ENDIF

    IF nRecNo != NIL
        PYMNT->( DBGOTO( nRecNo ) )
    ENDIF

    RETURN self

* ------------------------------------------------------------------ *
* Загрузка корреспонденции из ПИМАНТА с одновременной проверкой КБК
    METHOD CalcsAccs:LoadFromPymnt( cPayType, cEnt, cPost, nType, cErrorMessage, oAcc )
* ------------------------------------------------------------------ *
    LOCAL nRecNo
    LOCAL xTemp
    LOCAL lResult := .T.

    DEFAULT cErrorMessage IS ""

    IF oAcc == NIL
        xTemp := GetPrimaryFkr( @cPayType, @cEnt, cPost, nType )
        IF EMPTY( xTemp[ 1 ] ) .OR. LEN( ALLTRIM( xTemp[ 1 ] ) ) < 4
            cErrorMessage += '"' + ALLTRIM( SayRefer( "PYMNT", cPayType ) ) + ;
                             '", учреждение "' + ALLTRIM( SayRefer( "ENTF", cEnt ) ) + ;
                             '". Отсутствует или не удалось определить КБК для данного вида оплаты. '
            lResult := .F.
        ENDIF
        IF EMPTY( xTemp[ 2 ] )
            cErrorMessage += '"' + ALLTRIM( SayRefer( "PYMNT", cPayType ) ) + ;
                             '", учреждение "' + ALLTRIM( SayRefer( "ENTF", cEnt ) ) + ;
                             '". Отсутствует или не удалось определить вид деятельности для данного вида оплаты. '
            lResult := .F.
        ENDIF
    ELSE
        xTemp := { oAcc:fkr, LEFT( oAcc:acc, 1 ) }
    ENDIF


    IF ! lResult
        RETURN lResult
    ENDIF

    ::dacc := CalcsAcc():new()
    ::kacc := CalcsAcc():new()
    // Подразумеваем, что скопка уже стоит на пимент, поэтому ищем
    IF ::LocatePymnt( cPayType, @nRecNo )
        IF ! EMPTY( SUBSTR( PYMNT->DACC, 2 ) )
            ::dacc:fkr     := xTemp[1]
            ::dacc:acc     := xTemp[2] + SUBSTR( PYMNT->DACC, 2 )
            ::dacc:kgu     := PYMNT->DKGU
            ::dacc:acckf1  := PYMNT->DACCKF1
            ::dacc:acckf2  := PYMNT->DACCKF2
            ::dacc:acckf3  := PYMNT->DACCKF3
        ENDIF

        IF ! EMPTY( SUBSTR( PYMNT->KACC, 2 ) )
            ::kacc:fkr     := xTemp[1]
            ::kacc:acc     := xTemp[2] + SUBSTR( PYMNT->KACC, 2 )
            ::kacc:kgu     := PYMNT->KKGU
            ::kacc:acckf1  := PYMNT->KACCKF1
            ::kacc:acckf2  := PYMNT->KACCKF2
            ::kacc:acckf3  := PYMNT->KACCKF3
        ENDIF

        ::lIsPlus := ( PYMNT->GROUP < 35 )
    ENDIF

    IF ::lIsPlus // устанавливаем
        ::wacc := ::kacc
    ELSE
        ::wacc := ::dacc
    ENDIF

    ::FillAnalitHash()      // Заполняем хэш-набор аналитики
    ::FillAnalit( ::kacc, ::ohAnalit )
    ::FillAnalit( ::dacc, ::ohAnalit )
    ::RefreshSeekValues()

    ::CheckKGU()

    IF nRecNo != NIL
        PYMNT->( DBGOTO( nRecNo ) )
    ENDIF

    RETURN .T.

* ------------------------------------------------------------------ *
    METHOD CalcsAccs:PrepareWithKGU( cKGU, cPayType, cErrorMessage )
* ------------------------------------------------------------------ *
    LOCAL nI
    LOCAL cAccAnal
    LOCAL nRecNo
    LOCAL lResult := .T.

    DEFAULT cErrorMessage IS ""

    IF ! EMPTY( cKGU )
        IF ::LocatePymnt( cPayType, @nRecNo )
            IF EMPTY( PYMNT->FKGU ) .OR. PYMNT->FKGU == PADR( cKGU, 6 )
                IF SUBSTR( ::wacc:acc, 2, 3 ) == "302" // счет з/платы
                    IF ! EMPTY( nI := ASCAN( COMP_TABL, {|x| x[2] == ALLTRIM( cKGU ) } ) )
                        cAccAnal := COMP_TABL[nI][1]
                        ::wacc:acc := PADR( LEFT( ::wacc:acc, 4 ) + cAccAnal, 10 )
                        ::ohAnalit:put( "$KOSGU_FIN_RES", PADR( cKGU, 6 ) )
                        ::ohAnalit:put( "$STATS", PADR( cKGU, 6 ) )
                        ::FillAnalit( ::kacc )
                        ::FillAnalit( ::dacc )
                        ::CheckKGU()
                        ::RefreshSeekValues()
                    ENDIF
                ENDIF
            ELSE
                cErrorMessage += "Попытка заменить КоСГУ и счет зарплаты, а в справочнике видов оплат и удержаний указан КоСГУ финансового результата! Замена счета зарплаты и КоСГУ финансового результата произведена не будет!"
                lResult := .F.
            ENDIF
        ENDIF

        IF nRecNo != NIL
            PYMNT->( DBGOTO( nRecNo ) )
        ENDIF
    ENDIF

    RETURN lResult

* ------------------------------------------------------------------ *
    METHOD CalcsAccs:LoadFromPymntAnalit( cPayType )
* ------------------------------------------------------------------ *
    LOCAL nRecNo
    LOCAL xTemp

    ::dacc := CalcsAcc():new()
    ::kacc := CalcsAcc():new()
    xTemp := { SPACE(4), SPACE(1) }
// Подразумеваем, что скопка уже стоит на пимент, поэтому ищем
    IF ::LocatePymnt( cPayType, @nRecNo )
        IF ! EMPTY( SUBSTR( PYMNT->DACC, 2 ) )
            ::dacc:fkr     := xTemp[1]
            ::dacc:acc     := xTemp[2] + SUBSTR( PYMNT->DACC, 2 )
            ::dacc:kgu     := PYMNT->DKGU
            ::dacc:acckf1  := PYMNT->DACCKF1
            ::dacc:acckf2  := PYMNT->DACCKF2
            ::dacc:acckf3  := PYMNT->DACCKF3
        ENDIF

        IF ! EMPTY( SUBSTR( PYMNT->KACC, 2 ) )
            ::kacc:fkr     := xTemp[1]
            ::kacc:acc     := xTemp[2] + SUBSTR( PYMNT->KACC, 2 )
            ::kacc:kgu     := PYMNT->KKGU
            ::kacc:acckf1  := PYMNT->KACCKF1
            ::kacc:acckf2  := PYMNT->KACCKF2
            ::kacc:acckf3  := PYMNT->KACCKF3
        ENDIF

        ::lIsPlus := ( PYMNT->GROUP < 40 )
    ENDIF

    IF ::lIsPlus // устанавливаем
        ::wacc := ::kacc
    ELSE
        ::wacc := ::dacc
    ENDIF

    ::FillAnalitHash()      // Заполняем хэш-набор аналитики
    ::RefreshSeekValues()

    IF nRecNo != NIL
        PYMNT->( DBGOTO( nRecNo ) )
    ENDIF

    RETURN self

* ------------------------------------------------------------------ *
    METHOD CalcsAccs:FillAnalitHash()
* ------------------------------------------------------------------ *
    LOCAL oLocalHash
    LOCAL cStats
    LOCAL nI

    ::ohAnalit := Hash():new()
    IF ::lIsPlus   // Определяем набор аналитики, причем приоритетной
                   // является счет з/платы (в случае совпадения одной
                   // и той же аналитики для дебета и кредита)
        oLocalHash := ::dacc:GetAnalitHash()
        ::ohAnalit:ArrPut( oLocalHash:ArrGet() )
        oLocalHash := ::kacc:GetAnalitHash()
        ::ohAnalit:ArrPut( oLocalHash:ArrGet() )
    ELSE
        oLocalHash := ::kacc:GetAnalitHash()
        ::ohAnalit:ArrPut( oLocalHash:ArrGet() )
        oLocalHash := ::dacc:GetAnalitHash()
        ::ohAnalit:ArrPut( oLocalHash:ArrGet() )
    ENDIF

    IF EMPTY( ::ohAnalit:get( "$KOSGU_FIN_RES" ) ) .AND. ! EMPTY( ::ohAnalit:get( "$STATS" ) )
        ::ohAnalit:put( "$KOSGU_FIN_RES", ::ohAnalit:get( "$STATS" ) )
    ENDIF

    IF ::ohAnalit:get( "$STATS" ) == NIL
        ::ohAnalit:put( "$STATS", SPACE( 6 ) )
    ENDIF




// суем $STATS всегда, независимо, нужен он или нет
    IF EMPTY( ::ohAnalit:get( "$KOSGU_FIN_RES" ) )
        IF ::wacc != NIL // з/платный счет присутствует
            IF ! EMPTY( nI := ASCAN( COMP_TABL, {|x| x[1] == SUBSTR( ::wacc:acc, 5, 2 ) } ) )
                ::ohAnalit:put( "$KOSGU_FIN_RES", PADR( COMP_TABL[nI][2], 6 ) )
            ENDIF
        ENDIF
    ENDIF

    IF ::ohAnalit:get( "$KOSGU_FIN_RES" ) == NIL
        ::ohAnalit:put( "$KOSGU_FIN_RES", SPACE( 6 ) )
    ENDIF

    RETURN self

* ------------------------------------------------------------------ *
*   Метод возвращает строку хэш-объекта аналитики из корреспонденции
    METHOD CalcsAccs:FillSeekAnalitValue()
* ------------------------------------------------------------------ *
    LOCAL cReturn := ""
    LOCAL aArray
    LOCAL nIndex

    aArray := ::ohAnalit:ArrGet()

    FOR nIndex := 1 TO LEN( aArray )
        cReturn += aArray[nIndex][1] + aArray[nIndex][2]
    NEXT

    ::cSeekAnalitValue := cReturn

    RETURN self

* ------------------------------------------------------------------ *
*   Метод "заливает" хэш-объект аналитики и з/платный счет
    METHOD CalcsAccs:Join( oAcc, ohAnalit, lDefaultIsSpace )
* ------------------------------------------------------------------ *
    DEFAULT ohAnalit IS oAcc:GetAnalitHash()

    IF ::lIsPlus
        ::kacc:fkr := oAcc:fkr
        ::kacc:acc := oAcc:acc
        ::kacc:kgu := oAcc:kgu

        ::dacc:fkr := oAcc:fkr
        ::dacc:acc := LEFT( oAcc:acc, 1 ) + SUBSTR( ::dacc:acc, 2 )
    ELSE
        ::dacc:fkr := oAcc:fkr
        ::dacc:acc := oAcc:acc
        ::dacc:kgu := oAcc:kgu

        ::kacc:fkr := oAcc:fkr
        ::kacc:acc := LEFT( oAcc:acc, 1 ) + SUBSTR( ::kacc:acc, 2 )
    ENDIF

    ::FillAnalit( ::dacc, ohAnalit, lDefaultIsSpace )
    ::FillAnalit( ::kacc, ohAnalit, lDefaultIsSpace )

    ::FillAnalitHash()

    ::CheckKGU()

    RETURN self

* ------------------------------------------------------------------ *
*   Метод проверки корректности заполнения КоСГУ дебета и кредита
    METHOD CalcsAccs:CheckKGU()
* ------------------------------------------------------------------ *
    ::dacc:CheckKGU( ::ohAnalit, .T. )
    ::kacc:CheckKGU( ::ohAnalit, .F. )

    RETURN self
* ------------------------------------------------------------------ *
*   Метод "заливает" хэш-объект аналитики и з/платный счет
    METHOD CalcsAccs:FillAnalit( oAcc, ohAnalit, lDefaultIsSpace )
* ------------------------------------------------------------------ *
    DEFAULT ohAnalit IS ::ohAnalit

    oAcc:FillAnalit( ohAnalit, lDefaultIsSpace )

    RETURN self

* ------------------------------------------------------------------ *
*   Установка пимента на вид оплаты
    METHOD CalcsAccs:LocatePymnt( cPayType, nRecNo )
* ------------------------------------------------------------------ *
    LOCAL lFound

    IF !( PYMNT->CODE == cPayType )
// Если указатель не стоит на искомой позиции пимента - ищем DBSEEKом
        nRecNo := PYMNT->(RECNO())
        PYMNT->(DB_SETORDER("CODE"))
        lFound := PYMNT->( DBSEEK( cPayType ) )
    ELSE
        lFound := .T.
    ENDIF

    RETURN lFound

* ------------------------------------------------------------------ *
*   Обновление строк поиска
    METHOD CalcsAccs:RefreshSeekValues()
* ------------------------------------------------------------------ *

    ::FillSeekAnalitValue() // Заполняем строку для отбора аналитики

    ::cFullSeekValue := ::wacc:GetSeekValue() + ::cSeekAnalitValue
    // Строка для начислений (участвуют и дебет и кредит)
    ::cPlusFullSeekValue := ::dacc:GetSeekValue() + ::kacc:GetSeekValue() + ::cSeekAnalitValue

    RETURN self

* ------------------------------------------------------------------ *
*   По указанному виду оплат аналитика приводится к аналитике,
*   указанной в корреспонденции счетов данного вида оплаты
    PROCEDURE PrepareAnalitWithPayType( oCalcAcc, cPayType )
* ------------------------------------------------------------------ *
    LOCAL oPayTypeCalcAcc := CalcsAccs():new()
    LOCAL ohAnalitPymnt
    LOCAL ohAnalit
    LOCAL nIndex
    LOCAL aKeys := {}

    // Загрузка аналитики и корреспонденции счетов без вида деятельности и КБК
    oPayTypeCalcAcc:LoadFromPymntAnalit( cPayType )
    ohAnalitPymnt := oPayTypeCalcAcc:ohAnalit

    ohAnalit := oCalcAcc:ohAnalit

    // Заливаем аналитику из пимента, если она отсутствует в корреспонденции
    FOR nIndex := 1 TO ohAnalitPymnt:len()
        IF ohAnalit:get( ohAnalitPymnt:indexKeyGet( nIndex ) ) == NIL
            ohAnalit:put( ohAnalitPymnt:indexKeyGet( nIndex ), ohAnalitPymnt:indexGet( nIndex ) )
        ENDIF
    NEXT

    // Удаляем аналитику из корреспонденции, если она отсутствует в пименте
    FOR nIndex := 1 TO ohAnalit:len()
        IF ohAnalitPymnt:get( ohAnalit:indexKeyGet( nIndex ) ) == NIL
            AADD( aKeys, ohAnalit:indexKeyGet( nIndex ) )
        ENDIF
    NEXT

    FOR nIndex := 1 TO LEN( aKeys )
        ohAnalit:del( aKeys[ nIndex ] )
    NEXT

    oCalcAcc:RefreshSeekValues()

    RETURN
* ------------------------------------------------------------------ *
*   Слияние хэш-аналитик по принципу: в двух хэшах нету - нафиг не нужна
    PROCEDURE PrepareAnalit( ohAnalit, ; // Результирующий хэш
                             ohAnalitIn ) // Корреспондирующий хэш
* ------------------------------------------------------------------ *
    LOCAL aKeys := {}
    LOCAL nIndex

    // Удаляем аналитику из корреспонденции, если она отсутствует в пименте
    FOR nIndex := 1 TO ohAnalit:len()
        IF ohAnalitIn:get( ohAnalit:indexKeyGet( nIndex ) ) == NIL
            AADD( aKeys, ohAnalit:indexKeyGet( nIndex ) )
        ENDIF
    NEXT

    FOR nIndex := 1 TO LEN( aKeys )
        ohAnalit:del( aKeys[ nIndex ] )
    NEXT

    RETURN
* ------------------------------------------------------------------ *
*   Отбрасывание ненужной аналитики из хэша
    PROCEDURE RestrictAnalitHash( ohAnalit, ; // хэш с аналитикой
                                  oWacc ) // Счет
* ------------------------------------------------------------------ *
    LOCAL oNewHash := Hash():new()
    LOCAL nIndex
    LOCAL aAnalit := Extract( {}, "VAL", MEMVAR->SprPath + "accnt.dbf", { "ALLTRIM( KEYF1 )", "ALLTRIM( KEYF2 )", "ALLTRIM( KEYF3 )", "GROUP" }, { "ACCNT", oWacc:GetMainAcc(), oWacc:GetMainAcc() } )

    FOR nIndex := 1 TO ohAnalit:len()
        IF ( ASCAN( aAnalit, ohAnalit:indexKeyGet( nIndex ) ) > 0 ) .OR. ohAnalit:indexKeyGet( nIndex ) == "$KOSGU_FIN_RES"
            oNewHash:put( ohAnalit:indexKeyGet( nIndex ), ohAnalit:indexGet( nIndex ) )
        ENDIF
    NEXT

    ohAnalit:Clear()
    ohAnalit:ArrPut( oNewHash:ArrGet() )
    oNewHash:Clear()

    RETURN
* ------------------------------------------------------------------ *
*   Отбрасывание ненужной аналитики из хэша
    FUNCTION RejectAnalitHash( ohPymntAnalit, ; // хэш с аналитикой пимента
                                ohAnalit ) // хэш с аналитикой счета
* ------------------------------------------------------------------ *
    LOCAL oResultHash := Hash():new()
    LOCAL nIndex

    FOR nIndex := 1 TO ohPymntAnalit:len()
        IF ! ohAnalit:isKey( ohPymntAnalit:indexKeyGet( nIndex ) )
            oResultHash:put( ohPymntAnalit:indexKeyGet( nIndex ),  ohPymntAnalit:indexGet( nIndex ) )
        ENDIF
    NEXT

    FOR nIndex := 1 TO ohAnalit:len()
        IF ! ohPymntAnalit:isKey( ohAnalit:indexKeyGet( nIndex ) )
            oResultHash:put( ohAnalit:indexKeyGet( nIndex ),  ohAnalit:indexGet( nIndex ) )
        ENDIF
    NEXT

    RETURN oResultHash

* ------------------------------------------------------------------ *
*   Слияние 2-х хэш-аналитик
    FUNCTION JoinAnalitHash( ohAnalit, ; // Хэш с аналитикой
                            ohAnalitIn, cPaytype ) // Хэш с аналитикой пимента
* ------------------------------------------------------------------ *
    LOCAL oResultHash := Hash():new()
    LOCAL nIndex

    PRIVATE ohRulesHash

    IF cPayType == NIL
        ALERT( "SНеправильный вызов JoinAnalitHash!!!!" )
        RETURN oResultHash
    ENDIF

    ohRulesHash := Hash():new()

    SaveSet()

    IF ! ReferInit( { "PMTRL" } )
        RestSet()
        RETURN oResultHash
    ENDIF

    RestSet()

    Extract( {}, "ARR", "PMTRL", "ohRulesHash:put( ALLTRIM( FIELD->ANALIT ), FIELD->RULE )", { "CODE", cPayType, cPayType } )

    oResultHash:ArrPut( ohAnalitIn:ArrGet() )

    FOR nIndex := 1 TO ohAnalit:len()
        IF EMPTY( ohRulesHash:get( ohAnalit:indexKeyGet( nIndex ) ) ) .OR. oResultHash:get( ohAnalit:indexKeyGet( nIndex ) ) == NIL
            // Правило вообще отсутствует или 0 (умолчание)
            oResultHash:put( ohAnalit:indexKeyGet( nIndex ), ohAnalit:indexGet( nIndex ) )
        ENDIF
    NEXT

    IF oResultHash:get( "$STATS" ) != NIL
        IF EMPTY( ohRulesHash:get( "$STATS" ) )
            // Обработка по умолчанию - STATS = КоСГУ фин. рез-та
            oResultHash:put( "$STATS", oResultHash:get( "$KOSGU_FIN_RES" ) )

        ELSEIF ohRulesHash:get( "$STATS" ) = 1
            // берем из проводок всегда
            oResultHash:put( "$STATS", ohAnalit:get( "$STATS", SPACE( 6 ) ) )

        ELSEIF ohRulesHash:get( "$STATS" ) = 2
            // берем из пимента всегда
            oResultHash:put( "$STATS", ohAnalitIn:get( "$STATS", SPACE( 6 ) ) )

        ENDIF
    ENDIF

    RETURN oResultHash
* ------------------------------------------------------------------ *
    // Класс-набор для з/платы КБК + счет + КоСГУ + Аналитика 1 + Аналитика 2 + Аналитика 3
    // + некоторые методы работы с оными
    CLASS CalcsAcc
* ------------------------------------------------------------------ *
    EXPORTED:
        VAR fkr
        VAR acc
        VAR mainacc
        VAR kgu
        VAR acckf1
        VAR acckf2
        VAR acckf3

        METHOD Init
        METHOD LoadDebetAcc
        METHOD LoadKreditAcc
        METHOD GetSeekValue
        METHOD GetFullSeekValue
        METHOD GetAnalitHash
        METHOD GetMainAcc
        METHOD IsEqual
        METHOD CheckKGU
        METHOD FillAnalit

    ENDCLASS

* ------------------------------------------------------------------ *
    METHOD CalcsAcc:Init()
* ------------------------------------------------------------------ *

    ::fkr := ""
    ::acc := ""
//    ::mainacc := NIL
    ::kgu := ""
    ::acckf1 := ""
    ::acckf2 := ""
    ::acckf3 := ""

    RETURN self
* ------------------------------------------------------------------ *
    METHOD CalcsAcc:LoadDebetAcc( xValue )
* ------------------------------------------------------------------ *
    DEFAULT xValue IS "CALCS"

    IF VALTYPE( xValue ) == "O"
        ::fkr := xValue:dbfkr
        ::acc := xValue:dbacc
        ::kgu := xValue:dbkgu
        ::acckf1 := xValue:dbacckf1
        ::acckf2 := xValue:dbacckf2
        ::acckf3 := xValue:dbacckf3
    ELSE
        IF (xValue)->( FIELDPOS( "DBKGU" ) ) > 0
            ::fkr := (xValue)->DBFKR
            ::acc := (xValue)->DBACC
            ::kgu := (xValue)->DBKGU
            ::acckf1 := (xValue)->DBACCKF1
            ::acckf2 := (xValue)->DBACCKF2
            ::acckf3 := (xValue)->DBACCKF3
        ELSE
            ::fkr := (xValue)->DFKR
            ::acc := (xValue)->DACC
            ::kgu := (xValue)->DKGU
            ::acckf1 := (xValue)->DACCKF1
            ::acckf2 := (xValue)->DACCKF2
            ::acckf3 := (xValue)->DACCKF3
        ENDIF
    ENDIF

    RETURN self
* ------------------------------------------------------------------ *
    METHOD CalcsAcc:LoadKreditAcc( xValue )
* ------------------------------------------------------------------ *
    DEFAULT xValue IS "CALCS"

    IF VALTYPE( xValue ) == "O"
        ::fkr := xValue:kfkr
        ::acc := xValue:kacc
        ::kgu := xValue:kkgu
        ::acckf1 := xValue:kacckf1
        ::acckf2 := xValue:kacckf2
        ::acckf3 := xValue:kacckf3
    ELSE
        ::fkr := (xValue)->KFKR
        ::acc := (xValue)->KACC
        ::kgu := (xValue)->KKGU
        ::acckf1 := (xValue)->KACCKF1
        ::acckf2 := (xValue)->KACCKF2
        ::acckf3 := (xValue)->KACCKF3
    ENDIF

    RETURN self
* ------------------------------------------------------------------ *
    METHOD CalcsAcc:GetSeekValue()
* ------------------------------------------------------------------ *

    RETURN ::fkr + ::acc + SPACE( 6 )//::kgu// + ::acckf1 + ::acckf2 + ::acckf3
* ------------------------------------------------------------------ *
    METHOD CalcsAcc:GetFullSeekValue()
* ------------------------------------------------------------------ *

    RETURN ::fkr + ::acc + SPACE( 6 ) + ::acckf1 + ::acckf2 + ::acckf3
* ------------------------------------------------------------------ *

* ------------------------------------------------------------------ *
    METHOD CalcsAcc:GetAnalitHash()
* ------------------------------------------------------------------ *
    LOCAL oHash := Hash():new()
    LOCAL aAnalit
    LOCAL cAcc := ::GetMainAcc()

    aAnalit := Extract( {}, "VAL", MEMVAR->SprPath + "accnt.dbf", { "ALLTRIM( KEYF1 )", "ALLTRIM( KEYF2 )", "ALLTRIM( KEYF3 )", "GROUP" }, { "ACCNT", cAcc, cAcc } )

    IF ! EMPTY( aAnalit )
        IF ! EMPTY( aAnalit[1] )
            oHash:put( aAnalit[1], ::acckf1 )
        ENDIF
        IF ! EMPTY( aAnalit[2] )
            oHash:put( aAnalit[2], ::acckf2 )
        ENDIF
        IF ! EMPTY( aAnalit[3] )
            oHash:put( aAnalit[3], ::acckf3 )
        ENDIF
        IF aAnalit[4] == 11 .OR. LEFT( cAcc, 3 ) == "109" // Финансовый результат - добавляем KOSGU_FIN_RES из КСГУ
            oHash:put( "$KOSGU_FIN_RES", ::kgu )
        ENDIF

        // Если нет КСГУ фин.рез-а или счет не финреза - ставим из ПИМЕНТа, что указано в ксгу фин. реза
        IF oHash:get( "$KOSGU_FIN_RES" ) == NIL .AND. ! EMPTY( PYMNT->FKGU )
            oHash:put( "$KOSGU_FIN_RES", PYMNT->FKGU )
        ENDIF
        // Если и там нет - заполняем из STATS
        IF oHash:get( "$KOSGU_FIN_RES" ) == NIL .AND. ! EMPTY( oHash:get( "$STATS" ) )
            oHash:put( "$KOSGU_FIN_RES", oHash:get( "$STATS" ) )
        ENDIF

    ENDIF

    RETURN oHash

* ------------------------------------------------------------------ *
    METHOD CalcsAcc:GetMainAcc()
* ------------------------------------------------------------------ *
//    IF ::mainacc == NIL
//        ::mainacc := replaceaccag(substr(::acc,2,5))
//    ENDIF

//    RETURN ::mainacc
    RETURN replaceaccag(substr(::acc,2,5))

* ------------------------------------------------------------------ *
    METHOD CalcsAcc:IsEqual( oAcc, lFullAnalit )
* ------------------------------------------------------------------ *
    LOCAL cStats
    LOCAL cStats2

    DEFAULT lFullAnalit IS .T.

    IF lFullAnalit
        cStats  := ::GetAnalitHash():get( "$KOSGU_FIN_RES" )
        cStats2 := oAcc:GetAnalitHash():get( "$KOSGU_FIN_RES" )
        RETURN ::fkr == oAcc:fkr .AND. ::acc == oAcc:acc .AND. cStats == cStats2 .AND. ::acckf1 == oAcc:acckf1 .AND. ::acckf2 == oAcc:acckf2 .AND. ::acckf3 == oAcc:acckf3
    ELSE
        RETURN ::fkr == oAcc:fkr .AND. ::acc == oAcc:acc
    ENDIF

    RETURN self

* ------------------------------------------------------------------ *
    METHOD CalcsAcc:CheckKGU( ohAnalit, isDebet )
* ------------------------------------------------------------------ *
    LOCAL cAcc := ::GetMainAcc()
    LOCAL aGroup := Extract( { 0 }, "VAL", MEMVAR->SprPath + "accnt.dbf", { "GROUP" }, { "ACCNT", cAcc, cAcc } )

    IF ( aGroup[1] == 11 .OR. LEFT( cAcc, 3 ) == "109" ) .AND. ohAnalit != NIL
        ::kgu := ohAnalit:get( "$KOSGU_FIN_RES", SPACE( 6 ) )
    ELSE
//        ::kgu := aGroup[2]
        ::kgu := GetAccKgu( ::acc, MEMVAR->ENT, isDebet )
    ENDIF

    RETURN self
* ------------------------------------------------------------------ *
*   Метод "заливает" хэш-объект аналитики в счет
    METHOD CalcsAcc:FillAnalit( ohAnalit, lDefaultIsSpace )
* ------------------------------------------------------------------ *
    LOCAL cAcc := ::GetMainAcc()
    LOCAL aAcc := Extract( {}, "VAL", MEMVAR->SprPath + "accnt.dbf", { "ALLTRIM( KEYF1 )", "ALLTRIM( KEYF2 )", "ALLTRIM( KEYF3 )", "GROUP" }, { "ACCNT", cAcc, cAcc } )

    DEFAULT lDefaultIsSpace IS .T.

    IF ! EMPTY( aAcc )
        IF ! EMPTY( aAcc[ 1 ] )
            IF lDefaultIsSpace
                ::acckf1 := ohAnalit:get( aAcc[ 1 ], SPACE( 6 ) )
            ELSE
                ::acckf1 := ohAnalit:get( aAcc[ 1 ], ::acckf1 )
            ENDIF
        ELSE
            ::acckf1 := SPACE( 6 )
        ENDIF
        IF ! EMPTY( aAcc[ 2 ] )
            IF lDefaultIsSpace
                ::acckf2 := ohAnalit:get( aAcc[ 2 ], SPACE( 6 ) )
            ELSE
                ::acckf2 := ohAnalit:get( aAcc[ 2 ], ::acckf2 )
            ENDIF
        ELSE
            ::acckf2 := SPACE( 6 )
        ENDIF
        IF ! EMPTY( aAcc[ 3 ] )
            IF lDefaultIsSpace
                ::acckf3 := ohAnalit:get( aAcc[ 3 ], SPACE( 6 ) )
            ELSE
                ::acckf3 := ohAnalit:get( aAcc[ 3 ], ::acckf3 )
            ENDIF
        ELSE
            ::acckf3 := SPACE( 6 )
        ENDIF

        IF ( aAcc[ 4 ] == 11 .OR. LEFT( cAcc, 3 ) == "109" ) .AND. ! EMPTY( ohAnalit:get( "$KOSGU_FIN_RES" ) )
            // Если финансовый результат и есть СТАТС - суем его в КСГУ
            ::kgu := LEFT( ohAnalit:get( "$KOSGU_FIN_RES" ), 3 ) + SPACE( 3 )
        ENDIF
    ENDIF

    RETURN self
* ------------------------------------------------------------------ *

* -------------------------------------------------------------------------------------------------------- *
*   ФУНКЦИИ ПРОВЕРОК ВЫПЛАТЫ КОНКРЕТНЫХ ВИДОВ ОПЛАТ
* -------------------------------------------------------------------------------------------------------- *


* ------------------------------------------------------------------ *
*   Класс, инкпасулирующий параметры строки в ведомости
    CLASS SheetLineParams
    EXPORTED:
        VAR sheet_recno   // рекно записи ведомости
        VAR sheet_reccode // код ведомости
        VAR sheet_number  // номер ведомости
        VAR sheet_isfull  // признак окончательности ведомости

        VAR recno   // рекно записи позиции ведомости
        VAR reccode // код позиции ведомости

        METHOD Init
        METHOD LoadFromCurrent
        METHOD LoadFromObject
    ENDCLASS

* ------------------------------------------------------------------ *
*   Конструктор
    METHOD SheetLineParams:Init()
* ------------------------------------------------------------------ *
        ::sheet_recno := ""
        ::sheet_reccode := ""
        ::sheet_number  := ""
        ::sheet_isfull  := .F.

        ::recno   := 0
        ::reccode := ""
    RETURN self

* ------------------------------------------------------------------ *
*   Заполнить объект данными
    METHOD SheetLineParams:LoadFromCurrent( lLoadSheet )
* ------------------------------------------------------------------ *
    LOCAL oPaySheet
    DEFAULT lLoadSheet IS .F.

    IF SELECT( "SHLST" ) > 0 .AND. !SHLST->( EOF() ) .AND. !SHLST->( BOF() )
        ::recno   := SHLST->( RECNO() )
        ::reccode := SHLST->RECCODE

        ::sheet_reccode := SHLST->SHCODE
        IF lLoadSheet
            oPaySheet := PaySheet():new()
            IF oPaySheet:LoadByReccode( ::sheet_reccode )
                ::sheet_recno  := oPaySheet:nRecno
                ::sheet_number := oPaySheet:cNumber
                ::sheet_isfull := oPaySheet:lIsFinal
            ENDIF
        ENDIF

    ENDIF

    RETURN self

* ------------------------------------------------------------------ *
*   Заполнить объект данными. oObject - HashIvar
    METHOD SheetLineParams:LoadFromObject( oObject, lLoadSheet )
* ------------------------------------------------------------------ *
    LOCAL oPaySheet
    DEFAULT lLoadSheet IS .F.

    ::recno   := oObject:record_recno
    ::reccode := oObject:reccode

    ::sheet_reccode := oObject:shcode
    IF lLoadSheet
        oPaySheet := PaySheet():new()
        IF oPaySheet:LoadByReccode( ::sheet_reccode )
            ::sheet_recno  := oPaySheet:nRecno
            ::sheet_number := oPaySheet:cNumber
            ::sheet_isfull := oPaySheet:lIsFinal
        ENDIF
    ENDIF


    RETURN self

* ------------------------------------------------------------------ *
*   Класс для обслуживания запросов на принадлежность строк в CALCS к определенной ведомости
    CLASS CalcSheets
    HIDDEN:
        METHOD QueryToSheets        PERSISTENT
    EXPORTED:
        METHOD CalcWasPayed         PERSISTENT
        METHOD CalcSheetCode        PERSISTENT
        METHOD CalcShlstCode        PERSISTENT
        METHOD CalcSheetParams      PERSISTENT
        METHOD AllowCalcChange      PERSISTENT
        METHOD CalcAccParams        PERSISTENT
        METHOD GetSheet             PERSISTENT
        METHOD IsInFinalSheet       PERSISTENT   //начисление присутствует в окончательной ведомости
    ENDCLASS


* ------------------------------------------------------------------ *
*   Функция возвращает код окончательной ведомости в которую включена текущая запись из CALCS
*   Параметр aExcludedSheets указывает, какие ведомости не брать в расчет
*   lSuspendForPlus - реализовать предположение, в какой существующей окончательной ведомости
*   мог бы находится данный вид оплаты
    METHOD CalcSheets:QueryToSheets( oHashParams )
* ------------------------------------------------------------------ *
    LOCAL oSheetLineParams
    LOCAL aSheets
    LOCAL xTemp
    LOCAL nI
    LOCAL cSheetNumber
    LOCAL oSheetLines
    LOCAL cWagesAlias := "WAGES"
    LOCAL cCalcsAlias := "CALCS"
    LOCAL cShlstAlias := "SHLST"

    // параметры в форме переменных
    LOCAL aExcludedSheets
    LOCAL lSuspendForPlus
    LOCAL lLoadSheets
    LOCAL lFullAnalit

    IF( oHashParams != NIL)
        aExcludedSheets  := oHashParams:get( "ИсключенныеВедомости", {})
        lSuspendForPlus  := oHashParams:get( "ИгнорироватьНевключенностьНачислений", .F.)
        lLoadSheets := oHashParams:get( "ЗагружатьВедомости", .F. )
        lFullAnalit := oHashParams:get( "УчитыватьАналитику" )
        cWagesAlias := oHashParams:get( "WAGESALIAS", "WAGES" )
        cCalcsAlias := oHashParams:get( "CALCSALIAS", "CALCS" )
        cShlstAlias := oHashParams:get( "SHLSTALIAS", "SHLST" )
    ENDIF

    DEFAULT aExcludedSheets  IS {}
    DEFAULT lSuspendForPlus  IS .F.
    DEFAULT lLoadSheets IS .F.
    DEFAULT lFullAnalit IS .T.

    oSheetLineParams := NIL

    IF EMPTY( (cCalcsAlias)->SHLSTCODE )
        IF (cCalcsAlias)->MODE >= 40 .OR. lSuspendForPlus

            xTemp := ::CalcAccParams( lFullAnalit, oHashParams )

            aSheets := GetFinalSheetList( { MEMVAR->ENT, (cWagesAlias)->TYPE, (cWagesAlias)->MONTH }, xTemp:oAcc, oHashParams )

            IF VALTYPE( aSheets ) == "A"
                FOR nI := 1 TO LEN( aSheets )
                    IF EMPTY( ASCAN( aExcludedSheets, aSheets[ nI ]:reccode ) )
                        // делаем выборку из строк ведомости дабы узнать, если ли там наш сотрудник
                        oSheetLines := DBTable():new()
                        IF oSheetLines:load( cShlstAlias, { "KEY", aSheets[ nI ]:reccode + (cWagesAlias)->CODE + (cWagesAlias)->JOBSCODE, ;
                            aSheets[ nI ]:reccode + (cWagesAlias)->CODE + (cWagesAlias)->JOBSCODE } )
                            IF LEN( oSheetLines:rows ) > 0
                                oSheetLineParams := SheetLineParams():new()
                                oSheetLineParams:LoadFromObject( oSheetLines:rows[ 1 ], lLoadSheets )
                                EXIT
                            ENDIF
                        ENDIF
                    ENDIF
                NEXT
            ENDIF
        ENDIF
    ELSE
        oSheetLines := DBTable():new()
        IF oSheetLines:load( cShlstAlias, { "RECCODE", (cCalcsAlias)->SHLSTCODE, (cCalcsAlias)->SHLSTCODE } )
            IF LEN( oSheetLines:rows ) > 0
                oSheetLineParams := SheetLineParams():new()
                oSheetLineParams:LoadFromObject( oSheetLines:rows[ 1 ], .T. )
            ENDIF
        ENDIF
        // если это удержания и не авансы, то необходимо проверить,
        // а не в окончатульную ведомость ли включены записи
        IF (cCalcsAlias)->MODE >= 40 .AND. (cCalcsAlias)->GROUP != 50
            IF oSheetLineParams != NIL .AND. ! oSheetLineParams:sheet_isfull
                oSheetLineParams := NIL
            ENDIF
        ENDIF
    ENDIF

    RETURN oSheetLineParams

* ------------------------------------------------------------------ *
*   параметры ( dacc, refbu и fkr ведомости)
*
    METHOD CalcSheets:CalcAccParams( lFullAnalit, ohParams )
* ------------------------------------------------------------------ *
    LOCAL oParams
    LOCAL xTemp
    LOCAL cCalcsAlias := "CALCS"

    DEFAULT lFullAnalit IS .T.

    IF ohParams != NIL
        cCalcsAlias := ohParams:get( "CALCSALIAS", "CALCS" )
    ENDIF

    oParams := HashIvar():new()

    oParams:dacc  := ""
    oParams:fkr   := ""
    oParams:refbu := ""

    oParams:oAcc := CalcsAcc():new()
    IF (cCalcsAlias)->MODE > 39
        oParams:oAcc:fkr := (cCalcsAlias)->DFKR
        oParams:oAcc:acc := (cCalcsAlias)->DBACC
        oParams:oAcc:kgu := (cCalcsAlias)->DBKGU
        IF lFullAnalit
            oParams:oAcc:acckf1 := (cCalcsAlias)->DBACCKF1
            oParams:oAcc:acckf2 := (cCalcsAlias)->DBACCKF2
            oParams:oAcc:acckf3 := (cCalcsAlias)->DBACCKF3
        ELSE
            oParams:oAcc:acckf1 := SPACE( 6 )
            oParams:oAcc:acckf2 := SPACE( 6 )
            oParams:oAcc:acckf3 := SPACE( 6 )
        ENDIF
    ELSE
        oParams:oAcc:fkr := (cCalcsAlias)->DFKR
        oParams:oAcc:acc := (cCalcsAlias)->KACC
        oParams:oAcc:kgu := (cCalcsAlias)->KKGU
        IF lFullAnalit
            oParams:oAcc:acckf1 := (cCalcsAlias)->KACCKF1
            oParams:oAcc:acckf2 := (cCalcsAlias)->KACCKF2
            oParams:oAcc:acckf3 := (cCalcsAlias)->KACCKF3
        ELSE
            oParams:oAcc:acckf1 := SPACE( 6 )
            oParams:oAcc:acckf2 := SPACE( 6 )
            oParams:oAcc:acckf3 := SPACE( 6 )
        ENDIF
    ENDIF

    RETURN oParams

* ------------------------------------------------------------------ *
*   Получение ведомости, в кот. включена текущая оплата из CALCS
*
    METHOD CalcSheets:GetSheet( aExcludedSheets, lSayMessage )
* ------------------------------------------------------------------ *
    LOCAL oHash
    LOCAL oParams

    DEFAULT lSayMessage IS .F.

    oHash := Hash():new()
    oHash:put( "ИсключенныеВедомости", aExcludedSheets )
        oHash:put( "ЗагружатьВедомости", .T. )

    oParams := ::QueryToSheets( oHash )
    IF !EMPTY( oParams ) .AND. lSayMessage
        ALERT( "Запись включена в окончательную ведомость № " + oParams:sheet_number + ". Действия с данной записью запрещены." )
    ENDIF

    RETURN oParams

* ------------------------------------------------------------------ *
//  начисление присутствует в окончательной ведомости
//  lUseCurrentCalcRecord - если .T. - используем текущую запись в CALCS для получения параметров ведомости
//  oCalcParam - параметры ведомости (счет, КБК, вид. деят)
    METHOD CalcSheets:IsInFinalSheet( oHashParams, oCalcParam, lUseCurrentCalcRecord )
* ------------------------------------------------------------------ *
    LOCAL lFinalSheet := .F.
    LOCAL oSheetLineParams
    LOCAL xTemp, aSheets
    LOCAL oSheetLines
    LOCAL aExcludedSheets   := {}
    LOCAL lLoadSheets       := .T.
    LOCAL nI
    LOCAL cDACC  := ""
    LOCAL cFKR   := ""
    LOCAL cREFBU := ""
    LOCAL oCalcAcc

    DEFAULT lUseCurrentCalcRecord IS .T.

    IF( oHashParams != NIL)
        aExcludedSheets  := oHashParams:get( "ИсключенныеВедомости", {})
        lLoadSheets      := oHashParams:get( "ЗагружатьВедомости", .F.)
    ENDIF


    IF lUseCurrentCalcRecord
        //используем текущую запись в CALCS для получения параметров ведомости
        xTemp    := ::CalcAccParams( .F. )
        cDACC    := xTemp:dacc
        cFKR     := xTemp:fkr
        cREFBU   := xTemp:refbu
        oCalcAcc := xTemp:oAcc
    ELSE
        IF !EMPTY(oCalcParam)
            cDACC    := oCalcParam:get( "DACC",  "")
            cFKR     := oCalcParam:get( "FKR",   "")
            cREFBU   := oCalcParam:get( "REFBU", "")
            oCalcAcc := oCalcParam:get( "OACC", NIL )
        ENDIF
    ENDIF

    aSheets := GetFinalSheetList( { MEMVAR->ENT, WAGES->TYPE, WAGES->MONTH }, oCalcAcc/*cDACC, cFKR, cREFBU*/)

    IF VALTYPE( aSheets ) == "A"
        FOR nI := 1 TO LEN( aSheets )
            IF EMPTY( ASCAN( aExcludedSheets, aSheets[ nI ]:reccode ) )
                // делаем выборку из строк ведомости дабы узнать, если ли там наш сотрудник
                oSheetLines := DBTable():new()
                IF oSheetLines:load( "SHLST", { "KEY", aSheets[ nI ]:reccode + WAGES->CODE + WAGES->JOBSCODE, ;
                    aSheets[ nI ]:reccode + WAGES->CODE + WAGES->JOBSCODE } )
                    IF LEN( oSheetLines:rows ) > 0
                        oSheetLineParams := SheetLineParams():new()
                        oSheetLineParams:LoadFromObject( oSheetLines:rows[ 1 ], lLoadSheets )
                        EXIT
                    ENDIF
                ENDIF
            ENDIF
        NEXT
    ENDIF

    IF oSheetLineParams != NIL .AND. oSheetLineParams:sheet_isfull
        lFinalSheet := .T.
    ENDIF

    RETURN lFinalSheet

* ------------------------------------------------------------------ *
*   Включена ли текущая оплата из калкс в какую-либо ведомость
*
    METHOD CalcSheets:CalcWasPayed( aExcludedSheets, lSayMessage )
* ------------------------------------------------------------------ *
    LOCAL oHash
    LOCAL oParams

    DEFAULT lSayMessage IS .F.

    oHash := Hash():new()
    oHash:put( "ИсключенныеВедомости", aExcludedSheets )
    oHash:put( "УчитыватьАналитику", .F. )
    IF lSayMessage
        oHash:put( "ЗагружатьВедомости", .T. )
    ENDIF

    oParams := ::QueryToSheets( oHash )
    IF !EMPTY( oParams ) .AND. lSayMessage
        ALERT( "Запись включена в окончательную ведомость № " + oParams:sheet_number + ". Действия с данной записью запрещены." )
    ENDIF

    RETURN !EMPTY( oParams )

    METHOD CalcSheets:AllowCalcChange( lSayMessage, cMsg )
    LOCAL oHash
    LOCAL oParams
    LOCAL cStr

    DEFAULT lSayMessage IS .F.

    oHash := Hash():new()
    oHash:put( "ИгнорироватьНевключенностьНачислений", .T. )

    oHash:put( "УчитыватьАналитику", .F. )
    IF lSayMessage .OR. cMsg!=NIL
        oHash:put( "ЗагружатьВедомости", .T. )
    ENDIF

    oParams := ::QueryToSheets( oHash )
    IF !EMPTY( oParams )
        cStr := "В архиве ведомостей уже существует окончательная ведомость № " + oParams:sheet_number + ", в которую данная запись должна быть включена. Для выполнения Вашей операции необходимо либо удалить указанную ведомость, либо преобразовать ее в неокончательную."
        IF cMsg!=NIL
            cMsg := cStr
        ENDIF
        IF lSayMessage
            ALERT( cStr )
        ENDIF
    ENDIF

    RETURN EMPTY( oParams )

* ------------------------------------------------------------------ *
*   Возвращает код ведомости, в которую включен текущий вид оплаты
*
    METHOD CalcSheets:CalcSheetCode( )
* ------------------------------------------------------------------ *
    LOCAL oLine
    LOCAL oHash := Hash():new()

    oHash:put( "ЗагружатьВедомости", .T. )

    oLine := ::QueryToSheets( oHash )

    RETURN IF( EMPTY( oLine ), "", oLine:sheet_reccode )

* ------------------------------------------------------------------ *
*   Возвращает код позиции ведомости, в которую включен текущий вид оплаты
*
    METHOD CalcSheets:CalcShlstCode( oHash )
* ------------------------------------------------------------------ *
    LOCAL oLine

    oLine := ::QueryToSheets( oHash )

    RETURN IF( EMPTY( oLine ), "", oLine:reccode )



* ------------------------------------------------------------------ *
*   Возвращает параметры строки ведомости, в которую включен текущий вид оплаты
*
    METHOD CalcSheets:CalcSheetParams( )
* ------------------------------------------------------------------ *
    RETURN ::QueryToSheets()



* ------------------------------------------------------------------ *
*   Существуют виды оплат, не выплаченные ни по одной из ведомостей  *
    FUNCTION PersonUnpayedWages( aExcludedSheets )
* ------------------------------------------------------------------ *
    LOCAL aUnpayedWages := {}
    LOCAL nCalcsRecno
    LOCAL aCalcsScope
    LOCAL cAlias

    cAlias := ALIAS()

    SELECT CALCS
    nCalcsRecno := RECNO()
    aCalcsScope := SaveScope()

    DB_SETORDER( "CODE" )
    SET SCOPE TO ( DTOS( BOM( WAGES->MONTH ) ) + WAGES->CODE + WAGES->RECCODE )
    GO TOP

    DO WHILE ! EOF()
        IF !CalcSheets():CalcWasPayed( aExcludedSheets )
            AADD( aUnpayedWages, CalcSheets():CalcAccParams() )
        ENDIF
        SKIP
    ENDDO

    RestScope( aCalcsScope )
    DBGOTO( nCalcsRecno )

    DbSelectArea( cAlias )

    RETURN aUnpayedWages

* ------------------------------------------------------------------ *
* ------------------------------------------------------------------ *
* ------------------------------------------------------------------ *
*   КОНТЕЙНЕРНЫЕ КЛАССЫ ДЛЯ УЧЕТА ДОЛГА ЗА РАБОТНИКОМ / ПРЕДПРИЯТИЕМ
* ------------------------------------------------------------------ *
* ------------------------------------------------------------------ *
* ------------------------------------------------------------------ *

    CLASS GrouppedValues
    EXPORTED:
        VAR lines

        METHOD Init
        METHOD Put
        METHOD IsEmpty

        METHOD Join

    ENDCLASS

* ------------------------------------------------------------------ *
*   Типа, конструктор
    METHOD GrouppedValues:Init()
* ------------------------------------------------------------------ *
    ::lines := {}
    RETURN self

* ------------------------------------------------------------------ *
*   Добавить запись о долге
*   cKey - ключевое выражение, которое используется в качестве идентификатора
    METHOD GrouppedValues:Put( cKey, nValue, aOptionalArray)
* ------------------------------------------------------------------ *
    LOCAL nPos
    LOCAL oLine

    DEFAULT aOptionalArray IS {}

    nPos := ASCAN( ::lines, {|x| x:key == cKey } )
    IF EMPTY( nPos )

        oLine := GrouppedValuesLine():new()
        oLine:key   := cKey
        oLine:value := nValue
        oLine:optional_array := ACLONE( aOptionalArray )

        AADD( ::lines, oLine )
    ELSE
        ::lines[ nPos ]:value += nValue
        IF EMPTY( ::lines[ nPos ]:optional_array )
            ::lines[ nPos ]:optional_array := ACLONE( aOptionalArray )
        ENDIF
    ENDIF

    RETURN self

* ------------------------------------------------------------------ *
*   Объединить два объекта
    METHOD GrouppedValues:Join( oJoinWith )
* ------------------------------------------------------------------ *
    LOCAL nI

    FOR nI := 1 TO LEN( oJoinWith:lines )
        ::Put( oJoinWith:lines[ nI ]:key, oJoinWith:lines[ nI ]:value, oJoinWith:lines[ nI ]:optional_array )
    NEXT

    RETURN self

* ------------------------------------------------------------------ *
*   Объединить два объекта
    METHOD GrouppedValues:IsEmpty()
* ------------------------------------------------------------------ *
    RETURN LEN( ::lines ) == 0

    CLASS GrouppedValuesLine
    EXPORTED:
        VAR key
        VAR value
        VAR optional_array

        METHOD Init
    ENDCLASS

    METHOD GrouppedValuesLine:Init()
        ::key   := ""
        ::value := 0
        ::optional_array := {}
    RETURN self



* ------------------------------------------------------------------ *
* ------------------------------------------------------------------ *
* ------------------------------------------------------------------ *
*   КЛАССЫ
* ------------------------------------------------------------------ *
* ------------------------------------------------------------------ *
* ------------------------------------------------------------------ *
    CLASS CalcsByPerson
    EXPORTED:
        VAR lines
        VAR cCalcsAlias
        VAR cWagesAlias

        METHOD Init
        METHOD Load
        METHOD Reset

        METHOD Delete
    ENDCLASS
* ------------------------------------------------------------------ *
*   Конструктор
    METHOD CalcsByPerson:Init()
* ------------------------------------------------------------------ *
        ::cCalcsAlias := "CALCS"
        ::cWagesAlias := "WAGES"
        ::Reset()
    RETURN self

* ------------------------------------------------------------------ *
*   Сброс объекта, приведение его в исходное состояние
    METHOD CalcsByPerson:Reset()
* ------------------------------------------------------------------ *
        ::lines := {}
    RETURN self

* ------------------------------------------------------------------ *
*   Заполнить объект данными
    METHOD CalcsByPerson:Load( dMonth, cWagesCode, cWagesReccode, nModeFrom, nModeTo )
* ------------------------------------------------------------------ *
    LOCAL lResult := .F.
    LOCAL nCalcsRecno := 0
    LOCAL aCalcsScope := {}
    LOCAL cAlias := ALIAS()
    LOCAL oLine
    LOCAL cModeFrom
    LOCAL cModeTo

    IF SELECT( ::cWagesAlias ) > 0
        DEFAULT dMonth        IS (::cWagesAlias)->MONTH
        DEFAULT cWagesCode    IS (::cWagesAlias)->CODE
        DEFAULT cWagesReccode IS (::cWagesAlias)->RECCODE
    ELSE
        DEFAULT dMonth        IS CTOD( "" )
        DEFAULT cWagesCode    IS ""
        DEFAULT cWagesReccode IS ""
    ENDIF
    DEFAULT nModeFrom IS 0
    DEFAULT nModeTo   IS 99

    cModeFrom := STRZERO( nModeFrom, 2 )
    cModeTo   := STRZERO( nModeTo  , 2 )

    BEGIN SEQUENCE

        ::Reset()

        DBSELECTAREA(::cCalcsAlias)
        nCalcsRecno := RECNO()
        aCalcsScope := SaveScope()
        SaveSet()

        DB_SETORDER( "CODE" )
        SET SCOPE TO DTOS( BOM( dMonth ) ) + cWagesCode + cWagesReccode + cModeFrom,;
                     DTOS( BOM( dMonth ) ) + cWagesCode + cWagesReccode + cModeTo
        GO TOP

        DO WHILE ! EOF()
            oLine := CalcsByPersonLine():new()
            oLIne:cCalcsAlias := ::cCalcsAlias
            oLIne:cWagesAlias := ::cWagesAlias
            IF !oLine:LoadCurrent()
                ::Reset()
                BREAK
            ENDIF
            AADD( ::lines, oLine )
            SKIP
        ENDDO

        lResult := .T.
    END SEQUENCE

    (::cCalcsAlias)->(RestSet())
    IF !EMPTY( aCalcsScope )
        RestScope( aCalcsScope )
    ENDIF
    IF !EMPTY( nCalcsRecno )
        DBGOTO( nCalcsRecno )
    ENDIF

    DbSelectArea( cAlias )

    RETURN lResult

* ------------------------------------------------------------------ *
*   Удаление помеченных к удалению записей
    METHOD CalcsByPerson:Delete()
* ------------------------------------------------------------------ *
    LOCAL lResult := .F.
    LOCAL nI
    LOCAL oLine

    SaveSet()
    BEGIN SEQUENCE

        IF SELECT( ::cCalcsAlias ) <= 0
            BREAK
        ENDIF

        FOR nI := 1 TO LEN( ::lines )
            oLine := ::lines[ nI ]
            IF oLine:IsDeleted()
                (::cCalcsAlias)->( DBGOTO( oLine:recno ) )
                (::cCalcsAlias)->( SOFT_DELETE() )
            ENDIF
        NEXT

        lResult := .T.
    END SEQUENCE
    RestSet()

    RETURN lResult


* ------------------------------------------------------------------ *
*   Класс - запись в CALCS для сотрудника
* ------------------------------------------------------------------ *

    CLASS CalcsByPersonLine FROM HashIVar
    HIDDEN:
        VAR marked_as_deleted // запись помечена на удаление

    EXPORTED:
        VAR recno        // Номер записи в рабочей таблице

        VAR cCalcsAlias
        VAR cWagesAlias

        VAR paysheet    // объект платеженой ведомости, в которую включена данная запись

        VAR reccode
        VAR paytype
        VAR person_code
        VAR wages_code
        VAR wages_type
        VAR mode
        VAR group
        VAR month
        VAR summa
        VAR dacc
        VAR refbu
        VAR fkr
        VAR post
        //переменные продублированы в WageMethods:GroupBy()!!!!!!!!!!

        VAR CalcsAcc     // Объект корреспонденции счетов
//        VAR ohAnalit // Хэш с набором аналитики, причем, приоритетными
                     // значениями является аналитика зарплатного счета

        METHOD Init
        METHOD LoadCurrent
        METHOD Delete
        METHOD IsDeleted

    ENDCLASS

* ------------------------------------------------------------------ *
*   Коснтруктор
    METHOD CalcsByPersonLine:Init()
* ------------------------------------------------------------------ *
        ::cCalcsAlias       := "CALCS"
        ::cWagesAlias       := "WAGES"
        ::recno             := 0
        ::marked_as_deleted := .F.
        ::reccode           := ""
        ::paytype           := ""
        ::person_code       := ""
        ::wages_code        := ""
        ::wages_type        := 0
        ::mode              := 0
        ::month             := CTOD( "" )
        ::summa             := 0
        ::dacc              := ""
        ::refbu             := " "
        ::fkr               := ""
        ::paysheet          := NIL
        ::post              := ""
    RETURN self

* ------------------------------------------------------------------ *
*   Загрузить текущую запись из калкса
    METHOD CalcsByPersonLine:LoadCurrent( ohParams )
* ------------------------------------------------------------------ *
    LOCAL lResult := .F.
    LOCAL cShlstCode
    LOCAL xTemp

    IF SELECT( "ACCNT" ) = 0 .AND. ! ReferInit( { "ACCNT", "ACKGU" } )
        RETURN lResult
    ENDIF

    IF SELECT( ::cCalcsAlias  ) > 0 .AND. SELECT( ::cWagesAlias ) > 0 ;
        .AND. !(::cCalcsAlias)->( EOF() ) ;
        .AND. !(::cWagesAlias)->( EOF() )

        SaveSet()
        DBSELECTAREA( ::cCalcsAlias )
        ::recno       := RECNO()
        ::reccode     := FIELD->RECCODE
        ::paytype     := FIELD->PAYTYPE
        ::person_code := FIELD->CODE
        ::wages_code  := FIELD->WAGESCODE
        ::wages_type  := (::cWagesAlias)->TYPE
        ::mode        := FIELD->MODE
        ::group       := FIELD->GROUP
        ::month       := FIELD->MONTH
        ::summa       := FIELD->SUMMA
        ::post        := FIELD->POST
        RestSet()

        // загрузка платежной ведомости
        cShlstCode := CalcSheets():CalcShlstCode( ohParams )
        IF !EMPTY( cShLstCode )
            ::paysheet := PaySheet():new()
            IF !::paysheet:LoadByLineReccode( cShlstCode )
                ::paysheet := NIL
            ENDIF
        ENDIF

        ::CalcsAcc := CalcsAccs():new()
        ::CalcsAcc:lIsPlus := ( ::mode < 40 )
        IF ! ::CalcsAcc:LoadFromCalcs(::cCalcsAlias)
            RETURN lResult
        ENDIF

        lResult := .T.
    ENDIF
    RETURN lResult

* ------------------------------------------------------------------ *
*   Типа, удалить запись в калксе ( пометить на удаление )
    METHOD CalcsByPersonLine:Delete()
* ------------------------------------------------------------------ *
    ::marked_as_deleted := .T.
    RETURN self

* ------------------------------------------------------------------ *
*   А не помечена ли запись в калксе на удаление
    METHOD CalcsByPersonLine:IsDeleted()
* ------------------------------------------------------------------ *
    RETURN ::marked_as_deleted


* ------------------------------------------------------------------ *
*   Класс - методы анализа и обработки архива зарплаты
* ------------------------------------------------------------------ *

    CLASS WageMethods

    HIDDEN:

    EXPORTED:
        VAR lines
        VAR stats  //хэш с суммами (HashWithSum)
        VAR cCalcsAlias
        VAR cWagesAlias

        METHOD Init
        METHOD Reset
        METHOD Load
        METHOD GroupBy //заполняет хэш stats

    ENDCLASS

* ------------------------------------------------------------------ *
*   Конструктор
    METHOD WageMethods:Init()
* ------------------------------------------------------------------ *
        ::cCalcsAlias := "CALCS"
        ::cWagesAlias := "WAGES"
        ::Reset()
    RETURN self

* ------------------------------------------------------------------ *
*   Сброс объекта, приведение его в исходное состояние
    METHOD WageMethods:Reset()
* ------------------------------------------------------------------ *
        ::lines := {}
        ::stats := HashWithSum():New()
    RETURN self

* ------------------------------------------------------------------ *
*   Заполнить объект данными
    METHOD WageMethods:Load( dMonth, cWagesCode, cWagesReccode, nModeFrom, nModeTo )
* ------------------------------------------------------------------ *
    LOCAL oCalcsLines := CalcsByPerson():New()
    LOCAL lResult

    oCalcsLines:cCalcsAlias := ::cCalcsAlias
    oCalcsLines:cWagesAlias := ::cWagesAlias
    lResult := oCalcsLines:Load( dMonth, cWagesCode, cWagesReccode, nModeFrom, nModeTo )

        ::Reset()
        IF lResult
            ::lines := oCalcsLines:lines
        ENDIF
    RETURN lResult

* ------------------------------------------------------------------ *
*   Заполнить объект данными
    METHOD WageMethods:GroupBy( cVar )
* ------------------------------------------------------------------ *
    LOCAL nI, cValue, nSum
    LOCAL aGroupedValues := {}
    LOCAL nJ

    //сбросим отчет (хэш)
    ::stats := HashWithSum():New()

    IF VALTYPE(cVar) = "C"
        IF EMPTY(cVar) .OR. ;
                !ALLTRIM(LOWER(cVar)) $ ("recno;marked_as_deleted;reccode;paytype;person_code;"+;
                "wages_code;mode;month;summa;dacc;refbu;fkr;paysheet;post")
            RETURN self
        ENDIF
        aGroupedValues := { cVar }
    ELSEIF VALTYPE(cVar) = "A"
        FOR nJ := 1 TO LEN( cVar )
            IF EMPTY(cVar[nJ]) .OR. ;
                    !ALLTRIM(LOWER(cVar[nJ])) $ ("recno;marked_as_deleted;reccode;paytype;person_code;"+;
                    "wages_code;mode;month;summa;dacc;refbu;fkr;paysheet;post")
                RETURN self
            ENDIF
            AADD( aGroupedValues, cVar[nI] )
        NEXT
    ELSE
        RETURN self
    ENDIF
    IF !EMPTY(::lines)
        FOR nI := 1 TO LEN(::lines)
            FOR nJ := 1 TO LEN( aGroupedValues )
                cValue := ::lines[nI]:&( ALLTRIM(LOWER(aGroupedValues[nJ])) )
            NEXT
            IF !EMPTY(cValue)
                nSum := ::lines[nI]:summa
                ::stats:Add(cValue,nSum)
            ENDIF
        NEXT
    ENDIF

    RETURN self


*------------------------------------------------------*
*   Перерасчета зарплаты за предыдущий период

    STATIC PROCEDURE SBT_Pereraschet(cCode, cJobsCode, dSdate, dFdate)
*------------------------------------------------------*
    LOCAL aPayInfo, nCount, nWork, nDays, cPaytype
    LOCAL oHash, oCalcsAcc, lMayBeAppend
    LOCAL nIndex, aCalcsHash
    LOCAL cJobtbFileName, cSort, dDate
    LOCAL nStart, nEnd, aFields, nOffs, nD, aDays, aFieldsPtrn
    LOCAL cKey, aTabPtrn, aParam
    LOCAL nWrkdDays
    LOCAL aWeekParam, dSDateTemp:= dSDate
    LOCAL lFlag
    LOCAL dFDateTemp, nType, aScope, aVactn, dSVactn, dFVactn

    Saveset()

    aScope := Savescope()
    BEGIN SEQUENCE

        DBCLOSE("VACTN")

        IF ! ReferInit( { "PYMNT" } )
            BREAK
        ENDIF

        IF .NOT. MODINIT( { "VACTN" } )
            BREAK
        ENDIF

        aParam := { MEMVAR->aCfgFio[ 15 ], MEMVAR->aCfgFio[ 16 ] }

        IF !aParam[ 1 ]
            nType := 1
        ELSE
            IF EMPTY( aParam[ 2 ] )
                nType := 1
            ELSE
                cPaytype := aParam[ 2 ]
                nType := 2
            ENDIF
        ENDIF


        IF nType != 1
            //Проверим  есть ли в справочнике начислений вид начисления пер.бл (если что добавим)
            lFlag := !EMPTY( Extract( {}, "ARR", SprPath + "pymnt.dbf", { "NAME" }, { "CODE", cPaytype } ) )
            IF !lFlag
                BEGIN SEQUENCE
                DbSelectArea( "PYMNT" )
                DBAPPEND()
                FIELD->ITEMCODE := "0"
                FIELD->NAME     := "Перерасчет зарплаты"
                FIELD->CODE     := cPaytype
                FIELD->PRIORITY := 0
                FIELD->ROUND    := 0
                FIELD->GROUP    := 25
                FIELD->DACC     := "040120"
                FIELD->DKGU     := "211"
                FIELD->KACC     := "030211"
                FIELD->KKGU     := "730"
                FIELD->GNI01    := "2000"
                FIELD->SOCFND   := "ДхЕС"
                FIELD->IMPORTED := .T.
                FIELD->METOD    := "W_HOSP"
                FIELD->METODNOTE:= "Перерасчет зарплаты"
                FIELD->SAYMETOD := "{|x| ALLTRIM(p(x, 10))}"
                FIELD->EDITMETOD:= "{|x,y| MacroRun( ModSysPath+'W_HOSP.MAC','N',{y,x})}"
                FIELD->COUNTMETOD:= "{||NIL}"
                FIELD->RESERVED := .T.
                END SEQUENCE
            ENDIF
        // Получим массив видов оплат по таблице входимости
        // Вид массива: { PAYTYPE, COMMENT, SUMMA, POST, DACC, GROUP }
            DO WHILE (BOM(dSDateTemp) <= BOM(dFDate)) .AND. (BOM(dSdateTemp)!=BOM(MEMVAR->DATE))
                dFdateTemp := IF(BOM(dSdateTemp)==BOM(dFdate),dFdate,EOM(dSdateTemp))
                aPayInfo := SumByEntry( cPaytype, dsDateTemp, cJobsCode, 12 )
                nCount := 1
                aCalcsHash := {}

                cJobtbFileName := FILE_NAME("JOBTB", MEMVAR->ENT,, YEAR(dSDATETEMP))
                // Если расшифровка по видам оплат - добавляем виды оплат
                DO WHILE nCount <= LEN( aPayInfo )
                    oCalcsAcc := aPayInfo[ nCount ][8]
                    IF !EMPTY(CalcIsPresent( aPayInfo[ nCount ][ 1 ],;      // 1 Вид оплаты
                                       20,;                                 // 2 Режим
                                       aPayInfo[ nCount ][ 4 ],;            // 3 Должность сотрудника
                                       WAGES->JOBSCODE,;                    // 4
                                       CALCR->CODE,;                        // 5
                                       ,;                                   // 6 (не используется)
                                       ,;                                   // 7 (не используется)
                                       oCalcsAcc:wacc,;                     // 8 Счет
                                       ,;                                   // 9 Проверять ли включенность в ведомость (не используется)
                                       ,;                                   // 10 ФКР (не используется)
                                       , ;                                  // 11 Вид деятельности (не используется)
                                       dsDateTemp, ;                        // 12
                                       dFDateTemp  ) )                      // 13
                        nCount := nCount + 1
                        LOOP
                    ENDIF
                    IF aPayInfo[ nCount ][ 9 ] == 20
                        aVactn := Extract({},"ARR", "VACTN",{"POST", "SDATE", "FDATE"},{"TABEL", MEMVAR->ENT + cCode + cJobscode, MEMVAR->ENT + cCode + cJobscode})
                        ASORT( aVactn,,, {|aX,aY| aX[2] < aY[2] } )
                        IF EMPTY(aVactn)
                            cKey       := cCode + cJobscode + aPayInfo[ nCount ][ 4 ] + DTOS(BOM(dSDateTemp))
                            aWeekParam := Extract({0,0,0}, "VAL", cJobtbFileName, {"WEEKTYPE", "LDAY", "IF(LDAY, WRKDHOURS, WRKDDAYS)"}, {"ANYPOST2", cKey}, .F.)
                            nWrkdDays  := GetNumRecalcDays(cCode, cJobsCode, aPayInfo[ nCount ][ 4 ], dSDateTemp, dFDateTemp, aWeekParam[1], aWeekParam[2], .T., .T.)
                        ENDIF
                        FOR nIndex:=1 TO LEN(aVactn)
                            IF (aVactn[nIndex][2] >= dSDateTemp .AND. aVactn[nIndex][2] <= dFDateTemp) .OR.(aVactn[nIndex][3] >= dSDateTemp .AND. aVactn[nIndex][3] <= dFDateTemp).OR.(BOM(aVactn[nIndex][2]) <= BOM(dSDateTemp)) .AND. (BOM(aVactn[nIndex][3]) >= BOM(dFDateTemp))
                                IF (aVactn[nIndex][2] >= dSDateTemp .AND. aVactn[nIndex][2] <= dFDateTemp) // дата начала внутри периода
                                    dSVactn := aVactn[nIndex][2]
                                ELSEIF (BOM(aVactn[nIndex][2]) <= BOM(dSDateTemp))
                                    dSVactn := dSDateTemp
                                ENDIF
                                IF (aVactn[nIndex][3] >= dSDateTemp .AND. aVactn[nIndex][3] <= dFDateTemp)// дата конца внутри периода
                                    dFVactn := aVactn[nIndex][3]
                                ELSEIF (BOM(aVactn[nIndex][3]) >= BOM(dFDateTemp))
                                    dFVactn := dFDateTemp
                                ENDIF
                            ENDIF
                            IF !EMPTY(dSVactn) .AND. !EMPTY(dFVactn)
                                cKey         := cCode + cJobscode + aPayInfo[ nCount ][ 4 ] + DTOS(BOM(dSVactn))
                                aWeekParam   := {"","",0}
                                aWeekParam[3]:= GetNumRecalcDays(cCode, cJobsCode, aPayInfo[ nCount ][ 4 ], aVactn[nIndex][2], aVactn[nIndex][3], 3, .F., .F., .T.)
                                nWrkdDays    := GetNumRecalcDays(cCode, cJobsCode, aPayInfo[ nCount ][ 4 ], dSVactn,           dFVactn,           3, .F., .F., .T.)
                                EXIT
                            ENDIF
                        NEXT
                    ELSE
                        cKey       := cCode + cJobscode + aPayInfo[ nCount ][ 4 ] + DTOS(BOM(dSDateTemp))
                        aWeekParam := Extract({0,0,0}, "VAL", cJobtbFileName, {"WEEKTYPE", "LDAY", "IF(LDAY, WRKDHOURS, WRKDDAYS)"}, {"ANYPOST2", cKey}, .F.)
                        nWrkdDays  := GetNumRecalcDays(cCode, cJobsCode, aPayInfo[ nCount ][ 4 ], dSDateTemp, dFDateTemp, aWeekParam[1], aWeekParam[2], .T., .T.)
                    ENDIF
                    IF !(ABS(D( aPayInfo[ nCount ][ 3 ], aWeekParam[3]) * nWrkdDays) < 0.01)
                        oHash      := HashIVar():new()
                        oHash:reccode    := CALCS->( UQ_CODE() )
                        oHash:month      := MEMVAR->DATE
                        oHash:jobscode   := WAGES->JOBSCODE
                        oHash:wagescode  := WAGES->RECCODE
                        oHash:code       := WAGES->CODE
                        oHash:mode       := 30
                        oHash:paytype    := aPayInfo[ nCount ][ 1 ]
                        oHash:comment    := aPayInfo[ nCount ][ 2 ]
                        oHash:summa      := -( D( aPayInfo[ nCount ][ 3 ], aWeekParam[3] ) * nWrkdDays )
                        oHash:post       := aPayInfo[ nCount ][ 4 ]
                        oHash:group      := aPayInfo[ nCount ][ 6 ]
                        oHash:dateproduc := dsDateTemp
                        oHash:fdaterec   := dfDateTemp
                        // Автоматический перерасчет всегда отрицательный - необходимо указывать знак перерасчета для
                        // последующей корректной отработки расчета среднедневной ставки больничных и отпускных
                        oHash:put( "param", "/-///////" + "100/П-расч." + SayDate( dsDateTemp, "MMM YYYYг" ) + " " + ZR(XTOC( nWrkdDays )) + "дн.(" + ZR(XTOC( aWeekParam[3])) + ")" )
                        AADD( aCalcsHash, { oHash, oCalcsAcc } )
                    ENDIF
                    nCount := nCount + 1
                ENDDO
                dSdateTemp := BOM(ADDMONTH(dSdateTemp,1))
                lMayBeAppend := .T.
                FOR nIndex := 1 TO LEN( aCalcsHash )
                    oHash := aCalcsHash[ nIndex ][ 1 ]
                    //проверяем, нет ли в среди начислений аналогичных записей, добавленных вручную
                    IF ! CalcMayBeModified( oHash:paytype, ;        // 1
                                                       30, ;        // 2
                                                oHash:post,;        // 3
                                           oHash:jobscode, ;        // 4
                                                      NIL, ;        // 5
                                                         , ;        // 6
                                                         , ;        // 7
                                aCalcsHash[nIndex][2]:wacc,;        // 8
                                                         , ;        // 9
                                                          ,;        // 10
                                                     ,,,.F.)
                    // Хотя бы одна запись не может быть добавлена - все прерываем и выходим
                        lMayBeAppend := .F.
                        EXIT
                    ENDIF
                NEXT
                IF lMayBeAppend
                    FOR nIndex := 1 TO LEN( aCalcsHash )
                        oHash := aCalcsHash[ nIndex ][ 1 ]
                        AddRecordAndWriteHash( oHash, "CALCS", .T. )
                        CALCS->( CalcsObjectToTable( aCalcsHash[ nIndex ][ 2 ] ) )
                    NEXT
                ELSE
                    Message( "!Запись не может быть добавлена. Вероятно, существует окончательная ведомость по какому-либо из счетов" )
                ENDIF
            ENDDO
        ENDIF

        DBCLOSE("VACTN")

    END SEQUENCE

    RestSet()

    RestScope( aScope)
 RETURN

*------------------------------------------------------*
*  Получение кол-ва дней по которым будет перерасчет
    FUNCTION GetNumRecalcDays(cCode, cJobsCode,cPost, dSDate, dFDate, nWType, lLDay, lTabelGrafic, lWorkDay)
*------------------------------------------------------*

    LOCAL nDays, cFileName, nI
    LOCAL aFields, nDay
    LOCAL nWeekType, nStart, nEnd

    LOCAL nOffs, aDays, aFieldsPtrn, aTabPtrn
    LOCAL cKey

    nDays := 0

    IF lTabelGrafic //если доначисление
        //  В расчет берутся все невыходные и непраздничные дни, входящие в период расчета
        //  за исключением тех дней по которым уже был расчет (стоит рабочий день)

        IF !EMPTY(cPost) .AND. !EMPTY(dSDate) .AND. !EMPTY(dFDate) .AND. BOM(dSDate)=BOM(dFDate) .AND. dSDate<=dFDate
           nStart  := DAY(dSDate)
           nEnd    := DAY(dFDate)

            aFields    := { "LDAY", "NORMDAYS", "WRKDDAYS", "NORMHOURS", "WRKDHOURS", "WEEKTYPE" }
            nOffs := LEN(aFields)
            FOR nDay := nStart TO nEnd
                AADD( aFields, "DAY" + STRZERO( nDay, 2 ) )
            NEXT
            //получение табеля для сотрудника
            cFileName := FILE_NAME("JOBTB", MEMVAR->ENT,,YEAR( dSDate) )
            IF Path:FExist(cFileName)
                aDays := EXTRACT( {}, "VAL", cFileName, aFields, {"ANYPOST2", cCode + cJobsCode + cPost + DTOS(BOM( dSDate ) ) } )
            ELSE
                aDays := {}
            ENDIF

            aFieldsPtrn    := {}
            FOR nDay := nStart TO nEnd
                AADD( aFieldsPtrn, "CHA" + STRZERO( nDay, 2 ) )
            NEXT

            //получение графика рабочей недели
            cFileName := MEMVAR->SprPath + "wrkgr.dbf"
            IF Path:FExist(cFileName)
                cKey := IF (!EMPTY(aDays), STRZERO(aDays[6],3) + DTOS(BOM(dSDate)),"000" + DTOS(BOM(dSDate)))
                aTabPtrn := EXTRACT( {}, "VAL", cFileName, aFieldsPtrn, {"NUM", cKey } )
            ELSE
                aTabPtrn := {}
            ENDIF

            IF EMPTY( aTabPtrn )
                RETURN 0
            ENDIF

            nDays := 0
            FOR nI := 1 TO nEnd - nStart + 1
                IF aTabPtrn[nI]>0
                    IF lWorkDay
                        IF (!EMPTY(aDays) .AND. VAL(aDays[nI+nOffs]) > 0) .OR. EMPTY(aDays)
                            // учет работы в днях/часах
                            IF !aDays[ 1 ]
                                nDays++ // ИЩЕТ ОТРАБОТАННЫЕ ДНИ  (ПО ТАБЕЛЮ)
                            ELSE
                                nDays += VAL(aDays[nI+nOffs])
                            ENDIF
                        ENDIF
                    ELSE
                        IF (!EMPTY(aDays) .AND. VAL(aDays[nI+nOffs]) == 0) .OR. EMPTY(aDays)
                            nDays++ // ИЩЕТ НЕОТРАБОТАННЫЕ ДНИ (ПО ТАБЕЛЮ)
                        ENDIF
                    ENDIF
                ENDIF
            NEXT
        ENDIF
    ELSE
        //считаем кол-во рабочих дней по графику
        IF !EMPTY(dSDate) .AND. !EMPTY(dFDate) .AND. BOM(dSDate)=BOM(dFDate) .AND. dSDate<=dFDate
            nDays := NormDays(dSDate,dFDate, nWType,lLDay)
        ENDIF
    ENDIF

    RETURN nDays
*------------------------------------------------------*
*   Выбор должности по человеку из всего учреждения (включая отделы)

    FUNCTION WagesPostSelectByENT( cPost, nStav, nRazr, xStav, nDays, nWork, lHours, cWagescode, cJobsCode)
*------------------------------------------------------*
    // nPost - должность
    // nStav - кол-во ставок
    // nRazr - разряд

    // Сохраним установки на JOBTB
    LOCAL nRecno
    LOCAL nOrder
    LOCAL aSelect
    LOCAL aTemp
    LOCAL aScope
    LOCAL cEnt, aEntType, cJobName , nI, aPost, nJ
    LOCAL aResult := {}

    DEFAULT lHours IS .F.
    DEFAULT cWagescode IS WAGES->CODE
    DEFAULT cJobsCode IS WAGES->JOBSCODE

    aResult := {}

    IF SELECT( "JOBTB" ) == 0
        RETURN aResult
    ENDIF

    SaveSet()

    JOBTB->( SaveSet() )
    aScope := JOBTB->( SaveScope() )

    BEGIN SEQUENCE

    aPost    := {}
    aEntType := GetTreeEnts(MEMVAR->ENT)

    FOR nI:=1 TO LEN(aEntType)
        cJobName  := FILE_NAME( "JOBTB", aEnttype[nI],,Year(MEMVAR->DATE) )
        IF Path:FExist(cJobName)
            aTemp := EXTRACT( {}, "ARR", cJobName, {"SAYREFER('POSTS', FIELD->POST) ",".T.","TRRECCODE",;
                     "NORMDAYS", /*5*/ "WRKDDAYS", "NORMHOURS", "WRKDHOURS","POST", "'"+aEntType[nI]+"'"}, ;
                     {"CODE", DTOS( BOM( MEMVAR->DATE ) ) + cWagesCode, DTOS( BOM( MEMVAR->DATE ) ) + cWagesCode })
            FOR nJ:=1 TO LEN(aTemp)
                AADD(aPost , aTemp[nJ])
            NEXT
        ENDIF
    NEXT

    IF !EMPTY( aPost )
        nI := SPRSELECT( aPost )
        IF !EMPTY( nI )

            aTemp := EXTRACT({0,"",0},"VAL", FILE_NAME("TRREC", aPost[nI][9]), {"KSTAV","RAZ", xStav[1]},;
                     {"RECCODE", aPost[nI][3], aPost[nI][3]} )
            aResult := {aPost[nI][8], aTemp[1], aTemp[2], aTemp[3],  IF(!lHours, {aPost[nI][4],aPost[nI][6]},{aPost[nI][5],aPost[nI][7]})}

        ENDIF
    ENDIF

    END SEQUENCE

    // Восстановим установки на JOBTB
    JOBTB->( RestSet() )
    JOBTB->( RestScope(aScope) )

    RestSet()

    RETURN aResult

//**************************************************************
//  Проверка хэш на актуальность и заполнение в случае, если не актуален
    STATIC PROCEDURE CheckAndUpdateTaxHash()
//**************************************************************
    LOCAL cFName := MEMVAR->SprPath + "pymnt.dbf"
    LOCAL cSignFile := DTOS( FILEDATE( cFName ) ) + FILETIME( cFName )

    IF ! ( cSignFile == MEMVAR->ohTax:get( "ПодписьФайла" ) ) // штамп даты/времени не совпадают
        // значит, были произведены изменения
        MEMVAR->ohTax:Clear()

        Extract( {}, "ARR", cFName, "ZERO( MEMVAR->ohTax:put( FIELD->CODE, FIELD->GNI01 ), .T. )", "!EMPTY(GNI01)" )
        MEMVAR->ohTax:put( "ПодписьФайла", cSignFile )
    ENDIF

    RETURN
